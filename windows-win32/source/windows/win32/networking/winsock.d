module windows.win32.networking.winsock;

import windows.win32.guid : GUID;
import windows.win32.foundation : BOOL, BOOLEAN, CHAR, FARPROC, HANDLE, HRESULT, HWND, LPARAM, LUID, PSTR, PWSTR, WAIT_EVENT, WPARAM;
import windows.win32.system.com : BLOB;
import windows.win32.system.io : OVERLAPPED, OVERLAPPED_ENTRY;
import windows.win32.system.kernel : COMPARTMENT_ID, PROCESSOR_NUMBER;

version (Windows):
extern (Windows):

alias WSA_ERROR = int;
enum : int
{
    WSA_IO_PENDING              = 0x000003e5,
    WSA_IO_INCOMPLETE           = 0x000003e4,
    WSA_INVALID_HANDLE          = 0x00000006,
    WSA_INVALID_PARAMETER       = 0x00000057,
    WSA_NOT_ENOUGH_MEMORY       = 0x00000008,
    WSA_OPERATION_ABORTED       = 0x000003e3,
    WSA_WAIT_EVENT_0            = 0x00000000,
    WSA_WAIT_IO_COMPLETION      = 0x000000c0,
    WSABASEERR                  = 0x00002710,
    WSAEINTR                    = 0x00002714,
    WSAEBADF                    = 0x00002719,
    WSAEACCES                   = 0x0000271d,
    WSAEFAULT                   = 0x0000271e,
    WSAEINVAL                   = 0x00002726,
    WSAEMFILE                   = 0x00002728,
    WSAEWOULDBLOCK              = 0x00002733,
    WSAEINPROGRESS              = 0x00002734,
    WSAEALREADY                 = 0x00002735,
    WSAENOTSOCK                 = 0x00002736,
    WSAEDESTADDRREQ             = 0x00002737,
    WSAEMSGSIZE                 = 0x00002738,
    WSAEPROTOTYPE               = 0x00002739,
    WSAENOPROTOOPT              = 0x0000273a,
    WSAEPROTONOSUPPORT          = 0x0000273b,
    WSAESOCKTNOSUPPORT          = 0x0000273c,
    WSAEOPNOTSUPP               = 0x0000273d,
    WSAEPFNOSUPPORT             = 0x0000273e,
    WSAEAFNOSUPPORT             = 0x0000273f,
    WSAEADDRINUSE               = 0x00002740,
    WSAEADDRNOTAVAIL            = 0x00002741,
    WSAENETDOWN                 = 0x00002742,
    WSAENETUNREACH              = 0x00002743,
    WSAENETRESET                = 0x00002744,
    WSAECONNABORTED             = 0x00002745,
    WSAECONNRESET               = 0x00002746,
    WSAENOBUFS                  = 0x00002747,
    WSAEISCONN                  = 0x00002748,
    WSAENOTCONN                 = 0x00002749,
    WSAESHUTDOWN                = 0x0000274a,
    WSAETOOMANYREFS             = 0x0000274b,
    WSAETIMEDOUT                = 0x0000274c,
    WSAECONNREFUSED             = 0x0000274d,
    WSAELOOP                    = 0x0000274e,
    WSAENAMETOOLONG             = 0x0000274f,
    WSAEHOSTDOWN                = 0x00002750,
    WSAEHOSTUNREACH             = 0x00002751,
    WSAENOTEMPTY                = 0x00002752,
    WSAEPROCLIM                 = 0x00002753,
    WSAEUSERS                   = 0x00002754,
    WSAEDQUOT                   = 0x00002755,
    WSAESTALE                   = 0x00002756,
    WSAEREMOTE                  = 0x00002757,
    WSASYSNOTREADY              = 0x0000276b,
    WSAVERNOTSUPPORTED          = 0x0000276c,
    WSANOTINITIALISED           = 0x0000276d,
    WSAEDISCON                  = 0x00002775,
    WSAENOMORE                  = 0x00002776,
    WSAECANCELLED               = 0x00002777,
    WSAEINVALIDPROCTABLE        = 0x00002778,
    WSAEINVALIDPROVIDER         = 0x00002779,
    WSAEPROVIDERFAILEDINIT      = 0x0000277a,
    WSASYSCALLFAILURE           = 0x0000277b,
    WSASERVICE_NOT_FOUND        = 0x0000277c,
    WSATYPE_NOT_FOUND           = 0x0000277d,
    WSA_E_NO_MORE               = 0x0000277e,
    WSA_E_CANCELLED             = 0x0000277f,
    WSAEREFUSED                 = 0x00002780,
    WSAHOST_NOT_FOUND           = 0x00002af9,
    WSATRY_AGAIN                = 0x00002afa,
    WSANO_RECOVERY              = 0x00002afb,
    WSANO_DATA                  = 0x00002afc,
    WSA_QOS_RECEIVERS           = 0x00002afd,
    WSA_QOS_SENDERS             = 0x00002afe,
    WSA_QOS_NO_SENDERS          = 0x00002aff,
    WSA_QOS_NO_RECEIVERS        = 0x00002b00,
    WSA_QOS_REQUEST_CONFIRMED   = 0x00002b01,
    WSA_QOS_ADMISSION_FAILURE   = 0x00002b02,
    WSA_QOS_POLICY_FAILURE      = 0x00002b03,
    WSA_QOS_BAD_STYLE           = 0x00002b04,
    WSA_QOS_BAD_OBJECT          = 0x00002b05,
    WSA_QOS_TRAFFIC_CTRL_ERROR  = 0x00002b06,
    WSA_QOS_GENERIC_ERROR       = 0x00002b07,
    WSA_QOS_ESERVICETYPE        = 0x00002b08,
    WSA_QOS_EFLOWSPEC           = 0x00002b09,
    WSA_QOS_EPROVSPECBUF        = 0x00002b0a,
    WSA_QOS_EFILTERSTYLE        = 0x00002b0b,
    WSA_QOS_EFILTERTYPE         = 0x00002b0c,
    WSA_QOS_EFILTERCOUNT        = 0x00002b0d,
    WSA_QOS_EOBJLENGTH          = 0x00002b0e,
    WSA_QOS_EFLOWCOUNT          = 0x00002b0f,
    WSA_QOS_EUNKOWNPSOBJ        = 0x00002b10,
    WSA_QOS_EPOLICYOBJ          = 0x00002b11,
    WSA_QOS_EFLOWDESC           = 0x00002b12,
    WSA_QOS_EPSFLOWSPEC         = 0x00002b13,
    WSA_QOS_EPSFILTERSPEC       = 0x00002b14,
    WSA_QOS_ESDMODEOBJ          = 0x00002b15,
    WSA_QOS_ESHAPERATEOBJ       = 0x00002b16,
    WSA_QOS_RESERVED_PETYPE     = 0x00002b17,
    WSA_SECURE_HOST_NOT_FOUND   = 0x00002b18,
    WSA_IPSEC_NAME_POLICY_ERROR = 0x00002b19,
}

alias ADDRESS_FAMILY = ushort;
enum : ushort
{
    AF_INET   = 0x0002,
    AF_INET6  = 0x0017,
    AF_UNSPEC = 0x0000,
}

alias SET_SERVICE_OPERATION = uint;
enum : uint
{
    SERVICE_REGISTER    = 0x00000001,
    SERVICE_DEREGISTER  = 0x00000002,
    SERVICE_FLUSH       = 0x00000003,
    SERVICE_ADD_TYPE    = 0x00000004,
    SERVICE_DELETE_TYPE = 0x00000005,
}

alias SEND_RECV_FLAGS = int;
enum : int
{
    MSG_OOB            = 0x00000001,
    MSG_PEEK           = 0x00000002,
    MSG_DONTROUTE      = 0x00000004,
    MSG_WAITALL        = 0x00000008,
    MSG_PUSH_IMMEDIATE = 0x00000020,
}

alias RESOURCE_DISPLAY_TYPE = uint;
enum : uint
{
    RESOURCEDISPLAYTYPE_DOMAIN  = 0x00000001,
    RESOURCEDISPLAYTYPE_FILE    = 0x00000004,
    RESOURCEDISPLAYTYPE_GENERIC = 0x00000000,
    RESOURCEDISPLAYTYPE_GROUP   = 0x00000005,
    RESOURCEDISPLAYTYPE_SERVER  = 0x00000002,
    RESOURCEDISPLAYTYPE_SHARE   = 0x00000003,
    RESOURCEDISPLAYTYPE_TREE    = 0x0000000a,
}

alias WSAPOLL_EVENT_FLAGS = short;
enum : short
{
    POLLRDNORM = 0x0100,
    POLLRDBAND = 0x0200,
    POLLIN     = 0x0300,
    POLLPRI    = 0x0400,
    POLLWRNORM = 0x0010,
    POLLOUT    = 0x0010,
    POLLWRBAND = 0x0020,
    POLLERR    = 0x0001,
    POLLHUP    = 0x0002,
    POLLNVAL   = 0x0004,
}

alias WINSOCK_SHUTDOWN_HOW = int;
enum : int
{
    SD_RECEIVE = 0x00000000,
    SD_SEND    = 0x00000001,
    SD_BOTH    = 0x00000002,
}

alias WINSOCK_SOCKET_TYPE = int;
enum : int
{
    SOCK_STREAM    = 0x00000001,
    SOCK_DGRAM     = 0x00000002,
    SOCK_RAW       = 0x00000003,
    SOCK_RDM       = 0x00000004,
    SOCK_SEQPACKET = 0x00000005,
}

int WSCEnumProtocols32(int*, WSAPROTOCOL_INFOW*, uint*, int*);
int WSCDeinstallProvider32(GUID*, int*);
int WSCInstallProvider64_32(GUID*, const(wchar)*, const(WSAPROTOCOL_INFOW)*, uint, int*);
int WSCGetProviderPath32(GUID*, PWSTR, int*, int*);
int WSCUpdateProvider32(GUID*, const(wchar)*, const(WSAPROTOCOL_INFOW)*, uint, int*);
int WSCSetProviderInfo32(GUID*, WSC_PROVIDER_INFO_TYPE, ubyte*, ulong, uint, int*);
int WSCGetProviderInfo32(GUID*, WSC_PROVIDER_INFO_TYPE, ubyte*, ulong*, uint, int*);
int WSCEnumNameSpaceProviders32(uint*, WSANAMESPACE_INFOW*);
int WSCEnumNameSpaceProvidersEx32(uint*, WSANAMESPACE_INFOEXW*);
int WSCInstallNameSpace32(PWSTR, PWSTR, uint, uint, GUID*);
int WSCInstallNameSpaceEx32(PWSTR, PWSTR, uint, uint, GUID*, BLOB*);
int WSCUnInstallNameSpace32(GUID*);
int WSCEnableNSProvider32(GUID*, BOOL);
int WSCInstallProviderAndChains64_32(GUID*, const(wchar)*, const(wchar)*, const(wchar)*, uint, WSAPROTOCOL_INFOW*, uint, uint*, int*);
int WSCWriteProviderOrder32(uint*, uint);
int WSCWriteNameSpaceOrder32(GUID*, uint);
int __WSAFDIsSet(SOCKET, FD_SET*);
SOCKET accept(SOCKET, SOCKADDR*, int*);
int bind(SOCKET, const(SOCKADDR)*, int);
int closesocket(SOCKET);
int connect(SOCKET, const(SOCKADDR)*, int);
int ioctlsocket(SOCKET, int, uint*);
int getpeername(SOCKET, SOCKADDR*, int*);
int getsockname(SOCKET, SOCKADDR*, int*);
int getsockopt(SOCKET, int, int, PSTR, int*);
uint htonl(uint);
ushort htons(ushort);
uint inet_addr(const(char)*);
PSTR inet_ntoa(IN_ADDR);
int listen(SOCKET, int);
uint ntohl(uint);
ushort ntohs(ushort);
int recv(SOCKET, PSTR, int, SEND_RECV_FLAGS);
int recvfrom(SOCKET, PSTR, int, int, SOCKADDR*, int*);
int select(int, FD_SET*, FD_SET*, FD_SET*, const(TIMEVAL)*);
int send(SOCKET, const(char)*, int, SEND_RECV_FLAGS);
int sendto(SOCKET, const(char)*, int, int, const(SOCKADDR)*, int);
int setsockopt(SOCKET, int, int, const(char)*, int);
int shutdown(SOCKET, WINSOCK_SHUTDOWN_HOW);
SOCKET socket(int, WINSOCK_SOCKET_TYPE, int);
HOSTENT* gethostbyaddr(const(char)*, int, int);
HOSTENT* gethostbyname(const(char)*);
int gethostname(PSTR, int);
int GetHostNameW(PWSTR, int);
SERVENT* getservbyport(int, const(char)*);
SERVENT* getservbyname(const(char)*, const(char)*);
PROTOENT* getprotobynumber(int);
PROTOENT* getprotobyname(const(char)*);
int WSAStartup(ushort, WSADATA*);
int WSACleanup();
void WSASetLastError(int);
WSA_ERROR WSAGetLastError();
BOOL WSAIsBlocking();
int WSAUnhookBlockingHook();
FARPROC WSASetBlockingHook(FARPROC);
int WSACancelBlockingCall();
HANDLE WSAAsyncGetServByName(HWND, uint, const(char)*, const(char)*, PSTR, int);
HANDLE WSAAsyncGetServByPort(HWND, uint, int, const(char)*, PSTR, int);
HANDLE WSAAsyncGetProtoByName(HWND, uint, const(char)*, PSTR, int);
HANDLE WSAAsyncGetProtoByNumber(HWND, uint, int, PSTR, int);
HANDLE WSAAsyncGetHostByName(HWND, uint, const(char)*, PSTR, int);
HANDLE WSAAsyncGetHostByAddr(HWND, uint, const(char)*, int, int, PSTR, int);
int WSACancelAsyncRequest(HANDLE);
int WSAAsyncSelect(SOCKET, HWND, uint, int);
SOCKET WSAAccept(SOCKET, SOCKADDR*, int*, LPCONDITIONPROC, ulong);
BOOL WSACloseEvent(HANDLE);
int WSAConnect(SOCKET, const(SOCKADDR)*, int, WSABUF*, WSABUF*, QOS*, QOS*);
BOOL WSAConnectByNameW(SOCKET, PWSTR, PWSTR, uint*, SOCKADDR*, uint*, SOCKADDR*, const(TIMEVAL)*, OVERLAPPED*);
BOOL WSAConnectByNameA(SOCKET, const(char)*, const(char)*, uint*, SOCKADDR*, uint*, SOCKADDR*, const(TIMEVAL)*, OVERLAPPED*);
BOOL WSAConnectByList(SOCKET, SOCKET_ADDRESS_LIST*, uint*, SOCKADDR*, uint*, SOCKADDR*, const(TIMEVAL)*, OVERLAPPED*);
HANDLE WSACreateEvent();
int WSADuplicateSocketA(SOCKET, uint, WSAPROTOCOL_INFOA*);
int WSADuplicateSocketW(SOCKET, uint, WSAPROTOCOL_INFOW*);
int WSAEnumNetworkEvents(SOCKET, HANDLE, WSANETWORKEVENTS*);
int WSAEnumProtocolsA(int*, WSAPROTOCOL_INFOA*, uint*);
int WSAEnumProtocolsW(int*, WSAPROTOCOL_INFOW*, uint*);
int WSAEventSelect(SOCKET, HANDLE, int);
BOOL WSAGetOverlappedResult(SOCKET, OVERLAPPED*, uint*, BOOL, uint*);
BOOL WSAGetQOSByName(SOCKET, WSABUF*, QOS*);
int WSAHtonl(SOCKET, uint, uint*);
int WSAHtons(SOCKET, ushort, ushort*);
int WSAIoctl(SOCKET, uint, void*, uint, void*, uint, uint*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
SOCKET WSAJoinLeaf(SOCKET, const(SOCKADDR)*, int, WSABUF*, WSABUF*, QOS*, QOS*, uint);
int WSANtohl(SOCKET, uint, uint*);
int WSANtohs(SOCKET, ushort, ushort*);
int WSARecv(SOCKET, WSABUF*, uint, uint*, uint*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
int WSARecvDisconnect(SOCKET, WSABUF*);
int WSARecvFrom(SOCKET, WSABUF*, uint, uint*, uint*, SOCKADDR*, int*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
BOOL WSAResetEvent(HANDLE);
int WSASend(SOCKET, WSABUF*, uint, uint*, uint, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
int WSASendMsg(SOCKET, WSAMSG*, uint, uint*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
int WSASendDisconnect(SOCKET, WSABUF*);
int WSASendTo(SOCKET, WSABUF*, uint, uint*, uint, const(SOCKADDR)*, int, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
BOOL WSASetEvent(HANDLE);
SOCKET WSASocketA(int, int, int, WSAPROTOCOL_INFOA*, uint, uint);
SOCKET WSASocketW(int, int, int, WSAPROTOCOL_INFOW*, uint, uint);
WAIT_EVENT WSAWaitForMultipleEvents(uint, const(HANDLE)*, BOOL, uint, BOOL);
int WSAAddressToStringA(SOCKADDR*, uint, WSAPROTOCOL_INFOA*, PSTR, uint*);
int WSAAddressToStringW(SOCKADDR*, uint, WSAPROTOCOL_INFOW*, PWSTR, uint*);
int WSAStringToAddressA(PSTR, int, WSAPROTOCOL_INFOA*, SOCKADDR*, int*);
int WSAStringToAddressW(PWSTR, int, WSAPROTOCOL_INFOW*, SOCKADDR*, int*);
int WSALookupServiceBeginA(WSAQUERYSETA*, uint, HANDLE*);
int WSALookupServiceBeginW(WSAQUERYSETW*, uint, HANDLE*);
int WSALookupServiceNextA(HANDLE, uint, uint*, WSAQUERYSETA*);
int WSALookupServiceNextW(HANDLE, uint, uint*, WSAQUERYSETW*);
int WSANSPIoctl(HANDLE, uint, void*, uint, void*, uint, uint*, WSACOMPLETION*);
int WSALookupServiceEnd(HANDLE);
int WSAInstallServiceClassA(WSASERVICECLASSINFOA*);
int WSAInstallServiceClassW(WSASERVICECLASSINFOW*);
int WSARemoveServiceClass(GUID*);
int WSAGetServiceClassInfoA(GUID*, GUID*, uint*, WSASERVICECLASSINFOA*);
int WSAGetServiceClassInfoW(GUID*, GUID*, uint*, WSASERVICECLASSINFOW*);
int WSAEnumNameSpaceProvidersA(uint*, WSANAMESPACE_INFOA*);
int WSAEnumNameSpaceProvidersW(uint*, WSANAMESPACE_INFOW*);
int WSAEnumNameSpaceProvidersExA(uint*, WSANAMESPACE_INFOEXA*);
int WSAEnumNameSpaceProvidersExW(uint*, WSANAMESPACE_INFOEXW*);
int WSAGetServiceClassNameByClassIdA(GUID*, PSTR, uint*);
int WSAGetServiceClassNameByClassIdW(GUID*, PWSTR, uint*);
int WSASetServiceA(WSAQUERYSETA*, WSAESETSERVICEOP, uint);
int WSASetServiceW(WSAQUERYSETW*, WSAESETSERVICEOP, uint);
int WSAProviderConfigChange(HANDLE*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
int WSAPoll(WSAPOLLFD*, uint, int);
uint ProcessSocketNotifications(HANDLE, uint, SOCK_NOTIFY_REGISTRATION*, uint, uint, OVERLAPPED_ENTRY*, uint*);
PSTR RtlIpv4AddressToStringA(const(IN_ADDR)*, PSTR);
int RtlIpv4AddressToStringExA(const(IN_ADDR)*, ushort, PSTR, uint*);
PWSTR RtlIpv4AddressToStringW(const(IN_ADDR)*, PWSTR);
int RtlIpv4AddressToStringExW(const(IN_ADDR)*, ushort, PWSTR, uint*);
int RtlIpv4StringToAddressA(const(char)*, BOOLEAN, const(char)**, IN_ADDR*);
int RtlIpv4StringToAddressExA(const(char)*, BOOLEAN, IN_ADDR*, ushort*);
int RtlIpv4StringToAddressW(const(wchar)*, BOOLEAN, const(wchar)**, IN_ADDR*);
int RtlIpv4StringToAddressExW(const(wchar)*, BOOLEAN, IN_ADDR*, ushort*);
PSTR RtlIpv6AddressToStringA(const(IN6_ADDR)*, PSTR);
int RtlIpv6AddressToStringExA(const(IN6_ADDR)*, uint, ushort, PSTR, uint*);
PWSTR RtlIpv6AddressToStringW(const(IN6_ADDR)*, PWSTR);
int RtlIpv6AddressToStringExW(const(IN6_ADDR)*, uint, ushort, PWSTR, uint*);
int RtlIpv6StringToAddressA(const(char)*, const(char)**, IN6_ADDR*);
int RtlIpv6StringToAddressExA(const(char)*, IN6_ADDR*, uint*, ushort*);
int RtlIpv6StringToAddressW(const(wchar)*, const(wchar)**, IN6_ADDR*);
int RtlIpv6StringToAddressExW(const(wchar)*, IN6_ADDR*, uint*, ushort*);
PSTR RtlEthernetAddressToStringA(const(DL_EUI48)*, PSTR);
PWSTR RtlEthernetAddressToStringW(const(DL_EUI48)*, PWSTR);
int RtlEthernetStringToAddressA(const(char)*, const(char)**, DL_EUI48*);
int RtlEthernetStringToAddressW(const(wchar)*, const(wchar)**, DL_EUI48*);
int WSARecvEx(SOCKET, PSTR, int, int*);
BOOL TransmitFile(SOCKET, HANDLE, uint, uint, OVERLAPPED*, TRANSMIT_FILE_BUFFERS*, uint);
BOOL AcceptEx(SOCKET, SOCKET, void*, uint, uint, uint, uint*, OVERLAPPED*);
void GetAcceptExSockaddrs(void*, uint, uint, uint, SOCKADDR**, int*, SOCKADDR**, int*);
int WSCEnumProtocols(int*, WSAPROTOCOL_INFOW*, uint*, int*);
int WSCDeinstallProvider(GUID*, int*);
int WSCInstallProvider(GUID*, const(wchar)*, const(WSAPROTOCOL_INFOW)*, uint, int*);
int WSCGetProviderPath(GUID*, PWSTR, int*, int*);
int WSCUpdateProvider(GUID*, const(wchar)*, const(WSAPROTOCOL_INFOW)*, uint, int*);
int WSCSetProviderInfo(GUID*, WSC_PROVIDER_INFO_TYPE, ubyte*, ulong, uint, int*);
int WSCGetProviderInfo(GUID*, WSC_PROVIDER_INFO_TYPE, ubyte*, ulong*, uint, int*);
int WSCSetApplicationCategory(const(wchar)*, uint, const(wchar)*, uint, uint, uint*, int*);
int WSCGetApplicationCategory(const(wchar)*, uint, const(wchar)*, uint, uint*, int*);
int WPUCompleteOverlappedRequest(SOCKET, OVERLAPPED*, uint, uint, int*);
int WSCInstallNameSpace(PWSTR, PWSTR, uint, uint, GUID*);
int WSCUnInstallNameSpace(GUID*);
int WSCInstallNameSpaceEx(PWSTR, PWSTR, uint, uint, GUID*, BLOB*);
int WSCEnableNSProvider(GUID*, BOOL);
int WSAAdvertiseProvider(const(GUID)*, const(NSPV2_ROUTINE)*);
int WSAUnadvertiseProvider(const(GUID)*);
int WSAProviderCompleteAsyncCall(HANDLE, int);
int EnumProtocolsA(int*, void*, uint*);
int EnumProtocolsW(int*, void*, uint*);
int GetAddressByNameA(uint, GUID*, PSTR, int*, uint, SERVICE_ASYNC_INFO*, void*, uint*, PSTR, uint*);
int GetAddressByNameW(uint, GUID*, PWSTR, int*, uint, SERVICE_ASYNC_INFO*, void*, uint*, PWSTR, uint*);
int GetTypeByNameA(PSTR, GUID*);
int GetTypeByNameW(PWSTR, GUID*);
int GetNameByTypeA(GUID*, PSTR, uint);
int GetNameByTypeW(GUID*, PWSTR, uint);
int SetServiceA(uint, SET_SERVICE_OPERATION, uint, SERVICE_INFOA*, SERVICE_ASYNC_INFO*, uint*);
int SetServiceW(uint, SET_SERVICE_OPERATION, uint, SERVICE_INFOW*, SERVICE_ASYNC_INFO*, uint*);
int GetServiceA(uint, GUID*, PSTR, uint, void*, uint*, SERVICE_ASYNC_INFO*);
int GetServiceW(uint, GUID*, PWSTR, uint, void*, uint*, SERVICE_ASYNC_INFO*);
int getaddrinfo(const(char)*, const(char)*, const(ADDRINFOA)*, ADDRINFOA**);
int GetAddrInfoW(const(wchar)*, const(wchar)*, const(ADDRINFOW)*, ADDRINFOW**);
int GetAddrInfoExA(const(char)*, const(char)*, uint, GUID*, const(ADDRINFOEXA)*, ADDRINFOEXA**, TIMEVAL*, OVERLAPPED*, LPLOOKUPSERVICE_COMPLETION_ROUTINE, HANDLE*);
int GetAddrInfoExW(const(wchar)*, const(wchar)*, uint, GUID*, const(ADDRINFOEXW)*, ADDRINFOEXW**, TIMEVAL*, OVERLAPPED*, LPLOOKUPSERVICE_COMPLETION_ROUTINE, HANDLE*);
int GetAddrInfoExCancel(HANDLE*);
int GetAddrInfoExOverlappedResult(OVERLAPPED*);
int SetAddrInfoExA(const(char)*, const(char)*, SOCKET_ADDRESS*, uint, BLOB*, uint, uint, GUID*, TIMEVAL*, OVERLAPPED*, LPLOOKUPSERVICE_COMPLETION_ROUTINE, HANDLE*);
int SetAddrInfoExW(const(wchar)*, const(wchar)*, SOCKET_ADDRESS*, uint, BLOB*, uint, uint, GUID*, TIMEVAL*, OVERLAPPED*, LPLOOKUPSERVICE_COMPLETION_ROUTINE, HANDLE*);
void freeaddrinfo(ADDRINFOA*);
void FreeAddrInfoW(ADDRINFOW*);
void FreeAddrInfoEx(ADDRINFOEXA*);
void FreeAddrInfoExW(ADDRINFOEXW*);
int getnameinfo(const(SOCKADDR)*, socklen_t, PSTR, uint, PSTR, uint, int);
int GetNameInfoW(const(SOCKADDR)*, socklen_t, PWSTR, uint, PWSTR, uint, int);
int inet_pton(int, const(char)*, void*);
int InetPtonW(int, const(wchar)*, void*);
PSTR inet_ntop(int, const(void)*, PSTR, ulong);
PWSTR InetNtopW(int, const(void)*, PWSTR, ulong);
int WSASetSocketSecurity(SOCKET, const(SOCKET_SECURITY_SETTINGS)*, uint, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
int WSAQuerySocketSecurity(SOCKET, const(SOCKET_SECURITY_QUERY_TEMPLATE)*, uint, SOCKET_SECURITY_QUERY_INFO*, uint*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
int WSASetSocketPeerTargetName(SOCKET, const(SOCKET_PEER_TARGET_NAME)*, uint, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
int WSADeleteSocketPeerTargetName(SOCKET, const(SOCKADDR)*, uint, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
int WSAImpersonateSocketPeer(SOCKET, const(SOCKADDR)*, uint);
int WSARevertImpersonation();
HRESULT SetSocketMediaStreamingMode(BOOL);
int WSCWriteProviderOrder(uint*, uint);
int WSCWriteNameSpaceOrder(GUID*, uint);
enum SOCKET_DEFAULT2_QM_POLICY = GUID(0xaec2ef9c, 0x3a4d, 0x4d3e, [0x88, 0x42, 0x23, 0x99, 0x42, 0xe3, 0x9a, 0x47]);
enum REAL_TIME_NOTIFICATION_CAPABILITY = GUID(0x6b59819a, 0x5cae, 0x492d, [0xa9, 0x1, 0x2a, 0x3c, 0x2c, 0x50, 0x16, 0x4f]);
enum REAL_TIME_NOTIFICATION_CAPABILITY_EX = GUID(0x6843da03, 0x154a, 0x4616, [0xa5, 0x8, 0x44, 0x37, 0x12, 0x95, 0xf9, 0x6b]);
enum ASSOCIATE_NAMERES_CONTEXT = GUID(0x59a38b67, 0xd4fe, 0x46e1, [0xba, 0x3c, 0x87, 0xea, 0x74, 0xca, 0x30, 0x49]);
enum SIO_RCVALL = 0x98000001;
enum SIO_RCVALL_MCAST = 0x98000002;
enum SIO_RCVALL_IGMPMCAST = 0x98000003;
enum SIO_KEEPALIVE_VALS = 0x98000004;
enum SIO_ABSORB_RTRALERT = 0x98000005;
enum SIO_UCAST_IF = 0x98000006;
enum SIO_LIMIT_BROADCASTS = 0x98000007;
enum SIO_INDEX_BIND = 0x98000008;
enum SIO_INDEX_MCASTIF = 0x98000009;
enum SIO_INDEX_ADD_MCAST = 0x9800000a;
enum SIO_INDEX_DEL_MCAST = 0x9800000b;
enum SIO_RCVALL_MCAST_IF = 0x9800000d;
enum SIO_RCVALL_IF = 0x9800000e;
enum SIO_LOOPBACK_FAST_PATH = 0x98000010;
enum SIO_TCP_INITIAL_RTO = 0x98000011;
enum SIO_APPLY_TRANSPORT_SETTING = 0x98000013;
enum SIO_QUERY_TRANSPORT_SETTING = 0x98000014;
enum SIO_TCP_SET_ICW = 0x98000016;
enum SIO_TCP_SET_ACK_FREQUENCY = 0x98000017;
enum SIO_SET_PRIORITY_HINT = 0x98000018;
enum SIO_PRIORITY_HINT = 0x98000018;
enum SIO_TCP_INFO = 0xd8000027;
enum SIO_CPU_AFFINITY = 0x98000015;
enum SIO_TIMESTAMPING = 0x980000eb;
enum TIMESTAMPING_FLAG_RX = 0x00000001;
enum TIMESTAMPING_FLAG_TX = 0x00000002;
enum SO_TIMESTAMP = 0x0000300a;
enum SO_TIMESTAMP_ID = 0x0000300b;
enum SIO_GET_TX_TIMESTAMP = 0x980000ea;
enum TCP_INITIAL_RTO_DEFAULT_RTT = 0x00000000;
enum TCP_INITIAL_RTO_DEFAULT_MAX_SYN_RETRANSMISSIONS = 0x00000000;
enum SIO_ACQUIRE_PORT_RESERVATION = 0x98000064;
enum SIO_RELEASE_PORT_RESERVATION = 0x98000065;
enum SIO_ASSOCIATE_PORT_RESERVATION = 0x98000066;
enum SIO_SET_SECURITY = 0x980000c8;
enum SIO_QUERY_SECURITY = 0xd80000c9;
enum SIO_SET_PEER_TARGET_NAME = 0x980000ca;
enum SIO_DELETE_PEER_TARGET_NAME = 0x980000cb;
enum SIO_QUERY_WFP_CONNECTION_REDIRECT_RECORDS = 0x980000dc;
enum SIO_QUERY_WFP_CONNECTION_REDIRECT_CONTEXT = 0x980000dd;
enum SIO_SET_WFP_CONNECTION_REDIRECT_RECORDS = 0x980000de;
enum SIO_SOCKET_USAGE_NOTIFICATION = 0x980000cc;
enum SOCKET_SETTINGS_GUARANTEE_ENCRYPTION = 0x00000001;
enum SOCKET_SETTINGS_ALLOW_INSECURE = 0x00000002;
enum SOCKET_SETTINGS_IPSEC_SKIP_FILTER_INSTANTIATION = 0x00000001;
enum SOCKET_SETTINGS_IPSEC_OPTIONAL_PEER_NAME_VERIFICATION = 0x00000002;
enum SOCKET_SETTINGS_IPSEC_ALLOW_FIRST_INBOUND_PKT_UNENCRYPTED = 0x00000004;
enum SOCKET_SETTINGS_IPSEC_PEER_NAME_IS_RAW_FORMAT = 0x00000008;
enum SOCKET_QUERY_IPSEC2_ABORT_CONNECTION_ON_FIELD_CHANGE = 0x00000001;
enum SOCKET_QUERY_IPSEC2_FIELD_MASK_MM_SA_ID = 0x00000001;
enum SOCKET_QUERY_IPSEC2_FIELD_MASK_QM_SA_ID = 0x00000002;
enum SOCKET_INFO_CONNECTION_SECURED = 0x00000001;
enum SOCKET_INFO_CONNECTION_ENCRYPTED = 0x00000002;
enum SOCKET_INFO_CONNECTION_IMPERSONATED = 0x00000004;
enum SIO_QUERY_WFP_ALE_ENDPOINT_HANDLE = 0x580000cd;
enum SIO_QUERY_RSS_SCALABILITY_INFO = 0x580000d2;
enum IN4ADDR_LOOPBACK = 0x0100007f;
enum IN4ADDR_LOOPBACKPREFIX_LENGTH = 0x00000008;
enum IN4ADDR_LINKLOCALPREFIX_LENGTH = 0x00000010;
enum IN4ADDR_MULTICASTPREFIX_LENGTH = 0x00000004;
enum SIO_SET_COMPATIBILITY_MODE = 0x9800012c;
enum RIO_MSG_DONT_NOTIFY = 0x00000001;
enum RIO_MSG_DEFER = 0x00000002;
enum RIO_MSG_WAITALL = 0x00000004;
enum RIO_MSG_COMMIT_ONLY = 0x00000008;
enum RIO_MAX_CQ_SIZE = 0x08000000;
enum RIO_CORRUPT_CQ = 0xffffffff;
enum AF_UNIX = 0x0001;
enum AF_IMPLINK = 0x0003;
enum AF_PUP = 0x0004;
enum AF_CHAOS = 0x0005;
enum AF_NS = 0x0006;
enum AF_IPX = 0x0006;
enum AF_ISO = 0x0007;
enum AF_OSI = 0x0007;
enum AF_ECMA = 0x0008;
enum AF_DATAKIT = 0x0009;
enum AF_CCITT = 0x000a;
enum AF_SNA = 0x000b;
enum AF_DECnet = 0x000c;
enum AF_DLI = 0x000d;
enum AF_LAT = 0x000e;
enum AF_HYLINK = 0x000f;
enum AF_APPLETALK = 0x0010;
enum AF_NETBIOS = 0x0011;
enum AF_VOICEVIEW = 0x0012;
enum AF_FIREFOX = 0x0013;
enum AF_UNKNOWN1 = 0x0014;
enum AF_BAN = 0x0015;
enum AF_ATM = 0x0016;
enum AF_CLUSTER = 0x0018;
enum AF_12844 = 0x0019;
enum AF_IRDA = 0x001a;
enum AF_NETDES = 0x001c;
enum AF_MAX = 0x001d;
enum AF_TCNPROCESS = 0x001d;
enum AF_TCNMESSAGE = 0x001e;
enum AF_ICLFXBM = 0x001f;
enum AF_LINK = 0x0021;
enum AF_HYPERV = 0x0022;
enum SOL_SOCKET = 0x0000ffff;
enum SOL_IP = 0x0000fffb;
enum SOL_IPV6 = 0x0000fffa;
enum SO_DEBUG = 0x00000001;
enum SO_ACCEPTCONN = 0x00000002;
enum SO_REUSEADDR = 0x00000004;
enum SO_KEEPALIVE = 0x00000008;
enum SO_DONTROUTE = 0x00000010;
enum SO_BROADCAST = 0x00000020;
enum SO_USELOOPBACK = 0x00000040;
enum SO_LINGER = 0x00000080;
enum SO_OOBINLINE = 0x00000100;
enum SO_SNDBUF = 0x00001001;
enum SO_RCVBUF = 0x00001002;
enum SO_SNDLOWAT = 0x00001003;
enum SO_RCVLOWAT = 0x00001004;
enum SO_SNDTIMEO = 0x00001005;
enum SO_RCVTIMEO = 0x00001006;
enum SO_ERROR = 0x00001007;
enum SO_TYPE = 0x00001008;
enum SO_BSP_STATE = 0x00001009;
enum SO_GROUP_ID = 0x00002001;
enum SO_GROUP_PRIORITY = 0x00002002;
enum SO_MAX_MSG_SIZE = 0x00002003;
enum SO_CONDITIONAL_ACCEPT = 0x00003002;
enum SO_PAUSE_ACCEPT = 0x00003003;
enum SO_COMPARTMENT_ID = 0x00003004;
enum SO_RANDOMIZE_PORT = 0x00003005;
enum SO_PORT_SCALABILITY = 0x00003006;
enum SO_REUSE_UNICASTPORT = 0x00003007;
enum SO_REUSE_MULTICASTPORT = 0x00003008;
enum SO_ORIGINAL_DST = 0x0000300f;
enum IP6T_SO_ORIGINAL_DST = 0x0000300f;
enum WSK_SO_BASE = 0x00004000;
enum TCP_NODELAY = 0x00000001;
enum _SS_MAXSIZE = 0x00000080;
enum IOC_UNIX = 0x00000000;
enum IOC_WS2 = 0x08000000;
enum IOC_PROTOCOL = 0x10000000;
enum IOC_VENDOR = 0x18000000;
enum SIO_ASSOCIATE_HANDLE = 0x88000001;
enum SIO_ENABLE_CIRCULAR_QUEUEING = 0x28000002;
enum SIO_FIND_ROUTE = 0x48000003;
enum SIO_FLUSH = 0x28000004;
enum SIO_GET_BROADCAST_ADDRESS = 0x48000005;
enum SIO_GET_EXTENSION_FUNCTION_POINTER = 0xc8000006;
enum SIO_GET_QOS = 0xc8000007;
enum SIO_GET_GROUP_QOS = 0xc8000008;
enum SIO_MULTIPOINT_LOOPBACK = 0x88000009;
enum SIO_MULTICAST_SCOPE = 0x8800000a;
enum SIO_SET_QOS = 0x8800000b;
enum SIO_SET_GROUP_QOS = 0x8800000c;
enum SIO_TRANSLATE_HANDLE = 0xc800000d;
enum SIO_ROUTING_INTERFACE_QUERY = 0xc8000014;
enum SIO_ROUTING_INTERFACE_CHANGE = 0x88000015;
enum SIO_ADDRESS_LIST_QUERY = 0x48000016;
enum SIO_ADDRESS_LIST_CHANGE = 0x28000017;
enum SIO_QUERY_TARGET_PNP_HANDLE = 0x48000018;
enum SIO_QUERY_RSS_PROCESSOR_INFO = 0x48000025;
enum SIO_ADDRESS_LIST_SORT = 0xc8000019;
enum SIO_RESERVED_1 = 0x8800001a;
enum SIO_RESERVED_2 = 0x88000021;
enum SIO_GET_MULTIPLE_EXTENSION_FUNCTION_POINTER = 0xc8000024;
enum IPPORT_TCPMUX = 0x00000001;
enum IPPORT_ECHO = 0x00000007;
enum IPPORT_DISCARD = 0x00000009;
enum IPPORT_SYSTAT = 0x0000000b;
enum IPPORT_DAYTIME = 0x0000000d;
enum IPPORT_NETSTAT = 0x0000000f;
enum IPPORT_QOTD = 0x00000011;
enum IPPORT_MSP = 0x00000012;
enum IPPORT_CHARGEN = 0x00000013;
enum IPPORT_FTP_DATA = 0x00000014;
enum IPPORT_FTP = 0x00000015;
enum IPPORT_TELNET = 0x00000017;
enum IPPORT_SMTP = 0x00000019;
enum IPPORT_TIMESERVER = 0x00000025;
enum IPPORT_NAMESERVER = 0x0000002a;
enum IPPORT_WHOIS = 0x0000002b;
enum IPPORT_MTP = 0x00000039;
enum IPPORT_TFTP = 0x00000045;
enum IPPORT_RJE = 0x0000004d;
enum IPPORT_FINGER = 0x0000004f;
enum IPPORT_TTYLINK = 0x00000057;
enum IPPORT_SUPDUP = 0x0000005f;
enum IPPORT_POP3 = 0x0000006e;
enum IPPORT_NTP = 0x0000007b;
enum IPPORT_EPMAP = 0x00000087;
enum IPPORT_NETBIOS_NS = 0x00000089;
enum IPPORT_NETBIOS_DGM = 0x0000008a;
enum IPPORT_NETBIOS_SSN = 0x0000008b;
enum IPPORT_IMAP = 0x0000008f;
enum IPPORT_SNMP = 0x000000a1;
enum IPPORT_SNMP_TRAP = 0x000000a2;
enum IPPORT_IMAP3 = 0x000000dc;
enum IPPORT_LDAP = 0x00000185;
enum IPPORT_HTTPS = 0x000001bb;
enum IPPORT_MICROSOFT_DS = 0x000001bd;
enum IPPORT_EXECSERVER = 0x00000200;
enum IPPORT_LOGINSERVER = 0x00000201;
enum IPPORT_CMDSERVER = 0x00000202;
enum IPPORT_EFSSERVER = 0x00000208;
enum IPPORT_BIFFUDP = 0x00000200;
enum IPPORT_WHOSERVER = 0x00000201;
enum IPPORT_ROUTESERVER = 0x00000208;
enum IPPORT_RESERVED = 0x00000400;
enum IPPORT_REGISTERED_MIN = 0x00000400;
enum IPPORT_REGISTERED_MAX = 0x0000bfff;
enum IPPORT_DYNAMIC_MIN = 0x0000c000;
enum IPPORT_DYNAMIC_MAX = 0x0000ffff;
enum IN_CLASSA_NET = 0xff000000;
enum IN_CLASSA_NSHIFT = 0x00000018;
enum IN_CLASSA_HOST = 0x00ffffff;
enum IN_CLASSA_MAX = 0x00000080;
enum IN_CLASSB_NET = 0xffff0000;
enum IN_CLASSB_NSHIFT = 0x00000010;
enum IN_CLASSB_HOST = 0x0000ffff;
enum IN_CLASSB_MAX = 0x00010000;
enum IN_CLASSC_NET = 0xffffff00;
enum IN_CLASSC_NSHIFT = 0x00000008;
enum IN_CLASSC_HOST = 0x000000ff;
enum IN_CLASSD_NET = 0xf0000000;
enum IN_CLASSD_NSHIFT = 0x0000001c;
enum IN_CLASSD_HOST = 0x0fffffff;
enum INADDR_LOOPBACK = 0x7f000001;
enum INADDR_NONE = 0xffffffff;
enum IOCPARM_MASK = 0x0000007f;
enum IOC_VOID = 0x20000000;
enum IOC_OUT = 0x40000000;
enum IOC_IN = 0x80000000;
enum MSG_TRUNC = 0x00000100;
enum MSG_CTRUNC = 0x00000200;
enum MSG_BCAST = 0x00000400;
enum MSG_MCAST = 0x00000800;
enum MSG_ERRQUEUE = 0x00001000;
enum AI_PASSIVE = 0x00000001;
enum AI_CANONNAME = 0x00000002;
enum AI_NUMERICHOST = 0x00000004;
enum AI_NUMERICSERV = 0x00000008;
enum AI_DNS_ONLY = 0x00000010;
enum AI_FORCE_CLEAR_TEXT = 0x00000020;
enum AI_BYPASS_DNS_CACHE = 0x00000040;
enum AI_RETURN_TTL = 0x00000080;
enum AI_ALL = 0x00000100;
enum AI_ADDRCONFIG = 0x00000400;
enum AI_V4MAPPED = 0x00000800;
enum AI_NON_AUTHORITATIVE = 0x00004000;
enum AI_SECURE = 0x00008000;
enum AI_RETURN_PREFERRED_NAMES = 0x00010000;
enum AI_FQDN = 0x00020000;
enum AI_FILESERVER = 0x00040000;
enum AI_DISABLE_IDN_ENCODING = 0x00080000;
enum AI_SECURE_WITH_FALLBACK = 0x00100000;
enum AI_EXCLUSIVE_CUSTOM_SERVERS = 0x00200000;
enum AI_RETURN_RESPONSE_FLAGS = 0x10000000;
enum AI_REQUIRE_SECURE = 0x20000000;
enum AI_RESOLUTION_HANDLE = 0x40000000;
enum AI_EXTENDED = 0x80000000;
enum ADDRINFOEX_VERSION_2 = 0x00000002;
enum ADDRINFOEX_VERSION_3 = 0x00000003;
enum ADDRINFOEX_VERSION_4 = 0x00000004;
enum ADDRINFOEX_VERSION_5 = 0x00000005;
enum ADDRINFOEX_VERSION_6 = 0x00000006;
enum AI_DNS_SERVER_TYPE_UDP = 0x00000001;
enum AI_DNS_SERVER_TYPE_DOH = 0x00000002;
enum AI_DNS_SERVER_UDP_FALLBACK = 0x00000001;
enum AI_DNS_RESPONSE_SECURE = 0x00000001;
enum AI_DNS_RESPONSE_HOSTFILE = 0x00000002;
enum NS_ALL = 0x00000000;
enum NS_SAP = 0x00000001;
enum NS_NDS = 0x00000002;
enum NS_PEER_BROWSE = 0x00000003;
enum NS_SLP = 0x00000005;
enum NS_DHCP = 0x00000006;
enum NS_TCPIP_LOCAL = 0x0000000a;
enum NS_TCPIP_HOSTS = 0x0000000b;
enum NS_DNS = 0x0000000c;
enum NS_NETBT = 0x0000000d;
enum NS_WINS = 0x0000000e;
enum NS_NLA = 0x0000000f;
enum NS_NBP = 0x00000014;
enum NS_MS = 0x0000001e;
enum NS_STDA = 0x0000001f;
enum NS_NTDS = 0x00000020;
enum NS_EMAIL = 0x00000025;
enum NS_X500 = 0x00000028;
enum NS_NIS = 0x00000029;
enum NS_NISPLUS = 0x0000002a;
enum NS_WRQ = 0x00000032;
enum NS_NETDES = 0x0000003c;
enum NI_NOFQDN = 0x00000001;
enum NI_NUMERICHOST = 0x00000002;
enum NI_NAMEREQD = 0x00000004;
enum NI_NUMERICSERV = 0x00000008;
enum NI_DGRAM = 0x00000010;
enum NI_MAXHOST = 0x00000401;
enum NI_MAXSERV = 0x00000020;
enum IFF_UP = 0x00000001;
enum IFF_BROADCAST = 0x00000002;
enum IFF_LOOPBACK = 0x00000004;
enum IFF_POINTTOPOINT = 0x00000008;
enum IFF_MULTICAST = 0x00000010;
enum IP_OPTIONS = 0x00000001;
enum IP_HDRINCL = 0x00000002;
enum IP_TOS = 0x00000003;
enum IP_TTL = 0x00000004;
enum IP_MULTICAST_IF = 0x00000009;
enum IP_MULTICAST_TTL = 0x0000000a;
enum IP_MULTICAST_LOOP = 0x0000000b;
enum IP_ADD_MEMBERSHIP = 0x0000000c;
enum IP_DROP_MEMBERSHIP = 0x0000000d;
enum IP_DONTFRAGMENT = 0x0000000e;
enum IP_ADD_SOURCE_MEMBERSHIP = 0x0000000f;
enum IP_DROP_SOURCE_MEMBERSHIP = 0x00000010;
enum IP_BLOCK_SOURCE = 0x00000011;
enum IP_UNBLOCK_SOURCE = 0x00000012;
enum IP_PKTINFO = 0x00000013;
enum IP_HOPLIMIT = 0x00000015;
enum IP_RECVTTL = 0x00000015;
enum IP_RECEIVE_BROADCAST = 0x00000016;
enum IP_RECVIF = 0x00000018;
enum IP_RECVDSTADDR = 0x00000019;
enum IP_IFLIST = 0x0000001c;
enum IP_ADD_IFLIST = 0x0000001d;
enum IP_DEL_IFLIST = 0x0000001e;
enum IP_UNICAST_IF = 0x0000001f;
enum IP_RTHDR = 0x00000020;
enum IP_GET_IFLIST = 0x00000021;
enum IP_RECVRTHDR = 0x00000026;
enum IP_TCLASS = 0x00000027;
enum IP_RECVTCLASS = 0x00000028;
enum IP_RECVTOS = 0x00000028;
enum IP_ORIGINAL_ARRIVAL_IF = 0x0000002f;
enum IP_ECN = 0x00000032;
enum IP_RECVECN = 0x00000032;
enum IP_PKTINFO_EX = 0x00000033;
enum IP_WFP_REDIRECT_RECORDS = 0x0000003c;
enum IP_WFP_REDIRECT_CONTEXT = 0x00000046;
enum IP_MTU_DISCOVER = 0x00000047;
enum IP_MTU = 0x00000049;
enum IP_NRT_INTERFACE = 0x0000004a;
enum IP_RECVERR = 0x0000004b;
enum IP_USER_MTU = 0x0000004c;
enum IP_UNSPECIFIED_TYPE_OF_SERVICE = 0xffffffffffffffff;
enum IP_UNSPECIFIED_USER_MTU = 0xffffffff;
enum IN6ADDR_LINKLOCALPREFIX_LENGTH = 0x00000040;
enum IN6ADDR_MULTICASTPREFIX_LENGTH = 0x00000008;
enum IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_LENGTH = 0x00000068;
enum IN6ADDR_V4MAPPEDPREFIX_LENGTH = 0x00000060;
enum IN6ADDR_6TO4PREFIX_LENGTH = 0x00000010;
enum IN6ADDR_TEREDOPREFIX_LENGTH = 0x00000020;
enum MCAST_JOIN_GROUP = 0x00000029;
enum MCAST_LEAVE_GROUP = 0x0000002a;
enum MCAST_BLOCK_SOURCE = 0x0000002b;
enum MCAST_UNBLOCK_SOURCE = 0x0000002c;
enum MCAST_JOIN_SOURCE_GROUP = 0x0000002d;
enum MCAST_LEAVE_SOURCE_GROUP = 0x0000002e;
enum IPV6_HOPOPTS = 0x00000001;
enum IPV6_HDRINCL = 0x00000002;
enum IPV6_UNICAST_HOPS = 0x00000004;
enum IPV6_MULTICAST_IF = 0x00000009;
enum IPV6_MULTICAST_HOPS = 0x0000000a;
enum IPV6_MULTICAST_LOOP = 0x0000000b;
enum IPV6_ADD_MEMBERSHIP = 0x0000000c;
enum IPV6_JOIN_GROUP = 0x0000000c;
enum IPV6_DROP_MEMBERSHIP = 0x0000000d;
enum IPV6_LEAVE_GROUP = 0x0000000d;
enum IPV6_DONTFRAG = 0x0000000e;
enum IPV6_PKTINFO = 0x00000013;
enum IPV6_HOPLIMIT = 0x00000015;
enum IPV6_PROTECTION_LEVEL = 0x00000017;
enum IPV6_RECVIF = 0x00000018;
enum IPV6_RECVDSTADDR = 0x00000019;
enum IPV6_CHECKSUM = 0x0000001a;
enum IPV6_V6ONLY = 0x0000001b;
enum IPV6_IFLIST = 0x0000001c;
enum IPV6_ADD_IFLIST = 0x0000001d;
enum IPV6_DEL_IFLIST = 0x0000001e;
enum IPV6_UNICAST_IF = 0x0000001f;
enum IPV6_RTHDR = 0x00000020;
enum IPV6_GET_IFLIST = 0x00000021;
enum IPV6_RECVRTHDR = 0x00000026;
enum IPV6_TCLASS = 0x00000027;
enum IPV6_RECVTCLASS = 0x00000028;
enum IPV6_ECN = 0x00000032;
enum IPV6_RECVECN = 0x00000032;
enum IPV6_PKTINFO_EX = 0x00000033;
enum IPV6_WFP_REDIRECT_RECORDS = 0x0000003c;
enum IPV6_WFP_REDIRECT_CONTEXT = 0x00000046;
enum IPV6_MTU_DISCOVER = 0x00000047;
enum IPV6_MTU = 0x00000048;
enum IPV6_NRT_INTERFACE = 0x0000004a;
enum IPV6_RECVERR = 0x0000004b;
enum IPV6_USER_MTU = 0x0000004c;
enum IP_UNSPECIFIED_HOP_LIMIT = 0xffffffffffffffff;
enum IP_PROTECTION_LEVEL = 0x00000017;
enum PROTECTION_LEVEL_UNRESTRICTED = 0x0000000a;
enum PROTECTION_LEVEL_EDGERESTRICTED = 0x00000014;
enum PROTECTION_LEVEL_RESTRICTED = 0x0000001e;
enum PROTECTION_LEVEL_DEFAULT = 0x00000014;
enum INET_ADDRSTRLEN = 0x00000016;
enum INET6_ADDRSTRLEN = 0x00000041;
enum TCP_OFFLOAD_NO_PREFERENCE = 0x00000000;
enum TCP_OFFLOAD_NOT_PREFERRED = 0x00000001;
enum TCP_OFFLOAD_PREFERRED = 0x00000002;
enum TCP_EXPEDITED_1122 = 0x00000002;
enum TCP_KEEPALIVE = 0x00000003;
enum TCP_MAXSEG = 0x00000004;
enum TCP_MAXRT = 0x00000005;
enum TCP_STDURG = 0x00000006;
enum TCP_NOURG = 0x00000007;
enum TCP_ATMARK = 0x00000008;
enum TCP_NOSYNRETRIES = 0x00000009;
enum TCP_TIMESTAMPS = 0x0000000a;
enum TCP_OFFLOAD_PREFERENCE = 0x0000000b;
enum TCP_CONGESTION_ALGORITHM = 0x0000000c;
enum TCP_DELAY_FIN_ACK = 0x0000000d;
enum TCP_MAXRTMS = 0x0000000e;
enum TCP_FASTOPEN = 0x0000000f;
enum TCP_KEEPCNT = 0x00000010;
enum TCP_KEEPIDLE = 0x00000003;
enum TCP_KEEPINTVL = 0x00000011;
enum TCP_FAIL_CONNECT_ON_ICMP_ERROR = 0x00000012;
enum TCP_ICMP_ERROR_INFO = 0x00000013;
enum UDP_SEND_MSG_SIZE = 0x00000002;
enum UDP_RECV_MAX_COALESCED_SIZE = 0x00000003;
enum UDP_COALESCED_INFO = 0x00000003;
enum WINDOWS_AF_IRDA = 0x0000001a;
enum WINDOWS_PF_IRDA = 0x0000001a;
enum WCE_AF_IRDA = 0x00000016;
enum WCE_PF_IRDA = 0x00000016;
enum IRDA_PROTO_SOCK_STREAM = 0x00000001;
enum PF_IRDA = 0x001a;
enum SOL_IRLMP = 0x000000ff;
enum IRLMP_ENUMDEVICES = 0x00000010;
enum IRLMP_IAS_SET = 0x00000011;
enum IRLMP_IAS_QUERY = 0x00000012;
enum IRLMP_SEND_PDU_LEN = 0x00000013;
enum IRLMP_EXCLUSIVE_MODE = 0x00000014;
enum IRLMP_IRLPT_MODE = 0x00000015;
enum IRLMP_9WIRE_MODE = 0x00000016;
enum IRLMP_TINYTP_MODE = 0x00000017;
enum IRLMP_PARAMETERS = 0x00000018;
enum IRLMP_DISCOVERY_MODE = 0x00000019;
enum IRLMP_SHARP_MODE = 0x00000020;
enum IAS_ATTRIB_NO_CLASS = 0x00000010;
enum IAS_ATTRIB_NO_ATTRIB = 0x00000000;
enum IAS_ATTRIB_INT = 0x00000001;
enum IAS_ATTRIB_OCTETSEQ = 0x00000002;
enum IAS_ATTRIB_STR = 0x00000003;
enum IAS_MAX_USER_STRING = 0x00000100;
enum IAS_MAX_OCTET_STRING = 0x00000400;
enum IAS_MAX_CLASSNAME = 0x00000040;
enum IAS_MAX_ATTRIBNAME = 0x00000100;
enum LmCharSetASCII = 0x00000000;
enum LmCharSetISO_8859_1 = 0x00000001;
enum LmCharSetISO_8859_2 = 0x00000002;
enum LmCharSetISO_8859_3 = 0x00000003;
enum LmCharSetISO_8859_4 = 0x00000004;
enum LmCharSetISO_8859_5 = 0x00000005;
enum LmCharSetISO_8859_6 = 0x00000006;
enum LmCharSetISO_8859_7 = 0x00000007;
enum LmCharSetISO_8859_8 = 0x00000008;
enum LmCharSetISO_8859_9 = 0x00000009;
enum LmCharSetUNICODE = 0x000000ff;
enum LM_BAUD_1200 = 0x000004b0;
enum LM_BAUD_2400 = 0x00000960;
enum LM_BAUD_9600 = 0x00002580;
enum LM_BAUD_19200 = 0x00004b00;
enum LM_BAUD_38400 = 0x00009600;
enum LM_BAUD_57600 = 0x0000e100;
enum LM_BAUD_115200 = 0x0001c200;
enum LM_BAUD_576K = 0x0008ca00;
enum LM_BAUD_1152K = 0x00119400;
enum LM_BAUD_4M = 0x003d0900;
enum LM_BAUD_16M = 0x00f42400;
enum SO_CONNDATA = 0x00007000;
enum SO_CONNOPT = 0x00007001;
enum SO_DISCDATA = 0x00007002;
enum SO_DISCOPT = 0x00007003;
enum SO_CONNDATALEN = 0x00007004;
enum SO_CONNOPTLEN = 0x00007005;
enum SO_DISCDATALEN = 0x00007006;
enum SO_DISCOPTLEN = 0x00007007;
enum SO_OPENTYPE = 0x00007008;
enum SO_SYNCHRONOUS_ALERT = 0x00000010;
enum SO_SYNCHRONOUS_NONALERT = 0x00000020;
enum SO_MAXDG = 0x00007009;
enum SO_MAXPATHDG = 0x0000700a;
enum SO_UPDATE_ACCEPT_CONTEXT = 0x0000700b;
enum SO_CONNECT_TIME = 0x0000700c;
enum SO_UPDATE_CONNECT_CONTEXT = 0x00007010;
enum TCP_BSDURGENT = 0x00007000;
enum SIO_UDP_CONNRESET = 0x9800000c;
enum SIO_SOCKET_CLOSE_NOTIFY = 0x9800000d;
enum SIO_UDP_NETRESET = 0x9800000f;
enum TF_DISCONNECT = 0x00000001;
enum TF_REUSE_SOCKET = 0x00000002;
enum TF_WRITE_BEHIND = 0x00000004;
enum TF_USE_DEFAULT_WORKER = 0x00000000;
enum TF_USE_SYSTEM_THREAD = 0x00000010;
enum TF_USE_KERNEL_APC = 0x00000020;
enum WSAID_TRANSMITFILE = GUID(0xb5367df0, 0xcbac, 0x11cf, [0x95, 0xca, 0x0, 0x80, 0x5f, 0x48, 0xa1, 0x92]);
enum WSAID_ACCEPTEX = GUID(0xb5367df1, 0xcbac, 0x11cf, [0x95, 0xca, 0x0, 0x80, 0x5f, 0x48, 0xa1, 0x92]);
enum WSAID_GETACCEPTEXSOCKADDRS = GUID(0xb5367df2, 0xcbac, 0x11cf, [0x95, 0xca, 0x0, 0x80, 0x5f, 0x48, 0xa1, 0x92]);
enum TP_ELEMENT_MEMORY = 0x00000001;
enum TP_ELEMENT_FILE = 0x00000002;
enum TP_ELEMENT_EOP = 0x00000004;
enum TP_DISCONNECT = 0x00000001;
enum TP_REUSE_SOCKET = 0x00000002;
enum TP_USE_DEFAULT_WORKER = 0x00000000;
enum TP_USE_SYSTEM_THREAD = 0x00000010;
enum TP_USE_KERNEL_APC = 0x00000020;
enum WSAID_TRANSMITPACKETS = GUID(0xd9689da0, 0x1f90, 0x11d3, [0x99, 0x71, 0x0, 0xc0, 0x4f, 0x68, 0xc8, 0x76]);
enum WSAID_CONNECTEX = GUID(0x25a207b9, 0xddf3, 0x4660, [0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x6, 0x3e]);
enum WSAID_DISCONNECTEX = GUID(0x7fda2e11, 0x8630, 0x436f, [0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57]);
enum DE_REUSE_SOCKET = 0x00000002;
enum NLA_NAMESPACE_GUID = GUID(0x6642243a, 0x3ba8, 0x4aa6, [0xba, 0xa5, 0x2e, 0xb, 0xd7, 0x1f, 0xdd, 0x83]);
enum NLA_SERVICE_CLASS_GUID = GUID(0x37e515, 0xb5c9, 0x4a43, [0xba, 0xda, 0x8b, 0x48, 0xa8, 0x7a, 0xd2, 0x39]);
enum NLA_ALLUSERS_NETWORK = 0x00000001;
enum NLA_FRIENDLY_NAME = 0x00000002;
enum WSAID_WSARECVMSG = GUID(0xf689d7c8, 0x6f1f, 0x436b, [0x8a, 0x53, 0xe5, 0x4f, 0xe3, 0x51, 0xc3, 0x22]);
enum SIO_BSP_HANDLE = 0x4800001b;
enum SIO_BSP_HANDLE_SELECT = 0x4800001c;
enum SIO_BSP_HANDLE_POLL = 0x4800001d;
enum SIO_BASE_HANDLE = 0x48000022;
enum SIO_EXT_SELECT = 0xc800001e;
enum SIO_EXT_POLL = 0xc800001f;
enum SIO_EXT_SENDMSG = 0xc8000020;
enum WSAID_WSAPOLL = GUID(0x18c76f85, 0xdc66, 0x4964, [0x97, 0x2e, 0x23, 0xc2, 0x72, 0x38, 0x31, 0x2b]);
enum SERVICE_RESOURCE = 0x00000001;
enum SERVICE_SERVICE = 0x00000002;
enum SERVICE_LOCAL = 0x00000004;
enum SERVICE_FLAG_DEFER = 0x00000001;
enum SERVICE_FLAG_HARD = 0x00000002;
enum PROP_COMMENT = 0x00000001;
enum PROP_LOCALE = 0x00000002;
enum PROP_DISPLAY_HINT = 0x00000004;
enum PROP_VERSION = 0x00000008;
enum PROP_START_TIME = 0x00000010;
enum PROP_MACHINE = 0x00000020;
enum PROP_ADDRESSES = 0x00000100;
enum PROP_SD = 0x00000200;
enum PROP_ALL = 0x80000000;
enum SERVICE_ADDRESS_FLAG_RPC_CN = 0x00000001;
enum SERVICE_ADDRESS_FLAG_RPC_DG = 0x00000002;
enum SERVICE_ADDRESS_FLAG_RPC_NB = 0x00000004;
enum NS_DEFAULT = 0x00000000;
enum NS_VNS = 0x00000032;
enum NSTYPE_HIERARCHICAL = 0x00000001;
enum NSTYPE_DYNAMIC = 0x00000002;
enum NSTYPE_ENUMERABLE = 0x00000004;
enum NSTYPE_WORKGROUP = 0x00000008;
enum XP_CONNECTIONLESS = 0x00000001;
enum XP_GUARANTEED_DELIVERY = 0x00000002;
enum XP_GUARANTEED_ORDER = 0x00000004;
enum XP_MESSAGE_ORIENTED = 0x00000008;
enum XP_PSEUDO_STREAM = 0x00000010;
enum XP_GRACEFUL_CLOSE = 0x00000020;
enum XP_EXPEDITED_DATA = 0x00000040;
enum XP_CONNECT_DATA = 0x00000080;
enum XP_DISCONNECT_DATA = 0x00000100;
enum XP_SUPPORTS_BROADCAST = 0x00000200;
enum XP_SUPPORTS_MULTICAST = 0x00000400;
enum XP_BANDWIDTH_ALLOCATION = 0x00000800;
enum XP_FRAGMENTATION = 0x00001000;
enum XP_ENCRYPTS = 0x00002000;
enum RES_SOFT_SEARCH = 0x00000001;
enum RES_FIND_MULTIPLE = 0x00000002;
enum RES_SERVICE = 0x00000004;
enum SERVICE_TYPE_VALUE_SAPIDA = "SapId";
enum SERVICE_TYPE_VALUE_SAPIDW = "SapId";
enum SERVICE_TYPE_VALUE_CONNA = "ConnectionOriented";
enum SERVICE_TYPE_VALUE_CONNW = "ConnectionOriented";
enum SERVICE_TYPE_VALUE_TCPPORTA = "TcpPort";
enum SERVICE_TYPE_VALUE_TCPPORTW = "TcpPort";
enum SERVICE_TYPE_VALUE_UDPPORTA = "UdpPort";
enum SERVICE_TYPE_VALUE_UDPPORTW = "UdpPort";
enum SERVICE_TYPE_VALUE_SAPID = "SapId";
enum SERVICE_TYPE_VALUE_CONN = "ConnectionOriented";
enum SERVICE_TYPE_VALUE_TCPPORT = "TcpPort";
enum SERVICE_TYPE_VALUE_UDPPORT = "UdpPort";
enum SET_SERVICE_PARTIAL_SUCCESS = 0x00000001;
enum FD_SETSIZE = 0x00000040;
enum IMPLINK_IP = 0x0000009b;
enum IMPLINK_LOWEXPER = 0x0000009c;
enum IMPLINK_HIGHEXPER = 0x0000009e;
enum WSADESCRIPTION_LEN = 0x00000100;
enum WSASYS_STATUS_LEN = 0x00000080;
enum IP_DEFAULT_MULTICAST_TTL = 0x00000001;
enum IP_DEFAULT_MULTICAST_LOOP = 0x00000001;
enum IP_MAX_MEMBERSHIPS = 0x00000014;
enum SOCKET_ERROR = 0xffffffffffffffff;
enum PF_UNIX = 0x0001;
enum PF_IMPLINK = 0x0003;
enum PF_PUP = 0x0004;
enum PF_CHAOS = 0x0005;
enum PF_NS = 0x0006;
enum PF_IPX = 0x0006;
enum PF_ISO = 0x0007;
enum PF_OSI = 0x0007;
enum PF_ECMA = 0x0008;
enum PF_DATAKIT = 0x0009;
enum PF_CCITT = 0x000a;
enum PF_SNA = 0x000b;
enum PF_DECnet = 0x000c;
enum PF_DLI = 0x000d;
enum PF_LAT = 0x000e;
enum PF_HYLINK = 0x000f;
enum PF_APPLETALK = 0x0010;
enum PF_VOICEVIEW = 0x0012;
enum PF_FIREFOX = 0x0013;
enum PF_UNKNOWN1 = 0x0014;
enum PF_BAN = 0x0015;
enum PF_MAX = 0x001d;
enum SOMAXCONN = 0x00000005;
enum MSG_MAXIOVLEN = 0x00000010;
enum MSG_PARTIAL = 0x00008000;
enum MAXGETHOSTSTRUCT = 0x00000400;
enum FD_READ = 0x00000001;
enum FD_WRITE = 0x00000002;
enum FD_OOB = 0x00000004;
enum FD_ACCEPT = 0x00000008;
enum FD_CONNECT = 0x00000010;
enum FD_CLOSE = 0x00000020;
enum INCL_WINSOCK_API_PROTOTYPES = 0x00000001;
enum INCL_WINSOCK_API_TYPEDEFS = 0x00000000;
enum FROM_PROTOCOL_INFO = 0xffffffffffffffff;
enum SO_PROTOCOL_INFOA = 0x00002004;
enum SO_PROTOCOL_INFOW = 0x00002005;
enum SO_PROTOCOL_INFO = 0x00002005;
enum PVD_CONFIG = 0x00003001;
enum PF_ATM = 0x0016;
enum MSG_INTERRUPT = 0x00000010;
enum FD_READ_BIT = 0x00000000;
enum FD_WRITE_BIT = 0x00000001;
enum FD_OOB_BIT = 0x00000002;
enum FD_ACCEPT_BIT = 0x00000003;
enum FD_CONNECT_BIT = 0x00000004;
enum FD_CLOSE_BIT = 0x00000005;
enum FD_QOS_BIT = 0x00000006;
enum FD_GROUP_QOS_BIT = 0x00000007;
enum FD_ROUTING_INTERFACE_CHANGE_BIT = 0x00000008;
enum FD_ADDRESS_LIST_CHANGE_BIT = 0x00000009;
enum FD_MAX_EVENTS = 0x0000000a;
enum WSA_MAXIMUM_WAIT_EVENTS = 0x00000040;
enum WSA_WAIT_FAILED = 0xffffffff;
enum WSA_WAIT_TIMEOUT = 0x00000102;
enum CF_ACCEPT = 0x00000000;
enum CF_REJECT = 0x00000001;
enum CF_DEFER = 0x00000002;
enum SG_UNCONSTRAINED_GROUP = 0x00000001;
enum SG_CONSTRAINED_GROUP = 0x00000002;
enum MAX_PROTOCOL_CHAIN = 0x00000007;
enum BASE_PROTOCOL = 0x00000001;
enum LAYERED_PROTOCOL = 0x00000000;
enum WSAPROTOCOL_LEN = 0x000000ff;
enum PFL_MULTIPLE_PROTO_ENTRIES = 0x00000001;
enum PFL_RECOMMENDED_PROTO_ENTRY = 0x00000002;
enum PFL_HIDDEN = 0x00000004;
enum PFL_MATCHES_PROTOCOL_ZERO = 0x00000008;
enum PFL_NETWORKDIRECT_PROVIDER = 0x00000010;
enum XP1_CONNECTIONLESS = 0x00000001;
enum XP1_GUARANTEED_DELIVERY = 0x00000002;
enum XP1_GUARANTEED_ORDER = 0x00000004;
enum XP1_MESSAGE_ORIENTED = 0x00000008;
enum XP1_PSEUDO_STREAM = 0x00000010;
enum XP1_GRACEFUL_CLOSE = 0x00000020;
enum XP1_EXPEDITED_DATA = 0x00000040;
enum XP1_CONNECT_DATA = 0x00000080;
enum XP1_DISCONNECT_DATA = 0x00000100;
enum XP1_SUPPORT_BROADCAST = 0x00000200;
enum XP1_SUPPORT_MULTIPOINT = 0x00000400;
enum XP1_MULTIPOINT_CONTROL_PLANE = 0x00000800;
enum XP1_MULTIPOINT_DATA_PLANE = 0x00001000;
enum XP1_QOS_SUPPORTED = 0x00002000;
enum XP1_INTERRUPT = 0x00004000;
enum XP1_UNI_SEND = 0x00008000;
enum XP1_UNI_RECV = 0x00010000;
enum XP1_IFS_HANDLES = 0x00020000;
enum XP1_PARTIAL_MESSAGE = 0x00040000;
enum XP1_SAN_SUPPORT_SDP = 0x00080000;
enum BIGENDIAN = 0x00000000;
enum LITTLEENDIAN = 0x00000001;
enum SECURITY_PROTOCOL_NONE = 0x00000000;
enum JL_SENDER_ONLY = 0x00000001;
enum JL_RECEIVER_ONLY = 0x00000002;
enum JL_BOTH = 0x00000004;
enum WSA_FLAG_OVERLAPPED = 0x00000001;
enum WSA_FLAG_MULTIPOINT_C_ROOT = 0x00000002;
enum WSA_FLAG_MULTIPOINT_C_LEAF = 0x00000004;
enum WSA_FLAG_MULTIPOINT_D_ROOT = 0x00000008;
enum WSA_FLAG_MULTIPOINT_D_LEAF = 0x00000010;
enum WSA_FLAG_ACCESS_SYSTEM_SECURITY = 0x00000040;
enum WSA_FLAG_NO_HANDLE_INHERIT = 0x00000080;
enum WSA_FLAG_REGISTERED_IO = 0x00000100;
enum SIO_NSP_NOTIFY_CHANGE = 0x88000019;
enum TH_NETDEV = 0x00000001;
enum TH_TAPI = 0x00000002;
enum SERVICE_MULTIPLE = 0x00000001;
enum NS_LOCALNAME = 0x00000013;
enum RES_UNUSED_1 = 0x00000001;
enum RES_FLUSH_CACHE = 0x00000002;
enum SERVICE_TYPE_VALUE_IPXPORTA = "IpxSocket";
enum SERVICE_TYPE_VALUE_IPXPORTW = "IpxSocket";
enum SERVICE_TYPE_VALUE_OBJECTIDA = "ObjectId";
enum SERVICE_TYPE_VALUE_OBJECTIDW = "ObjectId";
enum SERVICE_TYPE_VALUE_OBJECTID = "ObjectId";
enum LUP_DEEP = 0x00000001;
enum LUP_CONTAINERS = 0x00000002;
enum LUP_NOCONTAINERS = 0x00000004;
enum LUP_NEAREST = 0x00000008;
enum LUP_RETURN_NAME = 0x00000010;
enum LUP_RETURN_TYPE = 0x00000020;
enum LUP_RETURN_VERSION = 0x00000040;
enum LUP_RETURN_COMMENT = 0x00000080;
enum LUP_RETURN_ADDR = 0x00000100;
enum LUP_RETURN_BLOB = 0x00000200;
enum LUP_RETURN_ALIASES = 0x00000400;
enum LUP_RETURN_QUERY_STRING = 0x00000800;
enum LUP_RETURN_ALL = 0x00000ff0;
enum LUP_RES_SERVICE = 0x00008000;
enum LUP_FLUSHCACHE = 0x00001000;
enum LUP_FLUSHPREVIOUS = 0x00002000;
enum LUP_NON_AUTHORITATIVE = 0x00004000;
enum LUP_SECURE = 0x00008000;
enum LUP_RETURN_PREFERRED_NAMES = 0x00010000;
enum LUP_DNS_ONLY = 0x00020000;
enum LUP_RETURN_RESPONSE_FLAGS = 0x00040000;
enum LUP_ADDRCONFIG = 0x00100000;
enum LUP_DUAL_ADDR = 0x00200000;
enum LUP_FILESERVER = 0x00400000;
enum LUP_DISABLE_IDN_ENCODING = 0x00800000;
enum LUP_API_ANSI = 0x01000000;
enum LUP_EXTENDED_QUERYSET = 0x02000000;
enum LUP_SECURE_WITH_FALLBACK = 0x04000000;
enum LUP_EXCLUSIVE_CUSTOM_SERVERS = 0x08000000;
enum LUP_REQUIRE_SECURE = 0x10000000;
enum LUP_RETURN_TTL = 0x20000000;
enum LUP_FORCE_CLEAR_TEXT = 0x40000000;
enum LUP_RESOLUTION_HANDLE = 0x80000000;
enum RESULT_IS_ALIAS = 0x00000001;
enum RESULT_IS_ADDED = 0x00000010;
enum RESULT_IS_CHANGED = 0x00000020;
enum RESULT_IS_DELETED = 0x00000040;
enum SOCK_NOTIFY_REGISTER_EVENT_NONE = 0x00000000;
enum SOCK_NOTIFY_REGISTER_EVENT_IN = 0x00000001;
enum SOCK_NOTIFY_REGISTER_EVENT_OUT = 0x00000002;
enum SOCK_NOTIFY_REGISTER_EVENT_HANGUP = 0x00000004;
enum SOCK_NOTIFY_EVENT_IN = 0x00000001;
enum SOCK_NOTIFY_EVENT_OUT = 0x00000002;
enum SOCK_NOTIFY_EVENT_HANGUP = 0x00000004;
enum SOCK_NOTIFY_EVENT_ERR = 0x00000040;
enum SOCK_NOTIFY_EVENT_REMOVE = 0x00000080;
enum SOCK_NOTIFY_OP_NONE = 0x00000000;
enum SOCK_NOTIFY_OP_ENABLE = 0x00000001;
enum SOCK_NOTIFY_OP_DISABLE = 0x00000002;
enum SOCK_NOTIFY_OP_REMOVE = 0x00000004;
enum SOCK_NOTIFY_TRIGGER_ONESHOT = 0x00000001;
enum SOCK_NOTIFY_TRIGGER_PERSISTENT = 0x00000002;
enum SOCK_NOTIFY_TRIGGER_LEVEL = 0x00000004;
enum SOCK_NOTIFY_TRIGGER_EDGE = 0x00000008;
enum ATMPROTO_AALUSER = 0x00000000;
enum ATMPROTO_AAL1 = 0x00000001;
enum ATMPROTO_AAL2 = 0x00000002;
enum ATMPROTO_AAL34 = 0x00000003;
enum ATMPROTO_AAL5 = 0x00000005;
enum SAP_FIELD_ABSENT = 0xfffffffe;
enum SAP_FIELD_ANY = 0xffffffff;
enum SAP_FIELD_ANY_AESA_SEL = 0xfffffffa;
enum SAP_FIELD_ANY_AESA_REST = 0xfffffffb;
enum ATM_E164 = 0x00000001;
enum ATM_NSAP = 0x00000002;
enum ATM_AESA = 0x00000002;
enum ATM_ADDR_SIZE = 0x00000014;
enum BLLI_L2_ISO_1745 = 0x00000001;
enum BLLI_L2_Q921 = 0x00000002;
enum BLLI_L2_X25L = 0x00000006;
enum BLLI_L2_X25M = 0x00000007;
enum BLLI_L2_ELAPB = 0x00000008;
enum BLLI_L2_HDLC_ARM = 0x00000009;
enum BLLI_L2_HDLC_NRM = 0x0000000a;
enum BLLI_L2_HDLC_ABM = 0x0000000b;
enum BLLI_L2_LLC = 0x0000000c;
enum BLLI_L2_X75 = 0x0000000d;
enum BLLI_L2_Q922 = 0x0000000e;
enum BLLI_L2_USER_SPECIFIED = 0x00000010;
enum BLLI_L2_ISO_7776 = 0x00000011;
enum BLLI_L3_X25 = 0x00000006;
enum BLLI_L3_ISO_8208 = 0x00000007;
enum BLLI_L3_X223 = 0x00000008;
enum BLLI_L3_SIO_8473 = 0x00000009;
enum BLLI_L3_T70 = 0x0000000a;
enum BLLI_L3_ISO_TR9577 = 0x0000000b;
enum BLLI_L3_USER_SPECIFIED = 0x00000010;
enum BLLI_L3_IPI_SNAP = 0x00000080;
enum BLLI_L3_IPI_IP = 0x000000cc;
enum BHLI_ISO = 0x00000000;
enum BHLI_UserSpecific = 0x00000001;
enum BHLI_HighLayerProfile = 0x00000002;
enum BHLI_VendorSpecificAppId = 0x00000003;
enum AAL5_MODE_MESSAGE = 0x00000001;
enum AAL5_MODE_STREAMING = 0x00000002;
enum AAL5_SSCS_NULL = 0x00000000;
enum AAL5_SSCS_SSCOP_ASSURED = 0x00000001;
enum AAL5_SSCS_SSCOP_NON_ASSURED = 0x00000002;
enum AAL5_SSCS_FRAME_RELAY = 0x00000004;
enum BCOB_A = 0x00000001;
enum BCOB_C = 0x00000003;
enum BCOB_X = 0x00000010;
enum TT_NOIND = 0x00000000;
enum TT_CBR = 0x00000004;
enum TT_VBR = 0x00000008;
enum TR_NOIND = 0x00000000;
enum TR_END_TO_END = 0x00000001;
enum TR_NO_END_TO_END = 0x00000002;
enum CLIP_NOT = 0x00000000;
enum CLIP_SUS = 0x00000020;
enum UP_P2P = 0x00000000;
enum UP_P2MP = 0x00000001;
enum BLLI_L2_MODE_NORMAL = 0x00000040;
enum BLLI_L2_MODE_EXT = 0x00000080;
enum BLLI_L3_MODE_NORMAL = 0x00000040;
enum BLLI_L3_MODE_EXT = 0x00000080;
enum BLLI_L3_PACKET_16 = 0x00000004;
enum BLLI_L3_PACKET_32 = 0x00000005;
enum BLLI_L3_PACKET_64 = 0x00000006;
enum BLLI_L3_PACKET_128 = 0x00000007;
enum BLLI_L3_PACKET_256 = 0x00000008;
enum BLLI_L3_PACKET_512 = 0x00000009;
enum BLLI_L3_PACKET_1024 = 0x0000000a;
enum BLLI_L3_PACKET_2048 = 0x0000000b;
enum BLLI_L3_PACKET_4096 = 0x0000000c;
enum PI_ALLOWED = 0x00000000;
enum PI_RESTRICTED = 0x00000040;
enum PI_NUMBER_NOT_AVAILABLE = 0x00000080;
enum SI_USER_NOT_SCREENED = 0x00000000;
enum SI_USER_PASSED = 0x00000001;
enum SI_USER_FAILED = 0x00000002;
enum SI_NETWORK = 0x00000003;
enum CAUSE_LOC_USER = 0x00000000;
enum CAUSE_LOC_PRIVATE_LOCAL = 0x00000001;
enum CAUSE_LOC_PUBLIC_LOCAL = 0x00000002;
enum CAUSE_LOC_TRANSIT_NETWORK = 0x00000003;
enum CAUSE_LOC_PUBLIC_REMOTE = 0x00000004;
enum CAUSE_LOC_PRIVATE_REMOTE = 0x00000005;
enum CAUSE_LOC_INTERNATIONAL_NETWORK = 0x00000007;
enum CAUSE_LOC_BEYOND_INTERWORKING = 0x0000000a;
enum CAUSE_UNALLOCATED_NUMBER = 0x00000001;
enum CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK = 0x00000002;
enum CAUSE_NO_ROUTE_TO_DESTINATION = 0x00000003;
enum CAUSE_VPI_VCI_UNACCEPTABLE = 0x0000000a;
enum CAUSE_NORMAL_CALL_CLEARING = 0x00000010;
enum CAUSE_USER_BUSY = 0x00000011;
enum CAUSE_NO_USER_RESPONDING = 0x00000012;
enum CAUSE_CALL_REJECTED = 0x00000015;
enum CAUSE_NUMBER_CHANGED = 0x00000016;
enum CAUSE_USER_REJECTS_CLIR = 0x00000017;
enum CAUSE_DESTINATION_OUT_OF_ORDER = 0x0000001b;
enum CAUSE_INVALID_NUMBER_FORMAT = 0x0000001c;
enum CAUSE_STATUS_ENQUIRY_RESPONSE = 0x0000001e;
enum CAUSE_NORMAL_UNSPECIFIED = 0x0000001f;
enum CAUSE_VPI_VCI_UNAVAILABLE = 0x00000023;
enum CAUSE_NETWORK_OUT_OF_ORDER = 0x00000026;
enum CAUSE_TEMPORARY_FAILURE = 0x00000029;
enum CAUSE_ACCESS_INFORMAION_DISCARDED = 0x0000002b;
enum CAUSE_NO_VPI_VCI_AVAILABLE = 0x0000002d;
enum CAUSE_RESOURCE_UNAVAILABLE = 0x0000002f;
enum CAUSE_QOS_UNAVAILABLE = 0x00000031;
enum CAUSE_USER_CELL_RATE_UNAVAILABLE = 0x00000033;
enum CAUSE_BEARER_CAPABILITY_UNAUTHORIZED = 0x00000039;
enum CAUSE_BEARER_CAPABILITY_UNAVAILABLE = 0x0000003a;
enum CAUSE_OPTION_UNAVAILABLE = 0x0000003f;
enum CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED = 0x00000041;
enum CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS = 0x00000049;
enum CAUSE_INVALID_CALL_REFERENCE = 0x00000051;
enum CAUSE_CHANNEL_NONEXISTENT = 0x00000052;
enum CAUSE_INCOMPATIBLE_DESTINATION = 0x00000058;
enum CAUSE_INVALID_ENDPOINT_REFERENCE = 0x00000059;
enum CAUSE_INVALID_TRANSIT_NETWORK_SELECTION = 0x0000005b;
enum CAUSE_TOO_MANY_PENDING_ADD_PARTY = 0x0000005c;
enum CAUSE_AAL_PARAMETERS_UNSUPPORTED = 0x0000005d;
enum CAUSE_MANDATORY_IE_MISSING = 0x00000060;
enum CAUSE_UNIMPLEMENTED_MESSAGE_TYPE = 0x00000061;
enum CAUSE_UNIMPLEMENTED_IE = 0x00000063;
enum CAUSE_INVALID_IE_CONTENTS = 0x00000064;
enum CAUSE_INVALID_STATE_FOR_MESSAGE = 0x00000065;
enum CAUSE_RECOVERY_ON_TIMEOUT = 0x00000066;
enum CAUSE_INCORRECT_MESSAGE_LENGTH = 0x00000068;
enum CAUSE_PROTOCOL_ERROR = 0x0000006f;
enum CAUSE_COND_UNKNOWN = 0x00000000;
enum CAUSE_COND_PERMANENT = 0x00000001;
enum CAUSE_COND_TRANSIENT = 0x00000002;
enum CAUSE_REASON_USER = 0x00000000;
enum CAUSE_REASON_IE_MISSING = 0x00000004;
enum CAUSE_REASON_IE_INSUFFICIENT = 0x00000008;
enum CAUSE_PU_PROVIDER = 0x00000000;
enum CAUSE_PU_USER = 0x00000008;
enum CAUSE_NA_NORMAL = 0x00000000;
enum CAUSE_NA_ABNORMAL = 0x00000004;
enum QOS_CLASS0 = 0x00000000;
enum QOS_CLASS1 = 0x00000001;
enum QOS_CLASS2 = 0x00000002;
enum QOS_CLASS3 = 0x00000003;
enum QOS_CLASS4 = 0x00000004;
enum TNS_TYPE_NATIONAL = 0x00000040;
enum TNS_PLAN_CARRIER_ID_CODE = 0x00000001;
enum SIO_GET_NUMBER_OF_ATM_DEVICES = 0x50160001;
enum SIO_GET_ATM_ADDRESS = 0xd0160002;
enum SIO_ASSOCIATE_PVC = 0x90160003;
enum SIO_GET_ATM_CONNECTION_ID = 0x50160004;
enum WSPDESCRIPTION_LEN = 0x000000ff;
enum WSS_OPERATION_IN_PROGRESS = 0x00000103;
enum LSP_SYSTEM = 0x80000000;
enum LSP_INSPECTOR = 0x00000001;
enum LSP_REDIRECTOR = 0x00000002;
enum LSP_PROXY = 0x00000004;
enum LSP_FIREWALL = 0x00000008;
enum LSP_INBOUND_MODIFY = 0x00000010;
enum LSP_OUTBOUND_MODIFY = 0x00000020;
enum LSP_CRYPTO_COMPRESS = 0x00000040;
enum LSP_LOCAL_CACHE = 0x00000080;
enum UDP_NOCHECKSUM = 0x00000001;
enum UDP_CHECKSUM_COVERAGE = 0x00000014;
enum GAI_STRERROR_BUFFER_SIZE = 0x00000400;
enum IPX_PTYPE = 0x00004000;
enum IPX_FILTERPTYPE = 0x00004001;
enum IPX_STOPFILTERPTYPE = 0x00004003;
enum IPX_DSTYPE = 0x00004002;
enum IPX_EXTENDED_ADDRESS = 0x00004004;
enum IPX_RECVHDR = 0x00004005;
enum IPX_MAXSIZE = 0x00004006;
enum IPX_ADDRESS = 0x00004007;
enum IPX_GETNETINFO = 0x00004008;
enum IPX_GETNETINFO_NORIP = 0x00004009;
enum IPX_SPXGETCONNECTIONSTATUS = 0x0000400b;
enum IPX_ADDRESS_NOTIFY = 0x0000400c;
enum IPX_MAX_ADAPTER_NUM = 0x0000400d;
enum IPX_RERIPNETNUMBER = 0x0000400e;
enum IPX_RECEIVE_BROADCAST = 0x0000400f;
enum IPX_IMMEDIATESPXACK = 0x00004010;
enum MAX_MCAST_TTL = 0x000000ff;
enum RM_OPTIONSBASE = 0x000003e8;
enum RM_RATE_WINDOW_SIZE = 0x000003e9;
enum RM_SET_MESSAGE_BOUNDARY = 0x000003ea;
enum RM_FLUSHCACHE = 0x000003eb;
enum RM_SENDER_WINDOW_ADVANCE_METHOD = 0x000003ec;
enum RM_SENDER_STATISTICS = 0x000003ed;
enum RM_LATEJOIN = 0x000003ee;
enum RM_SET_SEND_IF = 0x000003ef;
enum RM_ADD_RECEIVE_IF = 0x000003f0;
enum RM_DEL_RECEIVE_IF = 0x000003f1;
enum RM_SEND_WINDOW_ADV_RATE = 0x000003f2;
enum RM_USE_FEC = 0x000003f3;
enum RM_SET_MCAST_TTL = 0x000003f4;
enum RM_RECEIVER_STATISTICS = 0x000003f5;
enum RM_HIGH_SPEED_INTRANET_OPT = 0x000003f6;
enum SENDER_DEFAULT_RATE_KBITS_PER_SEC = 0x00000038;
enum SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE = 0x0000000f;
enum MAX_WINDOW_INCREMENT_PERCENTAGE = 0x00000019;
enum SENDER_DEFAULT_LATE_JOINER_PERCENTAGE = 0x00000000;
enum SENDER_MAX_LATE_JOINER_PERCENTAGE = 0x0000004b;
enum BITS_PER_BYTE = 0x00000008;
enum LOG2_BITS_PER_BYTE = 0x00000003;
enum UNIX_PATH_MAX = 0x0000006c;
enum SIO_AF_UNIX_GETPEERPID = 0x58000100;
enum SIO_AF_UNIX_SETBINDPARENTPATH = 0x98000101;
enum SIO_AF_UNIX_SETCONNPARENTPATH = 0x98000102;
enum ISOPROTO_TP0 = 0x00000019;
enum ISOPROTO_TP1 = 0x0000001a;
enum ISOPROTO_TP2 = 0x0000001b;
enum ISOPROTO_TP3 = 0x0000001c;
enum ISOPROTO_TP4 = 0x0000001d;
enum ISOPROTO_TP = 0x0000001d;
enum ISOPROTO_CLTP = 0x0000001e;
enum ISOPROTO_CLNP = 0x0000001f;
enum ISOPROTO_X25 = 0x00000020;
enum ISOPROTO_INACT_NL = 0x00000021;
enum ISOPROTO_ESIS = 0x00000022;
enum ISOPROTO_INTRAISIS = 0x00000023;
enum ISO_MAX_ADDR_LENGTH = 0x00000040;
enum ISO_HIERARCHICAL = 0x00000000;
enum ISO_NON_HIERARCHICAL = 0x00000001;
enum ISO_EXP_DATA_USE = 0x00000000;
enum ISO_EXP_DATA_NUSE = 0x00000001;
enum NSPROTO_IPX = 0x000003e8;
enum NSPROTO_SPX = 0x000004e8;
enum NSPROTO_SPXII = 0x000004e9;
enum NETBIOS_NAME_LENGTH = 0x00000010;
enum NETBIOS_UNIQUE_NAME = 0x00000000;
enum NETBIOS_GROUP_NAME = 0x00000001;
enum NETBIOS_TYPE_QUICK_UNIQUE = 0x00000002;
enum NETBIOS_TYPE_QUICK_GROUP = 0x00000003;
enum VNSPROTO_IPC = 0x00000001;
enum VNSPROTO_RELIABLE_IPC = 0x00000002;
enum VNSPROTO_SPP = 0x00000003;
enum _LITTLE_ENDIAN = 0x000004d2;
enum _BIG_ENDIAN = 0x000010e1;
enum _PDP_ENDIAN = 0x00000d54;
enum BYTE_ORDER = 0x000004d2;
enum DL_ADDRESS_LENGTH_MAXIMUM = 0x00000020;
enum DL_HEADER_LENGTH_MAXIMUM = 0x00000040;
enum SNAP_DSAP = 0x000000aa;
enum SNAP_SSAP = 0x000000aa;
enum SNAP_CONTROL = 0x00000003;
enum SNAP_OUI = 0x00000000;
enum ETH_LENGTH_OF_HEADER = 0x0000000e;
enum ETH_LENGTH_OF_VLAN_HEADER = 0x00000004;
enum ETH_LENGTH_OF_SNAP_HEADER = 0x00000008;
enum ETHERNET_TYPE_MINIMUM = 0x00000600;
enum ETHERNET_TYPE_IPV4 = 0x00000800;
enum ETHERNET_TYPE_ARP = 0x00000806;
enum ETHERNET_TYPE_IPV6 = 0x000086dd;
enum ETHERNET_TYPE_802_1Q = 0x00008100;
enum ETHERNET_TYPE_802_1AD = 0x000088a8;
enum IP_VER_MASK = 0x000000f0;
enum IPV4_VERSION = 0x00000004;
enum MAX_IPV4_PACKET = 0x0000ffff;
enum MAX_IPV4_HLEN = 0x0000003c;
enum IPV4_MINIMUM_MTU = 0x00000240;
enum IPV4_MIN_MINIMUM_MTU = 0x00000160;
enum IPV4_MAX_MINIMUM_MTU = 0x00000240;
enum SIZEOF_IP_OPT_ROUTING_HEADER = 0x00000003;
enum SIZEOF_IP_OPT_TIMESTAMP_HEADER = 0x00000004;
enum SIZEOF_IP_OPT_SECURITY = 0x0000000b;
enum SIZEOF_IP_OPT_STREAMIDENTIFIER = 0x00000004;
enum SIZEOF_IP_OPT_ROUTERALERT = 0x00000004;
enum IP4_OFF_MASK = 0x0000ff1f;
enum ICMPV4_INVALID_PREFERENCE_LEVEL = 0x80000000;
enum IGMP_QUERY_TYPE = 0x00000011;
enum IGMP_VERSION1_REPORT_TYPE = 0x00000012;
enum IGMP_VERSION2_REPORT_TYPE = 0x00000016;
enum IGMP_LEAVE_GROUP_TYPE = 0x00000017;
enum IGMP_VERSION3_REPORT_TYPE = 0x00000022;
enum IPV6_VERSION = 0x00000060;
enum IPV6_TRAFFIC_CLASS_MASK = 0x0000c00f;
enum IPV6_FULL_TRAFFIC_CLASS_MASK = 0x0000f00f;
enum IPV6_ECN_MASK = 0x00003000;
enum IPV6_FLOW_LABEL_MASK = 0xffff0f00;
enum MAX_IPV6_PAYLOAD = 0x0000ffff;
enum IPV6_ECN_SHIFT = 0x0000000c;
enum IPV6_MINIMUM_MTU = 0x00000500;
enum IP6F_OFF_MASK = 0x0000f8ff;
enum IP6F_RESERVED_MASK = 0x00000600;
enum IP6F_MORE_FRAG = 0x00000100;
enum EXT_LEN_UNIT = 0x00000008;
enum IP6OPT_TYPE_SKIP = 0x00000000;
enum IP6OPT_TYPE_DISCARD = 0x00000040;
enum IP6OPT_TYPE_FORCEICMP = 0x00000080;
enum IP6OPT_TYPE_ICMP = 0x000000c0;
enum IP6OPT_MUTABLE = 0x00000020;
enum ICMP6_DST_UNREACH_NOROUTE = 0x00000000;
enum ICMP6_DST_UNREACH_ADMIN = 0x00000001;
enum ICMP6_DST_UNREACH_BEYONDSCOPE = 0x00000002;
enum ICMP6_DST_UNREACH_ADDR = 0x00000003;
enum ICMP6_DST_UNREACH_NOPORT = 0x00000004;
enum ICMP6_TIME_EXCEED_TRANSIT = 0x00000000;
enum ICMP6_TIME_EXCEED_REASSEMBLY = 0x00000001;
enum ICMP6_PARAMPROB_HEADER = 0x00000000;
enum ICMP6_PARAMPROB_NEXTHEADER = 0x00000001;
enum ICMP6_PARAMPROB_OPTION = 0x00000002;
enum ICMP6_PARAMPROB_FIRSTFRAGMENT = 0x00000003;
enum ICMPV6_ECHO_REQUEST_FLAG_REVERSE = 0x00000001;
enum ND_RA_FLAG_MANAGED = 0x00000080;
enum ND_RA_FLAG_OTHER = 0x00000040;
enum ND_RA_FLAG_HOME_AGENT = 0x00000020;
enum ND_RA_FLAG_PREFERENCE = 0x00000018;
enum ND_NA_FLAG_ROUTER = 0x80000000;
enum ND_NA_FLAG_SOLICITED = 0x40000000;
enum ND_NA_FLAG_OVERRIDE = 0x20000000;
enum ND_OPT_PI_FLAG_ONLINK = 0x00000080;
enum ND_OPT_PI_FLAG_AUTO = 0x00000040;
enum ND_OPT_PI_FLAG_ROUTER_ADDR = 0x00000020;
enum ND_OPT_PI_FLAG_SITE_PREFIX = 0x00000010;
enum ND_OPT_PI_FLAG_ROUTE = 0x00000001;
enum ND_OPT_RI_FLAG_PREFERENCE = 0x00000018;
enum ND_OPT_RDNSS_MIN_LEN = 0x00000018;
enum ND_OPT_DNSSL_MIN_LEN = 0x00000010;
enum IN6_EMBEDDEDV4_UOCTET_POSITION = 0x00000008;
enum IN6_EMBEDDEDV4_BITS_IN_BYTE = 0x00000008;
enum TH_FIN = 0x00000001;
enum TH_SYN = 0x00000002;
enum TH_RST = 0x00000004;
enum TH_PSH = 0x00000008;
enum TH_ACK = 0x00000010;
enum TH_URG = 0x00000020;
enum TH_ECE = 0x00000040;
enum TH_CWR = 0x00000080;
enum TH_OPT_EOL = 0x00000000;
enum TH_OPT_NOP = 0x00000001;
enum TH_OPT_MSS = 0x00000002;
enum TH_OPT_WS = 0x00000003;
enum TH_OPT_SACK_PERMITTED = 0x00000004;
enum TH_OPT_SACK = 0x00000005;
enum TH_OPT_TS = 0x00000008;
enum TH_OPT_FASTOPEN = 0x00000022;
enum INVALID_SOCKET = 0xffffffffffffffff;
enum WSA_INFINITE = 0xffffffff;
enum IOC_INOUT = 0xc0000000;
enum FIONREAD = 0x4004667f;
enum FIONBIO = 0xffffffff8004667e;
enum FIOASYNC = 0xffffffff8004667d;
enum SIOCSHIWAT = 0xffffffff80047300;
enum SIOCGHIWAT = 0x40047301;
enum SIOCSLOWAT = 0xffffffff80047302;
enum SIOCGLOWAT = 0x40047303;
enum SIOCATMARK = 0x40047307;
enum LM_HB_Extension = 0x00000080;
enum LM_HB1_PnP = 0x00000001;
enum LM_HB1_PDA_Palmtop = 0x00000002;
enum LM_HB1_Computer = 0x00000004;
enum LM_HB1_Printer = 0x00000008;
enum LM_HB1_Modem = 0x00000010;
enum LM_HB1_Fax = 0x00000020;
enum LM_HB1_LANAccess = 0x00000040;
enum LM_HB2_Telephony = 0x00000001;
enum LM_HB2_FileServer = 0x00000002;
alias WSAEVENT = long;
alias SOCKET = ulong;
alias socklen_t = int;
alias sa_family_t = ushort;
alias RIO_BUFFERID = long;
alias RIO_CQ = long;
alias RIO_RQ = long;
struct FLOWSPEC
{
    uint TokenRate;
    uint TokenBucketSize;
    uint PeakBandwidth;
    uint Latency;
    uint DelayVariation;
    uint ServiceType;
    uint MaxSduSize;
    uint MinimumPolicedSize;
}
struct SERVENT
{
    PSTR s_name;
    byte** s_aliases;
    PSTR s_proto;
    short s_port;
}
struct WSADATA
{
    ushort wVersion;
    ushort wHighVersion;
    ushort iMaxSockets;
    ushort iMaxUdpDg;
    PSTR lpVendorInfo;
    CHAR[257] szDescription;
    CHAR[129] szSystemStatus;
}
struct IN_ADDR
{
    union _S_un_e__Union
    {
        struct _S_un_b_e__Struct
        {
            ubyte s_b1;
            ubyte s_b2;
            ubyte s_b3;
            ubyte s_b4;
        }
        struct _S_un_w_e__Struct
        {
            ushort s_w1;
            ushort s_w2;
        }
        uint S_addr;
    }
}
struct SOCKADDR
{
    ADDRESS_FAMILY sa_family;
    CHAR[14] sa_data;
}
struct SOCKET_ADDRESS
{
    SOCKADDR* lpSockaddr;
    int iSockaddrLength;
}
struct SOCKET_ADDRESS_LIST
{
    int iAddressCount;
    SOCKET_ADDRESS[1] Address;
}
struct CSADDR_INFO
{
    SOCKET_ADDRESS LocalAddr;
    SOCKET_ADDRESS RemoteAddr;
    int iSocketType;
    int iProtocol;
}
struct SOCKADDR_STORAGE
{
    ADDRESS_FAMILY ss_family;
    CHAR[6] __ss_pad1;
    long __ss_align;
    CHAR[112] __ss_pad2;
}
struct SOCKADDR_STORAGE_XP
{
    short ss_family;
    CHAR[6] __ss_pad1;
    long __ss_align;
    CHAR[112] __ss_pad2;
}
struct SOCKET_PROCESSOR_AFFINITY
{
    PROCESSOR_NUMBER Processor;
    ushort NumaNodeId;
    ushort Reserved;
}
alias IPPROTO = int;
enum : int
{
    IPPROTO_HOPOPTS               = 0x00000000,
    IPPROTO_ICMP                  = 0x00000001,
    IPPROTO_IGMP                  = 0x00000002,
    IPPROTO_GGP                   = 0x00000003,
    IPPROTO_IPV4                  = 0x00000004,
    IPPROTO_ST                    = 0x00000005,
    IPPROTO_TCP                   = 0x00000006,
    IPPROTO_CBT                   = 0x00000007,
    IPPROTO_EGP                   = 0x00000008,
    IPPROTO_IGP                   = 0x00000009,
    IPPROTO_PUP                   = 0x0000000c,
    IPPROTO_UDP                   = 0x00000011,
    IPPROTO_IDP                   = 0x00000016,
    IPPROTO_RDP                   = 0x0000001b,
    IPPROTO_IPV6                  = 0x00000029,
    IPPROTO_ROUTING               = 0x0000002b,
    IPPROTO_FRAGMENT              = 0x0000002c,
    IPPROTO_ESP                   = 0x00000032,
    IPPROTO_AH                    = 0x00000033,
    IPPROTO_ICMPV6                = 0x0000003a,
    IPPROTO_NONE                  = 0x0000003b,
    IPPROTO_DSTOPTS               = 0x0000003c,
    IPPROTO_ND                    = 0x0000004d,
    IPPROTO_ICLFXBM               = 0x0000004e,
    IPPROTO_PIM                   = 0x00000067,
    IPPROTO_PGM                   = 0x00000071,
    IPPROTO_L2TP                  = 0x00000073,
    IPPROTO_SCTP                  = 0x00000084,
    IPPROTO_RAW                   = 0x000000ff,
    IPPROTO_MAX                   = 0x00000100,
    IPPROTO_RESERVED_RAW          = 0x00000101,
    IPPROTO_RESERVED_IPSEC        = 0x00000102,
    IPPROTO_RESERVED_IPSECOFFLOAD = 0x00000103,
    IPPROTO_RESERVED_WNV          = 0x00000104,
    IPPROTO_RESERVED_MAX          = 0x00000105,
    IPPROTO_IP                    = 0x00000000,
    IPPROTO_RM                    = 0x00000071,
}

alias SCOPE_LEVEL = int;
enum : int
{
    ScopeLevelInterface    = 0x00000001,
    ScopeLevelLink         = 0x00000002,
    ScopeLevelSubnet       = 0x00000003,
    ScopeLevelAdmin        = 0x00000004,
    ScopeLevelSite         = 0x00000005,
    ScopeLevelOrganization = 0x00000008,
    ScopeLevelGlobal       = 0x0000000e,
    ScopeLevelCount        = 0x00000010,
}

struct SCOPE_ID
{
    union
    {
        struct
        {
            uint _bitfield0;
        }
        uint Value;
    }
}
struct SOCKADDR_IN
{
    ADDRESS_FAMILY sin_family;
    ushort sin_port;
    IN_ADDR sin_addr;
    CHAR[8] sin_zero;
}
struct SOCKADDR_DL
{
    ADDRESS_FAMILY sdl_family;
    ubyte[8] sdl_data;
    ubyte[4] sdl_zero;
}
struct WSABUF
{
    uint len;
    PSTR buf;
}
struct WSAMSG
{
    SOCKADDR* name;
    int namelen;
    WSABUF* lpBuffers;
    uint dwBufferCount;
    WSABUF Control;
    uint dwFlags;
}
struct CMSGHDR
{
    ulong cmsg_len;
    int cmsg_level;
    int cmsg_type;
}
struct ADDRINFOA
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    ulong ai_addrlen;
    PSTR ai_canonname;
    SOCKADDR* ai_addr;
    ADDRINFOA* ai_next;
}
struct ADDRINFOW
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    ulong ai_addrlen;
    PWSTR ai_canonname;
    SOCKADDR* ai_addr;
    ADDRINFOW* ai_next;
}
struct ADDRINFOEXA
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    ulong ai_addrlen;
    PSTR ai_canonname;
    SOCKADDR* ai_addr;
    void* ai_blob;
    ulong ai_bloblen;
    GUID* ai_provider;
    ADDRINFOEXA* ai_next;
}
struct ADDRINFOEXW
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    ulong ai_addrlen;
    PWSTR ai_canonname;
    SOCKADDR* ai_addr;
    void* ai_blob;
    ulong ai_bloblen;
    GUID* ai_provider;
    ADDRINFOEXW* ai_next;
}
struct ADDRINFOEX2A
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    ulong ai_addrlen;
    PSTR ai_canonname;
    SOCKADDR* ai_addr;
    void* ai_blob;
    ulong ai_bloblen;
    GUID* ai_provider;
    ADDRINFOEX2A* ai_next;
    int ai_version;
    PSTR ai_fqdn;
}
struct ADDRINFOEX2W
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    ulong ai_addrlen;
    PWSTR ai_canonname;
    SOCKADDR* ai_addr;
    void* ai_blob;
    ulong ai_bloblen;
    GUID* ai_provider;
    ADDRINFOEX2W* ai_next;
    int ai_version;
    PWSTR ai_fqdn;
}
struct ADDRINFOEX3
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    ulong ai_addrlen;
    PWSTR ai_canonname;
    SOCKADDR* ai_addr;
    void* ai_blob;
    ulong ai_bloblen;
    GUID* ai_provider;
    ADDRINFOEX3* ai_next;
    int ai_version;
    PWSTR ai_fqdn;
    int ai_interfaceindex;
}
struct ADDRINFOEX4
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    ulong ai_addrlen;
    PWSTR ai_canonname;
    SOCKADDR* ai_addr;
    void* ai_blob;
    ulong ai_bloblen;
    GUID* ai_provider;
    ADDRINFOEX4* ai_next;
    int ai_version;
    PWSTR ai_fqdn;
    int ai_interfaceindex;
    HANDLE ai_resolutionhandle;
}
struct ADDRINFOEX5
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    ulong ai_addrlen;
    PWSTR ai_canonname;
    SOCKADDR* ai_addr;
    void* ai_blob;
    ulong ai_bloblen;
    GUID* ai_provider;
    ADDRINFOEX5* ai_next;
    int ai_version;
    PWSTR ai_fqdn;
    int ai_interfaceindex;
    HANDLE ai_resolutionhandle;
    uint ai_ttl;
}
struct ADDRINFO_DNS_SERVER
{
    uint ai_servertype;
    ulong ai_flags;
    uint ai_addrlen;
    SOCKADDR* ai_addr;
    union
    {
        PWSTR ai_template;
    }
}
struct ADDRINFOEX6
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    ulong ai_addrlen;
    PWSTR ai_canonname;
    SOCKADDR* ai_addr;
    void* ai_blob;
    ulong ai_bloblen;
    GUID* ai_provider;
    ADDRINFOEX5* ai_next;
    int ai_version;
    PWSTR ai_fqdn;
    int ai_interfaceindex;
    HANDLE ai_resolutionhandle;
    uint ai_ttl;
    uint ai_numservers;
    ADDRINFO_DNS_SERVER* ai_servers;
    ulong ai_responseflags;
}
struct FD_SET
{
    uint fd_count;
    SOCKET[64] fd_array;
}
struct TIMEVAL
{
    int tv_sec;
    int tv_usec;
}
struct HOSTENT
{
    PSTR h_name;
    byte** h_aliases;
    short h_addrtype;
    short h_length;
    byte** h_addr_list;
}
struct netent
{
    PSTR n_name;
    byte** n_aliases;
    short n_addrtype;
    uint n_net;
}
/+ [CONFLICTED] struct SERVENT
{
    PSTR s_name;
    byte** s_aliases;
    short s_port;
    PSTR s_proto;
}
+/
struct PROTOENT
{
    PSTR p_name;
    byte** p_aliases;
    short p_proto;
}
/+ [CONFLICTED] struct WSADATA
{
    ushort wVersion;
    ushort wHighVersion;
    CHAR[257] szDescription;
    CHAR[129] szSystemStatus;
    ushort iMaxSockets;
    ushort iMaxUdpDg;
    PSTR lpVendorInfo;
}
+/
struct sockproto
{
    ushort sp_family;
    ushort sp_protocol;
}
struct LINGER
{
    ushort l_onoff;
    ushort l_linger;
}
struct QOS
{
    FLOWSPEC SendingFlowspec;
    FLOWSPEC ReceivingFlowspec;
    WSABUF ProviderSpecific;
}
struct WSANETWORKEVENTS
{
    int lNetworkEvents;
    int[10] iErrorCode;
}
struct WSAPROTOCOLCHAIN
{
    int ChainLen;
    uint[7] ChainEntries;
}
struct WSAPROTOCOL_INFOA
{
    uint dwServiceFlags1;
    uint dwServiceFlags2;
    uint dwServiceFlags3;
    uint dwServiceFlags4;
    uint dwProviderFlags;
    GUID ProviderId;
    uint dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int iVersion;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    int iProtocolMaxOffset;
    int iNetworkByteOrder;
    int iSecurityScheme;
    uint dwMessageSize;
    uint dwProviderReserved;
    CHAR[256] szProtocol;
}
struct WSAPROTOCOL_INFOW
{
    uint dwServiceFlags1;
    uint dwServiceFlags2;
    uint dwServiceFlags3;
    uint dwServiceFlags4;
    uint dwProviderFlags;
    GUID ProviderId;
    uint dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int iVersion;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    int iProtocolMaxOffset;
    int iNetworkByteOrder;
    int iSecurityScheme;
    uint dwMessageSize;
    uint dwProviderReserved;
    wchar[256] szProtocol;
}
alias LPCONDITIONPROC = int function(WSABUF*, WSABUF*, QOS*, QOS*, WSABUF*, WSABUF*, uint*, ulong);
alias LPWSAOVERLAPPED_COMPLETION_ROUTINE = void function(uint, uint, OVERLAPPED*, uint);
alias WSACOMPLETIONTYPE = int;
enum : int
{
    NSP_NOTIFY_IMMEDIATELY = 0x00000000,
    NSP_NOTIFY_HWND        = 0x00000001,
    NSP_NOTIFY_EVENT       = 0x00000002,
    NSP_NOTIFY_PORT        = 0x00000003,
    NSP_NOTIFY_APC         = 0x00000004,
}

struct WSACOMPLETION
{
    WSACOMPLETIONTYPE Type;
    union _Parameters_e__Union
    {
        struct _WindowMessage_e__Struct
        {
            HWND hWnd;
            uint uMsg;
            WPARAM context;
        }
        struct _Event_e__Struct
        {
            OVERLAPPED* lpOverlapped;
        }
        struct _Apc_e__Struct
        {
            OVERLAPPED* lpOverlapped;
            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc;
        }
        struct _Port_e__Struct
        {
            OVERLAPPED* lpOverlapped;
            HANDLE hPort;
            ulong Key;
        }
    }
}
struct AFPROTOCOLS
{
    int iAddressFamily;
    int iProtocol;
}
alias WSAECOMPARATOR = int;
enum : int
{
    COMP_EQUAL   = 0x00000000,
    COMP_NOTLESS = 0x00000001,
}

struct WSAVERSION
{
    uint dwVersion;
    WSAECOMPARATOR ecHow;
}
struct WSAQUERYSETA
{
    uint dwSize;
    PSTR lpszServiceInstanceName;
    GUID* lpServiceClassId;
    WSAVERSION* lpVersion;
    PSTR lpszComment;
    uint dwNameSpace;
    GUID* lpNSProviderId;
    PSTR lpszContext;
    uint dwNumberOfProtocols;
    AFPROTOCOLS* lpafpProtocols;
    PSTR lpszQueryString;
    uint dwNumberOfCsAddrs;
    CSADDR_INFO* lpcsaBuffer;
    uint dwOutputFlags;
    BLOB* lpBlob;
}
struct WSAQUERYSETW
{
    uint dwSize;
    PWSTR lpszServiceInstanceName;
    GUID* lpServiceClassId;
    WSAVERSION* lpVersion;
    PWSTR lpszComment;
    uint dwNameSpace;
    GUID* lpNSProviderId;
    PWSTR lpszContext;
    uint dwNumberOfProtocols;
    AFPROTOCOLS* lpafpProtocols;
    PWSTR lpszQueryString;
    uint dwNumberOfCsAddrs;
    CSADDR_INFO* lpcsaBuffer;
    uint dwOutputFlags;
    BLOB* lpBlob;
}
struct WSAQUERYSET2A
{
    uint dwSize;
    PSTR lpszServiceInstanceName;
    WSAVERSION* lpVersion;
    PSTR lpszComment;
    uint dwNameSpace;
    GUID* lpNSProviderId;
    PSTR lpszContext;
    uint dwNumberOfProtocols;
    AFPROTOCOLS* lpafpProtocols;
    PSTR lpszQueryString;
    uint dwNumberOfCsAddrs;
    CSADDR_INFO* lpcsaBuffer;
    uint dwOutputFlags;
    BLOB* lpBlob;
}
struct WSAQUERYSET2W
{
    uint dwSize;
    PWSTR lpszServiceInstanceName;
    WSAVERSION* lpVersion;
    PWSTR lpszComment;
    uint dwNameSpace;
    GUID* lpNSProviderId;
    PWSTR lpszContext;
    uint dwNumberOfProtocols;
    AFPROTOCOLS* lpafpProtocols;
    PWSTR lpszQueryString;
    uint dwNumberOfCsAddrs;
    CSADDR_INFO* lpcsaBuffer;
    uint dwOutputFlags;
    BLOB* lpBlob;
}
alias WSAESETSERVICEOP = int;
enum : int
{
    RNRSERVICE_REGISTER   = 0x00000000,
    RNRSERVICE_DEREGISTER = 0x00000001,
    RNRSERVICE_DELETE     = 0x00000002,
}

struct WSANSCLASSINFOA
{
    PSTR lpszName;
    uint dwNameSpace;
    uint dwValueType;
    uint dwValueSize;
    void* lpValue;
}
struct WSANSCLASSINFOW
{
    PWSTR lpszName;
    uint dwNameSpace;
    uint dwValueType;
    uint dwValueSize;
    void* lpValue;
}
struct WSASERVICECLASSINFOA
{
    GUID* lpServiceClassId;
    PSTR lpszServiceClassName;
    uint dwCount;
    WSANSCLASSINFOA* lpClassInfos;
}
struct WSASERVICECLASSINFOW
{
    GUID* lpServiceClassId;
    PWSTR lpszServiceClassName;
    uint dwCount;
    WSANSCLASSINFOW* lpClassInfos;
}
struct WSANAMESPACE_INFOA
{
    GUID NSProviderId;
    uint dwNameSpace;
    BOOL fActive;
    uint dwVersion;
    PSTR lpszIdentifier;
}
struct WSANAMESPACE_INFOW
{
    GUID NSProviderId;
    uint dwNameSpace;
    BOOL fActive;
    uint dwVersion;
    PWSTR lpszIdentifier;
}
struct WSANAMESPACE_INFOEXA
{
    GUID NSProviderId;
    uint dwNameSpace;
    BOOL fActive;
    uint dwVersion;
    PSTR lpszIdentifier;
    BLOB ProviderSpecific;
}
struct WSANAMESPACE_INFOEXW
{
    GUID NSProviderId;
    uint dwNameSpace;
    BOOL fActive;
    uint dwVersion;
    PWSTR lpszIdentifier;
    BLOB ProviderSpecific;
}
struct WSAPOLLFD
{
    SOCKET fd;
    WSAPOLL_EVENT_FLAGS events;
    WSAPOLL_EVENT_FLAGS revents;
}
struct SOCK_NOTIFY_REGISTRATION
{
    SOCKET socket;
    void* completionKey;
    ushort eventFilter;
    ubyte operation;
    ubyte triggerFlags;
    uint registrationResult;
}
struct IN6_ADDR
{
    union _u_e__Union
    {
        ubyte[16] Byte;
        ushort[8] Word;
    }
}
struct sockaddr_in6_old
{
    short sin6_family;
    ushort sin6_port;
    uint sin6_flowinfo;
    IN6_ADDR sin6_addr;
}
union sockaddr_gen
{
    SOCKADDR Address;
    SOCKADDR_IN AddressIn;
    sockaddr_in6_old AddressIn6;
}
struct INTERFACE_INFO
{
    uint iiFlags;
    sockaddr_gen iiAddress;
    sockaddr_gen iiBroadcastAddress;
    sockaddr_gen iiNetmask;
}
struct INTERFACE_INFO_EX
{
    uint iiFlags;
    SOCKET_ADDRESS iiAddress;
    SOCKET_ADDRESS iiBroadcastAddress;
    SOCKET_ADDRESS iiNetmask;
}
alias PMTUD_STATE = int;
enum : int
{
    IP_PMTUDISC_NOT_SET = 0x00000000,
    IP_PMTUDISC_DO      = 0x00000001,
    IP_PMTUDISC_DONT    = 0x00000002,
    IP_PMTUDISC_PROBE   = 0x00000003,
    IP_PMTUDISC_MAX     = 0x00000004,
}

struct SOCKADDR_IN6
{
    ADDRESS_FAMILY sin6_family;
    ushort sin6_port;
    uint sin6_flowinfo;
    IN6_ADDR sin6_addr;
    union
    {
        uint sin6_scope_id;
        SCOPE_ID sin6_scope_struct;
    }
}
struct SOCKADDR_IN6_W2KSP1
{
    short sin6_family;
    ushort sin6_port;
    uint sin6_flowinfo;
    IN6_ADDR sin6_addr;
    uint sin6_scope_id;
}
union SOCKADDR_INET
{
    SOCKADDR_IN Ipv4;
    SOCKADDR_IN6 Ipv6;
    ADDRESS_FAMILY si_family;
}
struct SOCKADDR_IN6_PAIR
{
    SOCKADDR_IN6* SourceAddress;
    SOCKADDR_IN6* DestinationAddress;
}
alias MULTICAST_MODE_TYPE = int;
enum : int
{
    MCAST_INCLUDE = 0x00000000,
    MCAST_EXCLUDE = 0x00000001,
}

struct IP_MREQ
{
    IN_ADDR imr_multiaddr;
    IN_ADDR imr_interface;
}
struct IP_MREQ_SOURCE
{
    IN_ADDR imr_multiaddr;
    IN_ADDR imr_sourceaddr;
    IN_ADDR imr_interface;
}
struct IP_MSFILTER
{
    IN_ADDR imsf_multiaddr;
    IN_ADDR imsf_interface;
    MULTICAST_MODE_TYPE imsf_fmode;
    uint imsf_numsrc;
    IN_ADDR[1] imsf_slist;
}
struct IPV6_MREQ
{
    IN6_ADDR ipv6mr_multiaddr;
    uint ipv6mr_interface;
}
struct GROUP_REQ
{
    uint gr_interface;
    SOCKADDR_STORAGE gr_group;
}
struct GROUP_SOURCE_REQ
{
    uint gsr_interface;
    SOCKADDR_STORAGE gsr_group;
    SOCKADDR_STORAGE gsr_source;
}
struct GROUP_FILTER
{
    uint gf_interface;
    SOCKADDR_STORAGE gf_group;
    MULTICAST_MODE_TYPE gf_fmode;
    uint gf_numsrc;
    SOCKADDR_STORAGE[1] gf_slist;
}
struct IN_PKTINFO
{
    IN_ADDR ipi_addr;
    uint ipi_ifindex;
}
struct IN6_PKTINFO
{
    IN6_ADDR ipi6_addr;
    uint ipi6_ifindex;
}
struct IN_PKTINFO_EX
{
    IN_PKTINFO pkt_info;
    SCOPE_ID scope_id;
}
struct IN6_PKTINFO_EX
{
    IN6_PKTINFO pkt_info;
    SCOPE_ID scope_id;
}
struct IN_RECVERR
{
    IPPROTO protocol;
    uint info;
    ubyte type;
    ubyte code;
}
struct ICMP_ERROR_INFO
{
    SOCKADDR_INET srcaddress;
    IPPROTO protocol;
    ubyte type;
    ubyte code;
}
alias eWINDOW_ADVANCE_METHOD = int;
enum : int
{
    E_WINDOW_ADVANCE_BY_TIME   = 0x00000001,
    E_WINDOW_USE_AS_DATA_CACHE = 0x00000002,
}

struct RM_SEND_WINDOW
{
    uint RateKbitsPerSec;
    uint WindowSizeInMSecs;
    uint WindowSizeInBytes;
}
struct RM_SENDER_STATS
{
    ulong DataBytesSent;
    ulong TotalBytesSent;
    ulong NaksReceived;
    ulong NaksReceivedTooLate;
    ulong NumOutstandingNaks;
    ulong NumNaksAfterRData;
    ulong RepairPacketsSent;
    ulong BufferSpaceAvailable;
    ulong TrailingEdgeSeqId;
    ulong LeadingEdgeSeqId;
    ulong RateKBitsPerSecOverall;
    ulong RateKBitsPerSecLast;
    ulong TotalODataPacketsSent;
}
struct RM_RECEIVER_STATS
{
    ulong NumODataPacketsReceived;
    ulong NumRDataPacketsReceived;
    ulong NumDuplicateDataPackets;
    ulong DataBytesReceived;
    ulong TotalBytesReceived;
    ulong RateKBitsPerSecOverall;
    ulong RateKBitsPerSecLast;
    ulong TrailingEdgeSeqId;
    ulong LeadingEdgeSeqId;
    ulong AverageSequencesInWindow;
    ulong MinSequencesInWindow;
    ulong MaxSequencesInWindow;
    ulong FirstNakSequenceNumber;
    ulong NumPendingNaks;
    ulong NumOutstandingNaks;
    ulong NumDataPacketsBuffered;
    ulong TotalSelectiveNaksSent;
    ulong TotalParityNaksSent;
}
struct RM_FEC_INFO
{
    ushort FECBlockSize;
    ushort FECProActivePackets;
    ubyte FECGroupSize;
    BOOLEAN fFECOnDemandParityEnabled;
}
struct IPX_ADDRESS_DATA
{
    int adapternum;
    ubyte[4] netnum;
    ubyte[6] nodenum;
    BOOLEAN wan;
    BOOLEAN status;
    int maxpkt;
    uint linkspeed;
}
struct IPX_NETNUM_DATA
{
    ubyte[4] netnum;
    ushort hopcount;
    ushort netdelay;
    int cardnum;
    ubyte[6] router;
}
struct IPX_SPXCONNSTATUS_DATA
{
    ubyte ConnectionState;
    ubyte WatchDogActive;
    ushort LocalConnectionId;
    ushort RemoteConnectionId;
    ushort LocalSequenceNumber;
    ushort LocalAckNumber;
    ushort LocalAllocNumber;
    ushort RemoteAckNumber;
    ushort RemoteAllocNumber;
    ushort LocalSocket;
    ubyte[6] ImmediateAddress;
    ubyte[4] RemoteNetwork;
    ubyte[6] RemoteNode;
    ushort RemoteSocket;
    ushort RetransmissionCount;
    ushort EstimatedRoundTripDelay;
    ushort RetransmittedPackets;
    ushort SuppressedPacket;
}
struct LM_IRPARMS
{
    uint nTXDataBytes;
    uint nRXDataBytes;
    uint nBaudRate;
    uint thresholdTime;
    uint discTime;
    ushort nMSLinkTurn;
    ubyte nTXPackets;
    ubyte nRXPackets;
}
struct SOCKADDR_IRDA
{
    ushort irdaAddressFamily;
    ubyte[4] irdaDeviceID;
    CHAR[25] irdaServiceName;
}
struct WINDOWS_IRDA_DEVICE_INFO
{
    ubyte[4] irdaDeviceID;
    CHAR[22] irdaDeviceName;
    ubyte irdaDeviceHints1;
    ubyte irdaDeviceHints2;
    ubyte irdaCharSet;
}
struct WCE_IRDA_DEVICE_INFO
{
    ubyte[4] irdaDeviceID;
    CHAR[22] irdaDeviceName;
    ubyte[2] Reserved;
}
struct WINDOWS_DEVICELIST
{
    uint numDevice;
    WINDOWS_IRDA_DEVICE_INFO[1] Device;
}
struct WCE_DEVICELIST
{
    uint numDevice;
    WCE_IRDA_DEVICE_INFO[1] Device;
}
struct WINDOWS_IAS_SET
{
    CHAR[64] irdaClassName;
    CHAR[256] irdaAttribName;
    uint irdaAttribType;
    union _irdaAttribute_e__Union
    {
        int irdaAttribInt;
        struct _irdaAttribOctetSeq_e__Struct
        {
            ushort Len;
            ubyte[1024] OctetSeq;
        }
        struct _irdaAttribUsrStr_e__Struct
        {
            ubyte Len;
            ubyte CharSet;
            ubyte[256] UsrStr;
        }
    }
}
struct WINDOWS_IAS_QUERY
{
    ubyte[4] irdaDeviceID;
    CHAR[64] irdaClassName;
    CHAR[256] irdaAttribName;
    uint irdaAttribType;
    union _irdaAttribute_e__Union
    {
        int irdaAttribInt;
        struct _irdaAttribOctetSeq_e__Struct
        {
            uint Len;
            ubyte[1024] OctetSeq;
        }
        struct _irdaAttribUsrStr_e__Struct
        {
            uint Len;
            uint CharSet;
            ubyte[256] UsrStr;
        }
    }
}
alias NL_PREFIX_ORIGIN = int;
enum : int
{
    IpPrefixOriginOther               = 0x00000000,
    IpPrefixOriginManual              = 0x00000001,
    IpPrefixOriginWellKnown           = 0x00000002,
    IpPrefixOriginDhcp                = 0x00000003,
    IpPrefixOriginRouterAdvertisement = 0x00000004,
    IpPrefixOriginUnchanged           = 0x00000010,
}

alias NL_SUFFIX_ORIGIN = int;
enum : int
{
    NlsoOther                      = 0x00000000,
    NlsoManual                     = 0x00000001,
    NlsoWellKnown                  = 0x00000002,
    NlsoDhcp                       = 0x00000003,
    NlsoLinkLayerAddress           = 0x00000004,
    NlsoRandom                     = 0x00000005,
    IpSuffixOriginOther            = 0x00000000,
    IpSuffixOriginManual           = 0x00000001,
    IpSuffixOriginWellKnown        = 0x00000002,
    IpSuffixOriginDhcp             = 0x00000003,
    IpSuffixOriginLinkLayerAddress = 0x00000004,
    IpSuffixOriginRandom           = 0x00000005,
    IpSuffixOriginUnchanged        = 0x00000010,
}

alias NL_DAD_STATE = int;
enum : int
{
    NldsInvalid          = 0x00000000,
    NldsTentative        = 0x00000001,
    NldsDuplicate        = 0x00000002,
    NldsDeprecated       = 0x00000003,
    NldsPreferred        = 0x00000004,
    IpDadStateInvalid    = 0x00000000,
    IpDadStateTentative  = 0x00000001,
    IpDadStateDuplicate  = 0x00000002,
    IpDadStateDeprecated = 0x00000003,
    IpDadStatePreferred  = 0x00000004,
}

alias NL_ROUTE_PROTOCOL = int;
enum : int
{
    RouteProtocolOther            = 0x00000001,
    RouteProtocolLocal            = 0x00000002,
    RouteProtocolNetMgmt          = 0x00000003,
    RouteProtocolIcmp             = 0x00000004,
    RouteProtocolEgp              = 0x00000005,
    RouteProtocolGgp              = 0x00000006,
    RouteProtocolHello            = 0x00000007,
    RouteProtocolRip              = 0x00000008,
    RouteProtocolIsIs             = 0x00000009,
    RouteProtocolEsIs             = 0x0000000a,
    RouteProtocolCisco            = 0x0000000b,
    RouteProtocolBbn              = 0x0000000c,
    RouteProtocolOspf             = 0x0000000d,
    RouteProtocolBgp              = 0x0000000e,
    RouteProtocolIdpr             = 0x0000000f,
    RouteProtocolEigrp            = 0x00000010,
    RouteProtocolDvmrp            = 0x00000011,
    RouteProtocolRpl              = 0x00000012,
    RouteProtocolDhcp             = 0x00000013,
    MIB_IPPROTO_OTHER             = 0x00000001,
    PROTO_IP_OTHER                = 0x00000001,
    MIB_IPPROTO_LOCAL             = 0x00000002,
    PROTO_IP_LOCAL                = 0x00000002,
    MIB_IPPROTO_NETMGMT           = 0x00000003,
    PROTO_IP_NETMGMT              = 0x00000003,
    MIB_IPPROTO_ICMP              = 0x00000004,
    PROTO_IP_ICMP                 = 0x00000004,
    MIB_IPPROTO_EGP               = 0x00000005,
    PROTO_IP_EGP                  = 0x00000005,
    MIB_IPPROTO_GGP               = 0x00000006,
    PROTO_IP_GGP                  = 0x00000006,
    MIB_IPPROTO_HELLO             = 0x00000007,
    PROTO_IP_HELLO                = 0x00000007,
    MIB_IPPROTO_RIP               = 0x00000008,
    PROTO_IP_RIP                  = 0x00000008,
    MIB_IPPROTO_IS_IS             = 0x00000009,
    PROTO_IP_IS_IS                = 0x00000009,
    MIB_IPPROTO_ES_IS             = 0x0000000a,
    PROTO_IP_ES_IS                = 0x0000000a,
    MIB_IPPROTO_CISCO             = 0x0000000b,
    PROTO_IP_CISCO                = 0x0000000b,
    MIB_IPPROTO_BBN               = 0x0000000c,
    PROTO_IP_BBN                  = 0x0000000c,
    MIB_IPPROTO_OSPF              = 0x0000000d,
    PROTO_IP_OSPF                 = 0x0000000d,
    MIB_IPPROTO_BGP               = 0x0000000e,
    PROTO_IP_BGP                  = 0x0000000e,
    MIB_IPPROTO_IDPR              = 0x0000000f,
    PROTO_IP_IDPR                 = 0x0000000f,
    MIB_IPPROTO_EIGRP             = 0x00000010,
    PROTO_IP_EIGRP                = 0x00000010,
    MIB_IPPROTO_DVMRP             = 0x00000011,
    PROTO_IP_DVMRP                = 0x00000011,
    MIB_IPPROTO_RPL               = 0x00000012,
    PROTO_IP_RPL                  = 0x00000012,
    MIB_IPPROTO_DHCP              = 0x00000013,
    PROTO_IP_DHCP                 = 0x00000013,
    MIB_IPPROTO_NT_AUTOSTATIC     = 0x00002712,
    PROTO_IP_NT_AUTOSTATIC        = 0x00002712,
    MIB_IPPROTO_NT_STATIC         = 0x00002716,
    PROTO_IP_NT_STATIC            = 0x00002716,
    MIB_IPPROTO_NT_STATIC_NON_DOD = 0x00002717,
    PROTO_IP_NT_STATIC_NON_DOD    = 0x00002717,
}

alias NL_ADDRESS_TYPE = int;
enum : int
{
    NlatUnspecified = 0x00000000,
    NlatUnicast     = 0x00000001,
    NlatAnycast     = 0x00000002,
    NlatMulticast   = 0x00000003,
    NlatBroadcast   = 0x00000004,
    NlatInvalid     = 0x00000005,
}

alias NL_ROUTE_ORIGIN = int;
enum : int
{
    NlroManual              = 0x00000000,
    NlroWellKnown           = 0x00000001,
    NlroDHCP                = 0x00000002,
    NlroRouterAdvertisement = 0x00000003,
    Nlro6to4                = 0x00000004,
}

alias NL_NEIGHBOR_STATE = int;
enum : int
{
    NlnsUnreachable = 0x00000000,
    NlnsIncomplete  = 0x00000001,
    NlnsProbe       = 0x00000002,
    NlnsDelay       = 0x00000003,
    NlnsStale       = 0x00000004,
    NlnsReachable   = 0x00000005,
    NlnsPermanent   = 0x00000006,
    NlnsMaximum     = 0x00000007,
}

alias NL_LINK_LOCAL_ADDRESS_BEHAVIOR = int;
enum : int
{
    LinkLocalAlwaysOff = 0x00000000,
    LinkLocalDelayed   = 0x00000001,
    LinkLocalAlwaysOn  = 0x00000002,
    LinkLocalUnchanged = 0xffffffff,
}

struct NL_INTERFACE_OFFLOAD_ROD
{
    ubyte _bitfield0;
}
alias NL_ROUTER_DISCOVERY_BEHAVIOR = int;
enum : int
{
    RouterDiscoveryDisabled  = 0x00000000,
    RouterDiscoveryEnabled   = 0x00000001,
    RouterDiscoveryDhcp      = 0x00000002,
    RouterDiscoveryUnchanged = 0xffffffff,
}

alias NL_BANDWIDTH_FLAG = int;
enum : int
{
    NlbwDisabled  = 0x00000000,
    NlbwEnabled   = 0x00000001,
    NlbwUnchanged = 0xffffffff,
}

struct NL_PATH_BANDWIDTH_ROD
{
    ulong Bandwidth;
    ulong Instability;
    BOOLEAN BandwidthPeaked;
}
alias NL_NETWORK_CATEGORY = int;
enum : int
{
    NetworkCategoryPublic              = 0x00000000,
    NetworkCategoryPrivate             = 0x00000001,
    NetworkCategoryDomainAuthenticated = 0x00000002,
    NetworkCategoryUnchanged           = 0xffffffff,
    NetworkCategoryUnknown             = 0xffffffff,
}

alias NL_INTERFACE_NETWORK_CATEGORY_STATE = int;
enum : int
{
    NlincCategoryUnknown     = 0x00000000,
    NlincPublic              = 0x00000001,
    NlincPrivate             = 0x00000002,
    NlincDomainAuthenticated = 0x00000003,
    NlincCategoryStateMax    = 0x00000004,
}

alias NL_NETWORK_CONNECTIVITY_LEVEL_HINT = int;
enum : int
{
    NetworkConnectivityLevelHintUnknown                   = 0x00000000,
    NetworkConnectivityLevelHintNone                      = 0x00000001,
    NetworkConnectivityLevelHintLocalAccess               = 0x00000002,
    NetworkConnectivityLevelHintInternetAccess            = 0x00000003,
    NetworkConnectivityLevelHintConstrainedInternetAccess = 0x00000004,
    NetworkConnectivityLevelHintHidden                    = 0x00000005,
}

alias NL_NETWORK_CONNECTIVITY_COST_HINT = int;
enum : int
{
    NetworkConnectivityCostHintUnknown      = 0x00000000,
    NetworkConnectivityCostHintUnrestricted = 0x00000001,
    NetworkConnectivityCostHintFixed        = 0x00000002,
    NetworkConnectivityCostHintVariable     = 0x00000003,
}

struct NL_NETWORK_CONNECTIVITY_HINT
{
    NL_NETWORK_CONNECTIVITY_LEVEL_HINT ConnectivityLevel;
    NL_NETWORK_CONNECTIVITY_COST_HINT ConnectivityCost;
    BOOLEAN ApproachingDataLimit;
    BOOLEAN OverDataLimit;
    BOOLEAN Roaming;
}
struct NL_BANDWIDTH_INFORMATION
{
    ulong Bandwidth;
    ulong Instability;
    BOOLEAN BandwidthPeaked;
}
alias TCPSTATE = int;
enum : int
{
    TCPSTATE_CLOSED      = 0x00000000,
    TCPSTATE_LISTEN      = 0x00000001,
    TCPSTATE_SYN_SENT    = 0x00000002,
    TCPSTATE_SYN_RCVD    = 0x00000003,
    TCPSTATE_ESTABLISHED = 0x00000004,
    TCPSTATE_FIN_WAIT_1  = 0x00000005,
    TCPSTATE_FIN_WAIT_2  = 0x00000006,
    TCPSTATE_CLOSE_WAIT  = 0x00000007,
    TCPSTATE_CLOSING     = 0x00000008,
    TCPSTATE_LAST_ACK    = 0x00000009,
    TCPSTATE_TIME_WAIT   = 0x0000000a,
    TCPSTATE_MAX         = 0x0000000b,
}

struct TRANSPORT_SETTING_ID
{
    GUID Guid;
}
struct tcp_keepalive
{
    uint onoff;
    uint keepalivetime;
    uint keepaliveinterval;
}
alias CONTROL_CHANNEL_TRIGGER_STATUS = int;
enum : int
{
    CONTROL_CHANNEL_TRIGGER_STATUS_INVALID                 = 0x00000000,
    CONTROL_CHANNEL_TRIGGER_STATUS_SOFTWARE_SLOT_ALLOCATED = 0x00000001,
    CONTROL_CHANNEL_TRIGGER_STATUS_HARDWARE_SLOT_ALLOCATED = 0x00000002,
    CONTROL_CHANNEL_TRIGGER_STATUS_POLICY_ERROR            = 0x00000003,
    CONTROL_CHANNEL_TRIGGER_STATUS_SYSTEM_ERROR            = 0x00000004,
    CONTROL_CHANNEL_TRIGGER_STATUS_TRANSPORT_DISCONNECTED  = 0x00000005,
    CONTROL_CHANNEL_TRIGGER_STATUS_SERVICE_UNAVAILABLE     = 0x00000006,
}

struct REAL_TIME_NOTIFICATION_SETTING_INPUT
{
    TRANSPORT_SETTING_ID TransportSettingId;
    GUID BrokerEventGuid;
}
struct REAL_TIME_NOTIFICATION_SETTING_INPUT_EX
{
    TRANSPORT_SETTING_ID TransportSettingId;
    GUID BrokerEventGuid;
    BOOLEAN Unmark;
}
struct REAL_TIME_NOTIFICATION_SETTING_OUTPUT
{
    CONTROL_CHANNEL_TRIGGER_STATUS ChannelStatus;
}
struct ASSOCIATE_NAMERES_CONTEXT_INPUT
{
    TRANSPORT_SETTING_ID TransportSettingId;
    ulong Handle;
}
struct TIMESTAMPING_CONFIG
{
    uint Flags;
    ushort TxTimestampsBuffered;
}
alias SOCKET_PRIORITY_HINT = int;
enum : int
{
    SocketPriorityHintVeryLow     = 0x00000000,
    SocketPriorityHintLow         = 0x00000001,
    SocketPriorityHintNormal      = 0x00000002,
    SocketMaximumPriorityHintType = 0x00000003,
}

struct PRIORITY_STATUS
{
    SOCKET_PRIORITY_HINT Sender;
    SOCKET_PRIORITY_HINT Receiver;
}
alias RCVALL_VALUE = int;
enum : int
{
    RCVALL_OFF             = 0x00000000,
    RCVALL_ON              = 0x00000001,
    RCVALL_SOCKETLEVELONLY = 0x00000002,
    RCVALL_IPLEVEL         = 0x00000003,
}

struct RCVALL_IF
{
    RCVALL_VALUE Mode;
    uint Interface;
}
struct TCP_INITIAL_RTO_PARAMETERS
{
    ushort Rtt;
    ubyte MaxSynRetransmissions;
}
alias TCP_ICW_LEVEL = int;
enum : int
{
    TCP_ICW_LEVEL_DEFAULT      = 0x00000000,
    TCP_ICW_LEVEL_HIGH         = 0x00000001,
    TCP_ICW_LEVEL_VERY_HIGH    = 0x00000002,
    TCP_ICW_LEVEL_AGGRESSIVE   = 0x00000003,
    TCP_ICW_LEVEL_EXPERIMENTAL = 0x00000004,
    TCP_ICW_LEVEL_COMPAT       = 0x000000fe,
    TCP_ICW_LEVEL_MAX          = 0x000000ff,
}

struct TCP_ICW_PARAMETERS
{
    TCP_ICW_LEVEL Level;
}
struct TCP_ACK_FREQUENCY_PARAMETERS
{
    ubyte TcpDelayedAckFrequency;
}
struct TCP_INFO_v0
{
    TCPSTATE State;
    uint Mss;
    ulong ConnectionTimeMs;
    BOOLEAN TimestampsEnabled;
    uint RttUs;
    uint MinRttUs;
    uint BytesInFlight;
    uint Cwnd;
    uint SndWnd;
    uint RcvWnd;
    uint RcvBuf;
    ulong BytesOut;
    ulong BytesIn;
    uint BytesReordered;
    uint BytesRetrans;
    uint FastRetrans;
    uint DupAcksIn;
    uint TimeoutEpisodes;
    ubyte SynRetrans;
}
struct TCP_INFO_v1
{
    TCPSTATE State;
    uint Mss;
    ulong ConnectionTimeMs;
    BOOLEAN TimestampsEnabled;
    uint RttUs;
    uint MinRttUs;
    uint BytesInFlight;
    uint Cwnd;
    uint SndWnd;
    uint RcvWnd;
    uint RcvBuf;
    ulong BytesOut;
    ulong BytesIn;
    uint BytesReordered;
    uint BytesRetrans;
    uint FastRetrans;
    uint DupAcksIn;
    uint TimeoutEpisodes;
    ubyte SynRetrans;
    uint SndLimTransRwin;
    uint SndLimTimeRwin;
    ulong SndLimBytesRwin;
    uint SndLimTransCwnd;
    uint SndLimTimeCwnd;
    ulong SndLimBytesCwnd;
    uint SndLimTransSnd;
    uint SndLimTimeSnd;
    ulong SndLimBytesSnd;
}
struct INET_PORT_RANGE
{
    ushort StartPort;
    ushort NumberOfPorts;
}
struct INET_PORT_RESERVATION_TOKEN
{
    ulong Token;
}
struct INET_PORT_RESERVATION_INSTANCE
{
    INET_PORT_RANGE Reservation;
    INET_PORT_RESERVATION_TOKEN Token;
}
struct INET_PORT_RESERVATION_INFORMATION
{
    uint OwningPid;
}
alias SOCKET_USAGE_TYPE = int;
enum : int
{
    SYSTEM_CRITICAL_SOCKET = 0x00000001,
}

alias SOCKET_SECURITY_PROTOCOL = int;
enum : int
{
    SOCKET_SECURITY_PROTOCOL_DEFAULT = 0x00000000,
    SOCKET_SECURITY_PROTOCOL_IPSEC   = 0x00000001,
    SOCKET_SECURITY_PROTOCOL_IPSEC2  = 0x00000002,
    SOCKET_SECURITY_PROTOCOL_INVALID = 0x00000003,
}

struct SOCKET_SECURITY_SETTINGS
{
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    uint SecurityFlags;
}
struct SOCKET_SECURITY_SETTINGS_IPSEC
{
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    uint SecurityFlags;
    uint IpsecFlags;
    GUID AuthipMMPolicyKey;
    GUID AuthipQMPolicyKey;
    GUID Reserved;
    ulong Reserved2;
    uint UserNameStringLen;
    uint DomainNameStringLen;
    uint PasswordStringLen;
    wchar[1] AllStrings;
}
struct SOCKET_PEER_TARGET_NAME
{
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    SOCKADDR_STORAGE PeerAddress;
    uint PeerTargetNameStringLen;
    wchar[1] AllStrings;
}
struct SOCKET_SECURITY_QUERY_TEMPLATE
{
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    SOCKADDR_STORAGE PeerAddress;
    uint PeerTokenAccessMask;
}
struct SOCKET_SECURITY_QUERY_TEMPLATE_IPSEC2
{
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    SOCKADDR_STORAGE PeerAddress;
    uint PeerTokenAccessMask;
    uint Flags;
    uint FieldMask;
}
struct SOCKET_SECURITY_QUERY_INFO
{
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    uint Flags;
    ulong PeerApplicationAccessTokenHandle;
    ulong PeerMachineAccessTokenHandle;
}
struct SOCKET_SECURITY_QUERY_INFO_IPSEC2
{
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    uint Flags;
    ulong PeerApplicationAccessTokenHandle;
    ulong PeerMachineAccessTokenHandle;
    ulong MmSaId;
    ulong QmSaId;
    uint NegotiationWinerr;
    GUID SaLookupContext;
}
struct RSS_SCALABILITY_INFO
{
    BOOLEAN RssEnabled;
}
alias WSA_COMPATIBILITY_BEHAVIOR_ID = int;
enum : int
{
    WsaBehaviorAll              = 0x00000000,
    WsaBehaviorReceiveBuffering = 0x00000001,
    WsaBehaviorAutoTuning       = 0x00000002,
}

struct WSA_COMPATIBILITY_MODE
{
    WSA_COMPATIBILITY_BEHAVIOR_ID BehaviorId;
    uint TargetOsVersion;
}
struct RIORESULT
{
    int Status;
    uint BytesTransferred;
    ulong SocketContext;
    ulong RequestContext;
}
struct RIO_BUF
{
    RIO_BUFFERID BufferId;
    uint Offset;
    uint Length;
}
struct RIO_CMSG_BUFFER
{
    uint TotalLength;
}
struct ATM_ADDRESS
{
    uint AddressType;
    uint NumofDigits;
    ubyte[20] Addr;
}
struct ATM_BLLI
{
    uint Layer2Protocol;
    uint Layer2UserSpecifiedProtocol;
    uint Layer3Protocol;
    uint Layer3UserSpecifiedProtocol;
    uint Layer3IPI;
    ubyte[5] SnapID;
}
struct ATM_BHLI
{
    uint HighLayerInfoType;
    uint HighLayerInfoLength;
    ubyte[8] HighLayerInfo;
}
struct SOCKADDR_ATM
{
    ushort satm_family;
    ATM_ADDRESS satm_number;
    ATM_BLLI satm_blli;
    ATM_BHLI satm_bhli;
}
alias Q2931_IE_TYPE = int;
enum : int
{
    IE_AALParameters             = 0x00000000,
    IE_TrafficDescriptor         = 0x00000001,
    IE_BroadbandBearerCapability = 0x00000002,
    IE_BHLI                      = 0x00000003,
    IE_BLLI                      = 0x00000004,
    IE_CalledPartyNumber         = 0x00000005,
    IE_CalledPartySubaddress     = 0x00000006,
    IE_CallingPartyNumber        = 0x00000007,
    IE_CallingPartySubaddress    = 0x00000008,
    IE_Cause                     = 0x00000009,
    IE_QOSClass                  = 0x0000000a,
    IE_TransitNetworkSelection   = 0x0000000b,
}

struct Q2931_IE
{
    Q2931_IE_TYPE IEType;
    uint IELength;
    ubyte[1] IE;
}
alias AAL_TYPE = int;
enum : int
{
    AALTYPE_5    = 0x00000005,
    AALTYPE_USER = 0x00000010,
}

struct AAL5_PARAMETERS
{
    uint ForwardMaxCPCSSDUSize;
    uint BackwardMaxCPCSSDUSize;
    ubyte Mode;
    ubyte SSCSType;
}
struct AALUSER_PARAMETERS
{
    uint UserDefined;
}
struct AAL_PARAMETERS_IE
{
    AAL_TYPE AALType;
    union _AALSpecificParameters_e__Union
    {
        AAL5_PARAMETERS AAL5Parameters;
        AALUSER_PARAMETERS AALUserParameters;
    }
}
struct ATM_TD
{
    uint PeakCellRate_CLP0;
    uint PeakCellRate_CLP01;
    uint SustainableCellRate_CLP0;
    uint SustainableCellRate_CLP01;
    uint MaxBurstSize_CLP0;
    uint MaxBurstSize_CLP01;
    BOOL Tagging;
}
struct ATM_TRAFFIC_DESCRIPTOR_IE
{
    ATM_TD Forward;
    ATM_TD Backward;
    BOOL BestEffort;
}
struct ATM_BROADBAND_BEARER_CAPABILITY_IE
{
    ubyte BearerClass;
    ubyte TrafficType;
    ubyte TimingRequirements;
    ubyte ClippingSusceptability;
    ubyte UserPlaneConnectionConfig;
}
struct ATM_BLLI_IE
{
    uint Layer2Protocol;
    ubyte Layer2Mode;
    ubyte Layer2WindowSize;
    uint Layer2UserSpecifiedProtocol;
    uint Layer3Protocol;
    ubyte Layer3Mode;
    ubyte Layer3DefaultPacketSize;
    ubyte Layer3PacketWindowSize;
    uint Layer3UserSpecifiedProtocol;
    uint Layer3IPI;
    ubyte[5] SnapID;
}
struct ATM_CALLING_PARTY_NUMBER_IE
{
    ATM_ADDRESS ATM_Number;
    ubyte Presentation_Indication;
    ubyte Screening_Indicator;
}
struct ATM_CAUSE_IE
{
    ubyte Location;
    ubyte Cause;
    ubyte DiagnosticsLength;
    ubyte[4] Diagnostics;
}
struct ATM_QOS_CLASS_IE
{
    ubyte QOSClassForward;
    ubyte QOSClassBackward;
}
struct ATM_TRANSIT_NETWORK_SELECTION_IE
{
    ubyte TypeOfNetworkId;
    ubyte NetworkIdPlan;
    ubyte NetworkIdLength;
    ubyte[1] NetworkId;
}
struct ATM_CONNECTION_ID
{
    uint DeviceNumber;
    uint VPI;
    uint VCI;
}
struct ATM_PVC_PARAMS
{
    align (4):
    ATM_CONNECTION_ID PvcConnectionId;
    QOS PvcQos;
}
alias NAPI_PROVIDER_TYPE = int;
enum : int
{
    ProviderType_Application = 0x00000001,
    ProviderType_Service     = 0x00000002,
}

alias NAPI_PROVIDER_LEVEL = int;
enum : int
{
    ProviderLevel_None      = 0x00000000,
    ProviderLevel_Secondary = 0x00000001,
    ProviderLevel_Primary   = 0x00000002,
}

struct NAPI_DOMAIN_DESCRIPTION_BLOB
{
    uint AuthLevel;
    uint cchDomainName;
    uint OffsetNextDomainDescription;
    uint OffsetThisDomainName;
}
struct NAPI_PROVIDER_INSTALLATION_BLOB
{
    uint dwVersion;
    uint dwProviderType;
    uint fSupportsWildCard;
    uint cDomains;
    uint OffsetFirstDomain;
}
struct TRANSMIT_FILE_BUFFERS
{
    void* Head;
    uint HeadLength;
    void* Tail;
    uint TailLength;
}
alias LPFN_TRANSMITFILE = BOOL function(SOCKET, HANDLE, uint, uint, OVERLAPPED*, TRANSMIT_FILE_BUFFERS*, uint);
alias LPFN_ACCEPTEX = BOOL function(SOCKET, SOCKET, void*, uint, uint, uint, uint*, OVERLAPPED*);
alias LPFN_GETACCEPTEXSOCKADDRS = void function(void*, uint, uint, uint, SOCKADDR**, int*, SOCKADDR**, int*);
struct TRANSMIT_PACKETS_ELEMENT
{
    uint dwElFlags;
    uint cLength;
    union
    {
        struct
        {
            long nFileOffset;
            HANDLE hFile;
        }
        void* pBuffer;
    }
}
alias LPFN_TRANSMITPACKETS = BOOL function(SOCKET, TRANSMIT_PACKETS_ELEMENT*, uint, uint, OVERLAPPED*, uint);
alias LPFN_CONNECTEX = BOOL function(SOCKET, const(SOCKADDR)*, int, void*, uint, uint*, OVERLAPPED*);
alias LPFN_DISCONNECTEX = BOOL function(SOCKET, OVERLAPPED*, uint, uint);
alias NLA_BLOB_DATA_TYPE = int;
enum : int
{
    NLA_RAW_DATA        = 0x00000000,
    NLA_INTERFACE       = 0x00000001,
    NLA_802_1X_LOCATION = 0x00000002,
    NLA_CONNECTIVITY    = 0x00000003,
    NLA_ICS             = 0x00000004,
}

alias NLA_CONNECTIVITY_TYPE = int;
enum : int
{
    NLA_NETWORK_AD_HOC    = 0x00000000,
    NLA_NETWORK_MANAGED   = 0x00000001,
    NLA_NETWORK_UNMANAGED = 0x00000002,
    NLA_NETWORK_UNKNOWN   = 0x00000003,
}

alias NLA_INTERNET = int;
enum : int
{
    NLA_INTERNET_UNKNOWN = 0x00000000,
    NLA_INTERNET_NO      = 0x00000001,
    NLA_INTERNET_YES     = 0x00000002,
}

struct NLA_BLOB
{
    struct _header_e__Struct
    {
        NLA_BLOB_DATA_TYPE type;
        uint dwSize;
        uint nextOffset;
    }
    union _data_e__Union
    {
        CHAR[1] rawData;
        struct _interfaceData_e__Struct
        {
            uint dwType;
            uint dwSpeed;
            CHAR[1] adapterName;
        }
        struct _locationData_e__Struct
        {
            CHAR[1] information;
        }
        struct _connectivity_e__Struct
        {
            NLA_CONNECTIVITY_TYPE type;
            NLA_INTERNET internet;
        }
        struct _ICS_e__Struct
        {
            struct _remote_e__Struct
            {
                uint speed;
                uint type;
                uint state;
                wchar[256] machineName;
                wchar[256] sharedAdapterName;
            }
        }
    }
}
alias LPFN_WSARECVMSG = int function(SOCKET, WSAMSG*, uint*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
struct WSAPOLLDATA
{
    int result;
    uint fds;
    int timeout;
    WSAPOLLFD[1] fdArray;
}
struct WSASENDMSG
{
    WSAMSG* lpMsg;
    uint dwFlags;
    uint* lpNumberOfBytesSent;
    OVERLAPPED* lpOverlapped;
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine;
}
alias LPFN_WSASENDMSG = int function(SOCKET, WSAMSG*, uint, uint*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
alias LPFN_WSAPOLL = int function(WSAPOLLFD*, uint, int);
alias LPFN_RIORECEIVE = BOOL function(RIO_RQ, RIO_BUF*, uint, uint, void*);
alias LPFN_RIORECEIVEEX = int function(RIO_RQ, RIO_BUF*, uint, RIO_BUF*, RIO_BUF*, RIO_BUF*, RIO_BUF*, uint, void*);
alias LPFN_RIOSEND = BOOL function(RIO_RQ, RIO_BUF*, uint, uint, void*);
alias LPFN_RIOSENDEX = BOOL function(RIO_RQ, RIO_BUF*, uint, RIO_BUF*, RIO_BUF*, RIO_BUF*, RIO_BUF*, uint, void*);
alias LPFN_RIOCLOSECOMPLETIONQUEUE = void function(RIO_CQ);
alias RIO_NOTIFICATION_COMPLETION_TYPE = int;
enum : int
{
    RIO_EVENT_COMPLETION = 0x00000001,
    RIO_IOCP_COMPLETION  = 0x00000002,
}

struct RIO_NOTIFICATION_COMPLETION
{
    RIO_NOTIFICATION_COMPLETION_TYPE Type;
    union
    {
        struct _Event_e__Struct
        {
            HANDLE EventHandle;
            BOOL NotifyReset;
        }
        struct _Iocp_e__Struct
        {
            HANDLE IocpHandle;
            void* CompletionKey;
            void* Overlapped;
        }
    }
}
alias LPFN_RIOCREATECOMPLETIONQUEUE = RIO_CQ function(uint, RIO_NOTIFICATION_COMPLETION*);
alias LPFN_RIOCREATEREQUESTQUEUE = RIO_RQ function(SOCKET, uint, uint, uint, uint, RIO_CQ, RIO_CQ, void*);
alias LPFN_RIODEQUEUECOMPLETION = uint function(RIO_CQ, RIORESULT*, uint);
alias LPFN_RIODEREGISTERBUFFER = void function(RIO_BUFFERID);
alias LPFN_RIONOTIFY = int function(RIO_CQ);
alias LPFN_RIOREGISTERBUFFER = RIO_BUFFERID function(PSTR, uint);
alias LPFN_RIORESIZECOMPLETIONQUEUE = BOOL function(RIO_CQ, uint);
alias LPFN_RIORESIZEREQUESTQUEUE = BOOL function(RIO_RQ, uint, uint);
struct RIO_EXTENSION_FUNCTION_TABLE
{
    uint cbSize;
    LPFN_RIORECEIVE RIOReceive;
    LPFN_RIORECEIVEEX RIOReceiveEx;
    LPFN_RIOSEND RIOSend;
    LPFN_RIOSENDEX RIOSendEx;
    LPFN_RIOCLOSECOMPLETIONQUEUE RIOCloseCompletionQueue;
    LPFN_RIOCREATECOMPLETIONQUEUE RIOCreateCompletionQueue;
    LPFN_RIOCREATEREQUESTQUEUE RIOCreateRequestQueue;
    LPFN_RIODEQUEUECOMPLETION RIODequeueCompletion;
    LPFN_RIODEREGISTERBUFFER RIODeregisterBuffer;
    LPFN_RIONOTIFY RIONotify;
    LPFN_RIOREGISTERBUFFER RIORegisterBuffer;
    LPFN_RIORESIZECOMPLETIONQUEUE RIOResizeCompletionQueue;
    LPFN_RIORESIZEREQUESTQUEUE RIOResizeRequestQueue;
}
struct WSPDATA
{
    ushort wVersion;
    ushort wHighVersion;
    wchar[256] szDescription;
}
struct WSATHREADID
{
    HANDLE ThreadHandle;
    ulong Reserved;
}
alias LPBLOCKINGCALLBACK = BOOL function(ulong);
alias LPWSAUSERAPC = void function(ulong);
alias LPWSPACCEPT = SOCKET function(SOCKET, SOCKADDR*, int*, LPCONDITIONPROC, ulong, int*);
alias LPWSPADDRESSTOSTRING = int function(SOCKADDR*, uint, WSAPROTOCOL_INFOW*, PWSTR, uint*, int*);
alias LPWSPASYNCSELECT = int function(SOCKET, HWND, uint, int, int*);
alias LPWSPBIND = int function(SOCKET, const(SOCKADDR)*, int, int*);
alias LPWSPCANCELBLOCKINGCALL = int function(int*);
alias LPWSPCLEANUP = int function(int*);
alias LPWSPCLOSESOCKET = int function(SOCKET, int*);
alias LPWSPCONNECT = int function(SOCKET, const(SOCKADDR)*, int, WSABUF*, WSABUF*, QOS*, QOS*, int*);
alias LPWSPDUPLICATESOCKET = int function(SOCKET, uint, WSAPROTOCOL_INFOW*, int*);
alias LPWSPENUMNETWORKEVENTS = int function(SOCKET, HANDLE, WSANETWORKEVENTS*, int*);
alias LPWSPEVENTSELECT = int function(SOCKET, HANDLE, int, int*);
alias LPWSPGETOVERLAPPEDRESULT = BOOL function(SOCKET, OVERLAPPED*, uint*, BOOL, uint*, int*);
alias LPWSPGETPEERNAME = int function(SOCKET, SOCKADDR*, int*, int*);
alias LPWSPGETSOCKNAME = int function(SOCKET, SOCKADDR*, int*, int*);
alias LPWSPGETSOCKOPT = int function(SOCKET, int, int, PSTR, int*, int*);
alias LPWSPGETQOSBYNAME = BOOL function(SOCKET, WSABUF*, QOS*, int*);
alias LPWSPIOCTL = int function(SOCKET, uint, void*, uint, void*, uint, uint*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE, WSATHREADID*, int*);
alias LPWSPJOINLEAF = SOCKET function(SOCKET, const(SOCKADDR)*, int, WSABUF*, WSABUF*, QOS*, QOS*, uint, int*);
alias LPWSPLISTEN = int function(SOCKET, int, int*);
alias LPWSPRECV = int function(SOCKET, WSABUF*, uint, uint*, uint*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE, WSATHREADID*, int*);
alias LPWSPRECVDISCONNECT = int function(SOCKET, WSABUF*, int*);
alias LPWSPRECVFROM = int function(SOCKET, WSABUF*, uint, uint*, uint*, SOCKADDR*, int*, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE, WSATHREADID*, int*);
alias LPWSPSELECT = int function(int, FD_SET*, FD_SET*, FD_SET*, const(TIMEVAL)*, int*);
alias LPWSPSEND = int function(SOCKET, WSABUF*, uint, uint*, uint, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE, WSATHREADID*, int*);
alias LPWSPSENDDISCONNECT = int function(SOCKET, WSABUF*, int*);
alias LPWSPSENDTO = int function(SOCKET, WSABUF*, uint, uint*, uint, const(SOCKADDR)*, int, OVERLAPPED*, LPWSAOVERLAPPED_COMPLETION_ROUTINE, WSATHREADID*, int*);
alias LPWSPSETSOCKOPT = int function(SOCKET, int, int, const(char)*, int, int*);
alias LPWSPSHUTDOWN = int function(SOCKET, int, int*);
alias LPWSPSOCKET = SOCKET function(int, int, int, WSAPROTOCOL_INFOW*, uint, uint, int*);
alias LPWSPSTRINGTOADDRESS = int function(PWSTR, int, WSAPROTOCOL_INFOW*, SOCKADDR*, int*, int*);
struct WSPPROC_TABLE
{
    LPWSPACCEPT lpWSPAccept;
    LPWSPADDRESSTOSTRING lpWSPAddressToString;
    LPWSPASYNCSELECT lpWSPAsyncSelect;
    LPWSPBIND lpWSPBind;
    LPWSPCANCELBLOCKINGCALL lpWSPCancelBlockingCall;
    LPWSPCLEANUP lpWSPCleanup;
    LPWSPCLOSESOCKET lpWSPCloseSocket;
    LPWSPCONNECT lpWSPConnect;
    LPWSPDUPLICATESOCKET lpWSPDuplicateSocket;
    LPWSPENUMNETWORKEVENTS lpWSPEnumNetworkEvents;
    LPWSPEVENTSELECT lpWSPEventSelect;
    LPWSPGETOVERLAPPEDRESULT lpWSPGetOverlappedResult;
    LPWSPGETPEERNAME lpWSPGetPeerName;
    LPWSPGETSOCKNAME lpWSPGetSockName;
    LPWSPGETSOCKOPT lpWSPGetSockOpt;
    LPWSPGETQOSBYNAME lpWSPGetQOSByName;
    LPWSPIOCTL lpWSPIoctl;
    LPWSPJOINLEAF lpWSPJoinLeaf;
    LPWSPLISTEN lpWSPListen;
    LPWSPRECV lpWSPRecv;
    LPWSPRECVDISCONNECT lpWSPRecvDisconnect;
    LPWSPRECVFROM lpWSPRecvFrom;
    LPWSPSELECT lpWSPSelect;
    LPWSPSEND lpWSPSend;
    LPWSPSENDDISCONNECT lpWSPSendDisconnect;
    LPWSPSENDTO lpWSPSendTo;
    LPWSPSETSOCKOPT lpWSPSetSockOpt;
    LPWSPSHUTDOWN lpWSPShutdown;
    LPWSPSOCKET lpWSPSocket;
    LPWSPSTRINGTOADDRESS lpWSPStringToAddress;
}
alias LPWPUCLOSEEVENT = BOOL function(HANDLE, int*);
alias LPWPUCLOSESOCKETHANDLE = int function(SOCKET, int*);
alias LPWPUCREATEEVENT = HANDLE function(int*);
alias LPWPUCREATESOCKETHANDLE = SOCKET function(uint, ulong, int*);
alias LPWPUFDISSET = int function(SOCKET, FD_SET*);
alias LPWPUGETPROVIDERPATH = int function(GUID*, PWSTR, int*, int*);
alias LPWPUMODIFYIFSHANDLE = SOCKET function(uint, SOCKET, int*);
alias LPWPUPOSTMESSAGE = BOOL function(HWND, uint, WPARAM, LPARAM);
alias LPWPUQUERYBLOCKINGCALLBACK = int function(uint, LPBLOCKINGCALLBACK*, ulong*, int*);
alias LPWPUQUERYSOCKETHANDLECONTEXT = int function(SOCKET, ulong*, int*);
alias LPWPUQUEUEAPC = int function(WSATHREADID*, LPWSAUSERAPC, ulong, int*);
alias LPWPURESETEVENT = BOOL function(HANDLE, int*);
alias LPWPUSETEVENT = BOOL function(HANDLE, int*);
alias LPWPUOPENCURRENTTHREAD = int function(WSATHREADID*, int*);
alias LPWPUCLOSETHREAD = int function(WSATHREADID*, int*);
alias LPWPUCOMPLETEOVERLAPPEDREQUEST = int function(SOCKET, OVERLAPPED*, uint, uint, int*);
struct WSPUPCALLTABLE
{
    LPWPUCLOSEEVENT lpWPUCloseEvent;
    LPWPUCLOSESOCKETHANDLE lpWPUCloseSocketHandle;
    LPWPUCREATEEVENT lpWPUCreateEvent;
    LPWPUCREATESOCKETHANDLE lpWPUCreateSocketHandle;
    LPWPUFDISSET lpWPUFDIsSet;
    LPWPUGETPROVIDERPATH lpWPUGetProviderPath;
    LPWPUMODIFYIFSHANDLE lpWPUModifyIFSHandle;
    LPWPUPOSTMESSAGE lpWPUPostMessage;
    LPWPUQUERYBLOCKINGCALLBACK lpWPUQueryBlockingCallback;
    LPWPUQUERYSOCKETHANDLECONTEXT lpWPUQuerySocketHandleContext;
    LPWPUQUEUEAPC lpWPUQueueApc;
    LPWPURESETEVENT lpWPUResetEvent;
    LPWPUSETEVENT lpWPUSetEvent;
    LPWPUOPENCURRENTTHREAD lpWPUOpenCurrentThread;
    LPWPUCLOSETHREAD lpWPUCloseThread;
}
alias LPWSPSTARTUP = int function(ushort, WSPDATA*, WSAPROTOCOL_INFOW*, WSPUPCALLTABLE, WSPPROC_TABLE*);
alias LPWSCENUMPROTOCOLS = int function(int*, WSAPROTOCOL_INFOW*, uint*, int*);
alias LPWSCDEINSTALLPROVIDER = int function(GUID*, int*);
alias LPWSCINSTALLPROVIDER = int function(GUID*, const(wchar)*, const(WSAPROTOCOL_INFOW)*, uint, int*);
alias LPWSCGETPROVIDERPATH = int function(GUID*, PWSTR, int*, int*);
alias LPWSCUPDATEPROVIDER = int function(GUID*, const(wchar)*, const(WSAPROTOCOL_INFOW)*, uint, int*);
alias WSC_PROVIDER_INFO_TYPE = int;
enum : int
{
    ProviderInfoLspCategories = 0x00000000,
    ProviderInfoAudit         = 0x00000001,
}

struct WSC_PROVIDER_AUDIT_INFO
{
    uint RecordSize;
    void* Reserved;
}
alias LPWSCINSTALLNAMESPACE = int function(PWSTR, PWSTR, uint, uint, GUID*);
alias LPWSCUNINSTALLNAMESPACE = int function(GUID*);
alias LPWSCENABLENSPROVIDER = int function(GUID*, BOOL);
alias LPNSPCLEANUP = int function(GUID*);
alias LPNSPLOOKUPSERVICEBEGIN = int function(GUID*, WSAQUERYSETW*, WSASERVICECLASSINFOW*, uint, HANDLE*);
alias LPNSPLOOKUPSERVICENEXT = int function(HANDLE, uint, uint*, WSAQUERYSETW*);
alias LPNSPIOCTL = int function(HANDLE, uint, void*, uint, void*, uint, uint*, WSACOMPLETION*, WSATHREADID*);
alias LPNSPLOOKUPSERVICEEND = int function(HANDLE);
alias LPNSPSETSERVICE = int function(GUID*, WSASERVICECLASSINFOW*, WSAQUERYSETW*, WSAESETSERVICEOP, uint);
alias LPNSPINSTALLSERVICECLASS = int function(GUID*, WSASERVICECLASSINFOW*);
alias LPNSPREMOVESERVICECLASS = int function(GUID*, GUID*);
alias LPNSPGETSERVICECLASSINFO = int function(GUID*, uint*, WSASERVICECLASSINFOW*);
struct NSP_ROUTINE
{
    uint cbSize;
    uint dwMajorVersion;
    uint dwMinorVersion;
    LPNSPCLEANUP NSPCleanup;
    LPNSPLOOKUPSERVICEBEGIN NSPLookupServiceBegin;
    LPNSPLOOKUPSERVICENEXT NSPLookupServiceNext;
    LPNSPLOOKUPSERVICEEND NSPLookupServiceEnd;
    LPNSPSETSERVICE NSPSetService;
    LPNSPINSTALLSERVICECLASS NSPInstallServiceClass;
    LPNSPREMOVESERVICECLASS NSPRemoveServiceClass;
    LPNSPGETSERVICECLASSINFO NSPGetServiceClassInfo;
    LPNSPIOCTL NSPIoctl;
}
alias LPNSPSTARTUP = int function(GUID*, NSP_ROUTINE*);
alias LPNSPV2STARTUP = int function(GUID*, void**);
alias LPNSPV2CLEANUP = int function(GUID*, void*);
alias LPNSPV2LOOKUPSERVICEBEGIN = int function(GUID*, WSAQUERYSET2W*, uint, void*, HANDLE*);
alias LPNSPV2LOOKUPSERVICENEXTEX = void function(HANDLE, HANDLE, uint, uint*, WSAQUERYSET2W*);
alias LPNSPV2LOOKUPSERVICEEND = int function(HANDLE);
alias LPNSPV2SETSERVICEEX = void function(HANDLE, GUID*, WSAQUERYSET2W*, WSAESETSERVICEOP, uint, void*);
alias LPNSPV2CLIENTSESSIONRUNDOWN = void function(GUID*, void*);
struct NSPV2_ROUTINE
{
    uint cbSize;
    uint dwMajorVersion;
    uint dwMinorVersion;
    LPNSPV2STARTUP NSPv2Startup;
    LPNSPV2CLEANUP NSPv2Cleanup;
    LPNSPV2LOOKUPSERVICEBEGIN NSPv2LookupServiceBegin;
    LPNSPV2LOOKUPSERVICENEXTEX NSPv2LookupServiceNextEx;
    LPNSPV2LOOKUPSERVICEEND NSPv2LookupServiceEnd;
    LPNSPV2SETSERVICEEX NSPv2SetServiceEx;
    LPNSPV2CLIENTSESSIONRUNDOWN NSPv2ClientSessionRundown;
}
struct NS_INFOA
{
    uint dwNameSpace;
    uint dwNameSpaceFlags;
    PSTR lpNameSpace;
}
struct NS_INFOW
{
    uint dwNameSpace;
    uint dwNameSpaceFlags;
    PWSTR lpNameSpace;
}
struct SERVICE_TYPE_VALUE
{
    uint dwNameSpace;
    uint dwValueType;
    uint dwValueSize;
    uint dwValueNameOffset;
    uint dwValueOffset;
}
struct SERVICE_TYPE_VALUE_ABSA
{
    uint dwNameSpace;
    uint dwValueType;
    uint dwValueSize;
    PSTR lpValueName;
    void* lpValue;
}
struct SERVICE_TYPE_VALUE_ABSW
{
    uint dwNameSpace;
    uint dwValueType;
    uint dwValueSize;
    PWSTR lpValueName;
    void* lpValue;
}
struct SERVICE_TYPE_INFO
{
    uint dwTypeNameOffset;
    uint dwValueCount;
    SERVICE_TYPE_VALUE[1] Values;
}
struct SERVICE_TYPE_INFO_ABSA
{
    PSTR lpTypeName;
    uint dwValueCount;
    SERVICE_TYPE_VALUE_ABSA[1] Values;
}
struct SERVICE_TYPE_INFO_ABSW
{
    PWSTR lpTypeName;
    uint dwValueCount;
    SERVICE_TYPE_VALUE_ABSW[1] Values;
}
struct SERVICE_ADDRESS
{
    uint dwAddressType;
    uint dwAddressFlags;
    uint dwAddressLength;
    uint dwPrincipalLength;
    ubyte* lpAddress;
    ubyte* lpPrincipal;
}
struct SERVICE_ADDRESSES
{
    uint dwAddressCount;
    SERVICE_ADDRESS[1] Addresses;
}
struct SERVICE_INFOA
{
    GUID* lpServiceType;
    PSTR lpServiceName;
    PSTR lpComment;
    PSTR lpLocale;
    RESOURCE_DISPLAY_TYPE dwDisplayHint;
    uint dwVersion;
    uint dwTime;
    PSTR lpMachineName;
    SERVICE_ADDRESSES* lpServiceAddress;
    BLOB ServiceSpecificInfo;
}
struct SERVICE_INFOW
{
    GUID* lpServiceType;
    PWSTR lpServiceName;
    PWSTR lpComment;
    PWSTR lpLocale;
    RESOURCE_DISPLAY_TYPE dwDisplayHint;
    uint dwVersion;
    uint dwTime;
    PWSTR lpMachineName;
    SERVICE_ADDRESSES* lpServiceAddress;
    BLOB ServiceSpecificInfo;
}
struct NS_SERVICE_INFOA
{
    uint dwNameSpace;
    SERVICE_INFOA ServiceInfo;
}
struct NS_SERVICE_INFOW
{
    uint dwNameSpace;
    SERVICE_INFOW ServiceInfo;
}
struct PROTOCOL_INFOA
{
    uint dwServiceFlags;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    uint dwMessageSize;
    PSTR lpProtocol;
}
struct PROTOCOL_INFOW
{
    uint dwServiceFlags;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    uint dwMessageSize;
    PWSTR lpProtocol;
}
struct NETRESOURCE2A
{
    uint dwScope;
    uint dwType;
    uint dwUsage;
    uint dwDisplayType;
    PSTR lpLocalName;
    PSTR lpRemoteName;
    PSTR lpComment;
    NS_INFOA ns_info;
    GUID ServiceType;
    uint dwProtocols;
    int* lpiProtocols;
}
struct NETRESOURCE2W
{
    uint dwScope;
    uint dwType;
    uint dwUsage;
    uint dwDisplayType;
    PWSTR lpLocalName;
    PWSTR lpRemoteName;
    PWSTR lpComment;
    NS_INFOA ns_info;
    GUID ServiceType;
    uint dwProtocols;
    int* lpiProtocols;
}
alias LPFN_NSPAPI = uint function();
alias LPSERVICE_CALLBACK_PROC = void function(LPARAM, HANDLE);
struct SERVICE_ASYNC_INFO
{
    LPSERVICE_CALLBACK_PROC lpServiceCallbackProc;
    LPARAM lParam;
    HANDLE hAsyncTaskHandle;
}
alias LPLOOKUPSERVICE_COMPLETION_ROUTINE = void function(uint, uint, OVERLAPPED*);
alias LPWSCWRITEPROVIDERORDER = int function(uint*, uint);
alias LPWSCWRITENAMESPACEORDER = int function(GUID*, uint);
struct SOCKADDR_UN
{
    ADDRESS_FAMILY sun_family;
    CHAR[108] sun_path;
}
struct SOCKADDR_IPX
{
    short sa_family;
    CHAR[4] sa_netnum;
    CHAR[6] sa_nodenum;
    ushort sa_socket;
}
struct SOCKADDR_TP
{
    ushort tp_family;
    ushort tp_addr_type;
    ushort tp_taddr_len;
    ushort tp_tsel_len;
    ubyte[64] tp_addr;
}
struct SOCKADDR_NB
{
    short snb_family;
    ushort snb_type;
    CHAR[16] snb_name;
}
struct SOCKADDR_VNS
{
    ushort sin_family;
    ubyte[4] net_address;
    ubyte[2] subnet_addr;
    ubyte[2] port;
    ubyte hops;
    ubyte[5] filler;
}
union DL_OUI
{
    ubyte[3] Byte;
    struct
    {
        ubyte _bitfield0;
    }
}
union DL_EI48
{
    ubyte[3] Byte;
}
union DL_EUI48
{
    ubyte[6] Byte;
    struct
    {
        DL_OUI Oui;
        DL_EI48 Ei48;
    }
}
union DL_EI64
{
    ubyte[5] Byte;
}
union DL_EUI64
{
    ubyte[8] Byte;
    ulong Value;
    struct
    {
        DL_OUI Oui;
        union
        {
            DL_EI64 Ei64;
            struct
            {
                ubyte Type;
                ubyte Tse;
                DL_EI48 Ei48;
            }
        }
    }
}
struct SNAP_HEADER
{
    ubyte Dsap;
    ubyte Ssap;
    ubyte Control;
    ubyte[3] Oui;
    ushort Type;
}
struct ETHERNET_HEADER
{
    DL_EUI48 Destination;
    DL_EUI48 Source;
    union
    {
        ushort Type;
        ushort Length;
    }
}
struct VLAN_TAG
{
    union
    {
        ushort Tag;
        struct
        {
            ushort _bitfield0;
        }
    }
    ushort Type;
}
struct ICMP_HEADER
{
    ubyte Type;
    ubyte Code;
    ushort Checksum;
}
struct ICMP_MESSAGE
{
    ICMP_HEADER Header;
    union _Data_e__Union
    {
        uint[1] Data32;
        ushort[2] Data16;
        ubyte[4] Data8;
    }
}
struct IPV4_HEADER
{
    union
    {
        ubyte VersionAndHeaderLength;
        struct
        {
            ubyte _bitfield0;
        }
    }
    union
    {
        ubyte TypeOfServiceAndEcnField;
        struct
        {
            ubyte _bitfield1;
        }
    }
    ushort TotalLength;
    ushort Identification;
    union
    {
        ushort FlagsAndOffset;
        struct
        {
            ushort _bitfield2;
        }
    }
    ubyte TimeToLive;
    ubyte Protocol;
    ushort HeaderChecksum;
    IN_ADDR SourceAddress;
    IN_ADDR DestinationAddress;
}
struct IPV4_OPTION_HEADER
{
    union
    {
        ubyte OptionType;
        struct
        {
            ubyte _bitfield0;
        }
    }
    ubyte OptionLength;
}
alias IPV4_OPTION_TYPE = int;
enum : int
{
    IP_OPT_EOL          = 0x00000000,
    IP_OPT_NOP          = 0x00000001,
    IP_OPT_SECURITY     = 0x00000082,
    IP_OPT_LSRR         = 0x00000083,
    IP_OPT_TS           = 0x00000044,
    IP_OPT_RR           = 0x00000007,
    IP_OPT_SSRR         = 0x00000089,
    IP_OPT_SID          = 0x00000088,
    IP_OPT_ROUTER_ALERT = 0x00000094,
    IP_OPT_MULTIDEST    = 0x00000095,
}

struct IPV4_TIMESTAMP_OPTION
{
    IPV4_OPTION_HEADER OptionHeader;
    ubyte Pointer;
    union
    {
        ubyte FlagsOverflow;
        struct
        {
            ubyte _bitfield0;
        }
    }
}
alias IP_OPTION_TIMESTAMP_FLAGS = int;
enum : int
{
    IP_OPTION_TIMESTAMP_ONLY             = 0x00000000,
    IP_OPTION_TIMESTAMP_ADDRESS          = 0x00000001,
    IP_OPTION_TIMESTAMP_SPECIFIC_ADDRESS = 0x00000003,
}

struct IPV4_ROUTING_HEADER
{
    IPV4_OPTION_HEADER OptionHeader;
    ubyte Pointer;
}
alias ICMP4_UNREACH_CODE = int;
enum : int
{
    ICMP4_UNREACH_NET                = 0x00000000,
    ICMP4_UNREACH_HOST               = 0x00000001,
    ICMP4_UNREACH_PROTOCOL           = 0x00000002,
    ICMP4_UNREACH_PORT               = 0x00000003,
    ICMP4_UNREACH_FRAG_NEEDED        = 0x00000004,
    ICMP4_UNREACH_SOURCEROUTE_FAILED = 0x00000005,
    ICMP4_UNREACH_NET_UNKNOWN        = 0x00000006,
    ICMP4_UNREACH_HOST_UNKNOWN       = 0x00000007,
    ICMP4_UNREACH_ISOLATED           = 0x00000008,
    ICMP4_UNREACH_NET_ADMIN          = 0x00000009,
    ICMP4_UNREACH_HOST_ADMIN         = 0x0000000a,
    ICMP4_UNREACH_NET_TOS            = 0x0000000b,
    ICMP4_UNREACH_HOST_TOS           = 0x0000000c,
    ICMP4_UNREACH_ADMIN              = 0x0000000d,
}

alias ICMP4_TIME_EXCEED_CODE = int;
enum : int
{
    ICMP4_TIME_EXCEED_TRANSIT    = 0x00000000,
    ICMP4_TIME_EXCEED_REASSEMBLY = 0x00000001,
}

struct ICMPV4_ROUTER_SOLICIT
{
    ICMP_MESSAGE RsHeader;
}
struct ICMPV4_ROUTER_ADVERT_HEADER
{
    ICMP_MESSAGE RaHeader;
}
struct ICMPV4_ROUTER_ADVERT_ENTRY
{
    IN_ADDR RouterAdvertAddr;
    int PreferenceLevel;
}
struct ICMPV4_TIMESTAMP_MESSAGE
{
    ICMP_MESSAGE Header;
    uint OriginateTimestamp;
    uint ReceiveTimestamp;
    uint TransmitTimestamp;
}
struct ICMPV4_ADDRESS_MASK_MESSAGE
{
    ICMP_MESSAGE Header;
    uint AddressMask;
}
struct ARP_HEADER
{
    ushort HardwareAddressSpace;
    ushort ProtocolAddressSpace;
    ubyte HardwareAddressLength;
    ubyte ProtocolAddressLength;
    ushort Opcode;
    ubyte[1] SenderHardwareAddress;
}
alias ARP_OPCODE = int;
enum : int
{
    ARP_REQUEST  = 0x00000001,
    ARP_RESPONSE = 0x00000002,
}

alias ARP_HARDWARE_TYPE = int;
enum : int
{
    ARP_HW_ENET = 0x00000001,
    ARP_HW_802  = 0x00000006,
}

struct IGMP_HEADER
{
    union
    {
        struct
        {
            ubyte _bitfield0;
        }
        ubyte VersionType;
    }
    union
    {
        ubyte Reserved;
        ubyte MaxRespTime;
        ubyte Code;
    }
    ushort Checksum;
    IN_ADDR MulticastAddress;
}
alias IGMP_MAX_RESP_CODE_TYPE = int;
enum : int
{
    IGMP_MAX_RESP_CODE_TYPE_NORMAL = 0x00000000,
    IGMP_MAX_RESP_CODE_TYPE_FLOAT  = 0x00000001,
}

struct IGMPV3_QUERY_HEADER
{
    ubyte Type;
    union
    {
        ubyte MaxRespCode;
        struct
        {
            ubyte _bitfield0;
        }
    }
    ushort Checksum;
    IN_ADDR MulticastAddress;
    ubyte _bitfield1;
    union
    {
        ubyte QueriersQueryInterfaceCode;
        struct
        {
            ubyte _bitfield2;
        }
    }
    ushort SourceCount;
}
struct IGMPV3_REPORT_RECORD_HEADER
{
    ubyte Type;
    ubyte AuxillaryDataLength;
    ushort SourceCount;
    IN_ADDR MulticastAddress;
}
struct IGMPV3_REPORT_HEADER
{
    ubyte Type;
    ubyte Reserved;
    ushort Checksum;
    ushort Reserved2;
    ushort RecordCount;
}
struct IPV6_HEADER
{
    union
    {
        uint VersionClassFlow;
        struct
        {
            uint _bitfield0;
        }
    }
    ushort PayloadLength;
    ubyte NextHeader;
    ubyte HopLimit;
    IN6_ADDR SourceAddress;
    IN6_ADDR DestinationAddress;
}
struct IPV6_FRAGMENT_HEADER
{
    ubyte NextHeader;
    ubyte Reserved;
    union
    {
        struct
        {
            ushort _bitfield0;
        }
        ushort OffsetAndFlags;
    }
    uint Id;
}
struct IPV6_EXTENSION_HEADER
{
    ubyte NextHeader;
    ubyte Length;
}
struct IPV6_OPTION_HEADER
{
    ubyte Type;
    ubyte DataLength;
}
alias IPV6_OPTION_TYPE = int;
enum : int
{
    IP6OPT_PAD1         = 0x00000000,
    IP6OPT_PADN         = 0x00000001,
    IP6OPT_TUNNEL_LIMIT = 0x00000004,
    IP6OPT_ROUTER_ALERT = 0x00000005,
    IP6OPT_JUMBO        = 0x000000c2,
    IP6OPT_NSAP_ADDR    = 0x000000c3,
}

struct IPV6_OPTION_JUMBOGRAM
{
    IPV6_OPTION_HEADER Header;
    ubyte[4] JumbogramLength;
}
struct IPV6_OPTION_ROUTER_ALERT
{
    IPV6_OPTION_HEADER Header;
    ubyte[2] Value;
}
struct IPV6_ROUTING_HEADER
{
    ubyte NextHeader;
    ubyte Length;
    ubyte RoutingType;
    ubyte SegmentsLeft;
    ubyte[4] Reserved;
}
struct ND_ROUTER_SOLICIT_HEADER
{
    ICMP_MESSAGE nd_rs_hdr;
}
struct ND_ROUTER_ADVERT_HEADER
{
    ICMP_MESSAGE nd_ra_hdr;
    uint nd_ra_reachable;
    uint nd_ra_retransmit;
}
union IPV6_ROUTER_ADVERTISEMENT_FLAGS
{
    struct
    {
        ubyte _bitfield0;
    }
    ubyte Value;
}
struct ND_NEIGHBOR_SOLICIT_HEADER
{
    ICMP_MESSAGE nd_ns_hdr;
    IN6_ADDR nd_ns_target;
}
struct ND_NEIGHBOR_ADVERT_HEADER
{
    ICMP_MESSAGE nd_na_hdr;
    IN6_ADDR nd_na_target;
}
union IPV6_NEIGHBOR_ADVERTISEMENT_FLAGS
{
    struct
    {
        ubyte _bitfield0;
        ubyte[3] Reserved2;
    }
    uint Value;
}
struct ND_REDIRECT_HEADER
{
    ICMP_MESSAGE nd_rd_hdr;
    IN6_ADDR nd_rd_target;
    IN6_ADDR nd_rd_dst;
}
struct ND_OPTION_HDR
{
    ubyte nd_opt_type;
    ubyte nd_opt_len;
}
alias ND_OPTION_TYPE = int;
enum : int
{
    ND_OPT_SOURCE_LINKADDR        = 0x00000001,
    ND_OPT_TARGET_LINKADDR        = 0x00000002,
    ND_OPT_PREFIX_INFORMATION     = 0x00000003,
    ND_OPT_REDIRECTED_HEADER      = 0x00000004,
    ND_OPT_MTU                    = 0x00000005,
    ND_OPT_NBMA_SHORTCUT_LIMIT    = 0x00000006,
    ND_OPT_ADVERTISEMENT_INTERVAL = 0x00000007,
    ND_OPT_HOME_AGENT_INFORMATION = 0x00000008,
    ND_OPT_SOURCE_ADDR_LIST       = 0x00000009,
    ND_OPT_TARGET_ADDR_LIST       = 0x0000000a,
    ND_OPT_ROUTE_INFO             = 0x00000018,
    ND_OPT_RDNSS                  = 0x00000019,
    ND_OPT_DNSSL                  = 0x0000001f,
}

struct ND_OPTION_PREFIX_INFO
{
    ubyte nd_opt_pi_type;
    ubyte nd_opt_pi_len;
    ubyte nd_opt_pi_prefix_len;
    union
    {
        ubyte nd_opt_pi_flags_reserved;
        struct _Flags_e__Struct
        {
            ubyte _bitfield0;
        }
    }
    uint nd_opt_pi_valid_time;
    uint nd_opt_pi_preferred_time;
    union
    {
        uint nd_opt_pi_reserved2;
        struct
        {
            ubyte[3] nd_opt_pi_reserved3;
            ubyte nd_opt_pi_site_prefix_len;
        }
    }
    IN6_ADDR nd_opt_pi_prefix;
}
struct ND_OPTION_RD_HDR
{
    ubyte nd_opt_rh_type;
    ubyte nd_opt_rh_len;
    ushort nd_opt_rh_reserved1;
    uint nd_opt_rh_reserved2;
}
struct ND_OPTION_MTU
{
    ubyte nd_opt_mtu_type;
    ubyte nd_opt_mtu_len;
    ushort nd_opt_mtu_reserved;
    uint nd_opt_mtu_mtu;
}
struct ND_OPTION_ROUTE_INFO
{
    ubyte nd_opt_ri_type;
    ubyte nd_opt_ri_len;
    ubyte nd_opt_ri_prefix_len;
    union
    {
        ubyte nd_opt_ri_flags_reserved;
        struct _Flags_e__Struct
        {
            ubyte _bitfield0;
        }
    }
    uint nd_opt_ri_route_lifetime;
    IN6_ADDR nd_opt_ri_prefix;
}
struct ND_OPTION_RDNSS
{
    ubyte nd_opt_rdnss_type;
    ubyte nd_opt_rdnss_len;
    ushort nd_opt_rdnss_reserved;
    uint nd_opt_rdnss_lifetime;
}
struct ND_OPTION_DNSSL
{
    ubyte nd_opt_dnssl_type;
    ubyte nd_opt_dnssl_len;
    ushort nd_opt_dnssl_reserved;
    uint nd_opt_dnssl_lifetime;
}
struct MLD_HEADER
{
    ICMP_HEADER IcmpHeader;
    ushort MaxRespTime;
    ushort Reserved;
    IN6_ADDR MulticastAddress;
}
alias MLD_MAX_RESP_CODE_TYPE = int;
enum : int
{
    MLD_MAX_RESP_CODE_TYPE_NORMAL = 0x00000000,
    MLD_MAX_RESP_CODE_TYPE_FLOAT  = 0x00000001,
}

struct MLDV2_QUERY_HEADER
{
    ICMP_HEADER IcmpHeader;
    union
    {
        ushort MaxRespCode;
        struct
        {
            ushort _bitfield0;
        }
    }
    ushort Reserved;
    IN6_ADDR MulticastAddress;
    ubyte _bitfield1;
    union
    {
        ubyte QueriersQueryInterfaceCode;
        struct
        {
            ubyte _bitfield2;
        }
    }
    ushort SourceCount;
}
struct MLDV2_REPORT_RECORD_HEADER
{
    ubyte Type;
    ubyte AuxillaryDataLength;
    ushort SourceCount;
    IN6_ADDR MulticastAddress;
}
struct MLDV2_REPORT_HEADER
{
    ICMP_HEADER IcmpHeader;
    ushort Reserved;
    ushort RecordCount;
}
struct TCP_HDR
{
    align (1):
    ushort th_sport;
    ushort th_dport;
    uint th_seq;
    uint th_ack;
    ubyte _bitfield0;
    ubyte th_flags;
    ushort th_win;
    ushort th_sum;
    ushort th_urp;
}
struct TCP_OPT_MSS
{
    align (1):
    ubyte Kind;
    ubyte Length;
    ushort Mss;
}
struct TCP_OPT_WS
{
    align (1):
    ubyte Kind;
    ubyte Length;
    ubyte ShiftCnt;
}
struct TCP_OPT_SACK_PERMITTED
{
    align (1):
    ubyte Kind;
    ubyte Length;
}
struct TCP_OPT_SACK
{
    align (1):
    ubyte Kind;
    ubyte Length;
    struct tcp_opt_sack_block
    {
        align (1):
        uint Left;
        uint Right;
    }
}
struct TCP_OPT_TS
{
    align (1):
    ubyte Kind;
    ubyte Length;
    uint Val;
    uint EcR;
}
struct TCP_OPT_UNKNOWN
{
    align (1):
    ubyte Kind;
    ubyte Length;
}
struct TCP_OPT_FASTOPEN
{
    align (1):
    ubyte Kind;
    ubyte Length;
    ubyte[1] Cookie;
}
struct DL_TUNNEL_ADDRESS
{
    COMPARTMENT_ID CompartmentId;
    SCOPE_ID ScopeId;
    ubyte[1] IpAddress;
}
alias TUNNEL_SUB_TYPE = int;
enum : int
{
    TUNNEL_SUB_TYPE_NONE  = 0x00000000,
    TUNNEL_SUB_TYPE_CP    = 0x00000001,
    TUNNEL_SUB_TYPE_IPTLS = 0x00000002,
    TUNNEL_SUB_TYPE_HA    = 0x00000003,
}

struct DL_TEREDO_ADDRESS
{
    align (1):
    ubyte[6] Reserved;
    union
    {
        align (1):
        DL_EUI64 Eui64;
        struct
        {
            align (1):
            ushort Flags;
            ushort MappedPort;
            IN_ADDR MappedAddress;
        }
    }
}
struct DL_TEREDO_ADDRESS_PRV
{
    align (1):
    ubyte[6] Reserved;
    union
    {
        align (1):
        DL_EUI64 Eui64;
        struct
        {
            align (1):
            ushort Flags;
            ushort MappedPort;
            IN_ADDR MappedAddress;
            IN_ADDR LocalAddress;
            uint InterfaceIndex;
            ushort LocalPort;
            DL_EUI48 DlDestination;
        }
    }
}
struct IPTLS_METADATA
{
    align (1):
    ulong SequenceNumber;
}
alias NPI_MODULEID_TYPE = int;
enum : int
{
    MIT_GUID    = 0x00000001,
    MIT_IF_LUID = 0x00000002,
}

struct NPI_MODULEID
{
    ushort Length;
    NPI_MODULEID_TYPE Type;
    union
    {
        GUID Guid;
        LUID IfLuid;
    }
}
alias FALLBACK_INDEX = int;
enum : int
{
    FallbackIndexTcpFastopen = 0x00000000,
    FallbackIndexMax         = 0x00000001,
}

