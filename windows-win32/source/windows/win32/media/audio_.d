module windows.win32.media.audio_;

import windows.win32.guid : GUID;
import windows.win32.foundation : BOOL, CHAR, HANDLE, HINSTANCE, HRESULT, HWND, LPARAM, LRESULT, PSTR, PWSTR, WPARAM;
import windows.win32.media_ : HTASK, MMTIME;
import windows.win32.media.multimedia : HDRVR;
import windows.win32.system.com_ : CLSCTX, INTERFACEINFO, IUnknown, STGM;
import windows.win32.system.com.structuredstorage : PROPVARIANT;
import windows.win32.ui.shell.propertiessystem : IPropertyStore, PROPERTYKEY;
import windows.win32.ui.windowsandmessaging : HICON;

version (Windows):
extern (Windows):

alias LPWAVECALLBACK = void function(HDRVR, uint, ulong, ulong, ulong);
alias LPMIDICALLBACK = void function(HDRVR, uint, ulong, ulong, ulong);
HRESULT CoRegisterMessageFilter(IMessageFilter, IMessageFilter*);
BOOL sndPlaySoundA(const(char)*, uint);
BOOL sndPlaySoundW(const(wchar)*, uint);
BOOL PlaySoundA(const(char)*, HINSTANCE, SND_FLAGS);
BOOL PlaySoundW(const(wchar)*, HINSTANCE, SND_FLAGS);
uint waveOutGetNumDevs();
uint waveOutGetDevCapsA(ulong, WAVEOUTCAPSA*, uint);
uint waveOutGetDevCapsW(ulong, WAVEOUTCAPSW*, uint);
uint waveOutGetVolume(HWAVEOUT, uint*);
uint waveOutSetVolume(HWAVEOUT, uint);
uint waveOutGetErrorTextA(uint, PSTR, uint);
uint waveOutGetErrorTextW(uint, PWSTR, uint);
uint waveOutOpen(HWAVEOUT*, uint, WAVEFORMATEX*, ulong, ulong, MIDI_WAVE_OPEN_TYPE);
uint waveOutClose(HWAVEOUT);
uint waveOutPrepareHeader(HWAVEOUT, WAVEHDR*, uint);
uint waveOutUnprepareHeader(HWAVEOUT, WAVEHDR*, uint);
uint waveOutWrite(HWAVEOUT, WAVEHDR*, uint);
uint waveOutPause(HWAVEOUT);
uint waveOutRestart(HWAVEOUT);
uint waveOutReset(HWAVEOUT);
uint waveOutBreakLoop(HWAVEOUT);
uint waveOutGetPosition(HWAVEOUT, MMTIME*, uint);
uint waveOutGetPitch(HWAVEOUT, uint*);
uint waveOutSetPitch(HWAVEOUT, uint);
uint waveOutGetPlaybackRate(HWAVEOUT, uint*);
uint waveOutSetPlaybackRate(HWAVEOUT, uint);
uint waveOutGetID(HWAVEOUT, uint*);
uint waveOutMessage(HWAVEOUT, uint, ulong, ulong);
uint waveInGetNumDevs();
uint waveInGetDevCapsA(ulong, WAVEINCAPSA*, uint);
uint waveInGetDevCapsW(ulong, WAVEINCAPSW*, uint);
uint waveInGetErrorTextA(uint, PSTR, uint);
uint waveInGetErrorTextW(uint, PWSTR, uint);
uint waveInOpen(HWAVEIN*, uint, WAVEFORMATEX*, ulong, ulong, MIDI_WAVE_OPEN_TYPE);
uint waveInClose(HWAVEIN);
uint waveInPrepareHeader(HWAVEIN, WAVEHDR*, uint);
uint waveInUnprepareHeader(HWAVEIN, WAVEHDR*, uint);
uint waveInAddBuffer(HWAVEIN, WAVEHDR*, uint);
uint waveInStart(HWAVEIN);
uint waveInStop(HWAVEIN);
uint waveInReset(HWAVEIN);
uint waveInGetPosition(HWAVEIN, MMTIME*, uint);
uint waveInGetID(HWAVEIN, uint*);
uint waveInMessage(HWAVEIN, uint, ulong, ulong);
uint midiOutGetNumDevs();
uint midiStreamOpen(HMIDISTRM*, uint*, uint, ulong, ulong, uint);
uint midiStreamClose(HMIDISTRM);
uint midiStreamProperty(HMIDISTRM, ubyte*, uint);
uint midiStreamPosition(HMIDISTRM, MMTIME*, uint);
uint midiStreamOut(HMIDISTRM, MIDIHDR*, uint);
uint midiStreamPause(HMIDISTRM);
uint midiStreamRestart(HMIDISTRM);
uint midiStreamStop(HMIDISTRM);
uint midiConnect(HMIDI, HMIDIOUT, void*);
uint midiDisconnect(HMIDI, HMIDIOUT, void*);
uint midiOutGetDevCapsA(ulong, MIDIOUTCAPSA*, uint);
uint midiOutGetDevCapsW(ulong, MIDIOUTCAPSW*, uint);
uint midiOutGetVolume(HMIDIOUT, uint*);
uint midiOutSetVolume(HMIDIOUT, uint);
uint midiOutGetErrorTextA(uint, PSTR, uint);
uint midiOutGetErrorTextW(uint, PWSTR, uint);
uint midiOutOpen(HMIDIOUT*, uint, ulong, ulong, MIDI_WAVE_OPEN_TYPE);
uint midiOutClose(HMIDIOUT);
uint midiOutPrepareHeader(HMIDIOUT, MIDIHDR*, uint);
uint midiOutUnprepareHeader(HMIDIOUT, MIDIHDR*, uint);
uint midiOutShortMsg(HMIDIOUT, uint);
uint midiOutLongMsg(HMIDIOUT, MIDIHDR*, uint);
uint midiOutReset(HMIDIOUT);
uint midiOutCachePatches(HMIDIOUT, uint, ushort*, uint);
uint midiOutCacheDrumPatches(HMIDIOUT, uint, ushort*, uint);
uint midiOutGetID(HMIDIOUT, uint*);
uint midiOutMessage(HMIDIOUT, uint, ulong, ulong);
uint midiInGetNumDevs();
uint midiInGetDevCapsA(ulong, MIDIINCAPSA*, uint);
uint midiInGetDevCapsW(ulong, MIDIINCAPSW*, uint);
uint midiInGetErrorTextA(uint, PSTR, uint);
uint midiInGetErrorTextW(uint, PWSTR, uint);
uint midiInOpen(HMIDIIN*, uint, ulong, ulong, MIDI_WAVE_OPEN_TYPE);
uint midiInClose(HMIDIIN);
uint midiInPrepareHeader(HMIDIIN, MIDIHDR*, uint);
uint midiInUnprepareHeader(HMIDIIN, MIDIHDR*, uint);
uint midiInAddBuffer(HMIDIIN, MIDIHDR*, uint);
uint midiInStart(HMIDIIN);
uint midiInStop(HMIDIIN);
uint midiInReset(HMIDIIN);
uint midiInGetID(HMIDIIN, uint*);
uint midiInMessage(HMIDIIN, uint, ulong, ulong);
uint auxGetNumDevs();
uint auxGetDevCapsA(ulong, AUXCAPSA*, uint);
uint auxGetDevCapsW(ulong, AUXCAPSW*, uint);
uint auxSetVolume(uint, uint);
uint auxGetVolume(uint, uint*);
uint auxOutMessage(uint, uint, ulong, ulong);
uint mixerGetNumDevs();
uint mixerGetDevCapsA(ulong, MIXERCAPSA*, uint);
uint mixerGetDevCapsW(ulong, MIXERCAPSW*, uint);
uint mixerOpen(long*, uint, ulong, ulong, uint);
uint mixerClose(HMIXER);
uint mixerMessage(HMIXER, uint, ulong, ulong);
uint mixerGetLineInfoA(HMIXEROBJ, MIXERLINEA*, uint);
uint mixerGetLineInfoW(HMIXEROBJ, MIXERLINEW*, uint);
uint mixerGetID(HMIXEROBJ, uint*, uint);
uint mixerGetLineControlsA(HMIXEROBJ, MIXERLINECONTROLSA*, uint);
uint mixerGetLineControlsW(HMIXEROBJ, MIXERLINECONTROLSW*, uint);
uint mixerGetControlDetailsA(HMIXEROBJ, MIXERCONTROLDETAILS*, uint);
uint mixerGetControlDetailsW(HMIXEROBJ, MIXERCONTROLDETAILS*, uint);
uint mixerSetControlDetails(HMIXEROBJ, MIXERCONTROLDETAILS*, uint);
HRESULT ActivateAudioInterfaceAsync(const(wchar)*, const(GUID)*, PROPVARIANT*, IActivateAudioInterfaceCompletionHandler, IActivateAudioInterfaceAsyncOperation*);
HRESULT CreateRenderAudioStateMonitor(IAudioStateMonitor*);
HRESULT CreateRenderAudioStateMonitorForCategory(AUDIO_STREAM_CATEGORY, IAudioStateMonitor*);
HRESULT CreateRenderAudioStateMonitorForCategoryAndDeviceRole(AUDIO_STREAM_CATEGORY, ERole, IAudioStateMonitor*);
HRESULT CreateRenderAudioStateMonitorForCategoryAndDeviceId(AUDIO_STREAM_CATEGORY, const(wchar)*, IAudioStateMonitor*);
HRESULT CreateCaptureAudioStateMonitor(IAudioStateMonitor*);
HRESULT CreateCaptureAudioStateMonitorForCategory(AUDIO_STREAM_CATEGORY, IAudioStateMonitor*);
HRESULT CreateCaptureAudioStateMonitorForCategoryAndDeviceRole(AUDIO_STREAM_CATEGORY, ERole, IAudioStateMonitor*);
HRESULT CreateCaptureAudioStateMonitorForCategoryAndDeviceId(AUDIO_STREAM_CATEGORY, const(wchar)*, IAudioStateMonitor*);
uint acmGetVersion();
uint acmMetrics(HACMOBJ, uint, void*);
uint acmDriverEnum(ACMDRIVERENUMCB, ulong, uint);
uint acmDriverID(HACMOBJ, long*, uint);
uint acmDriverAddA(long*, HINSTANCE, LPARAM, uint, uint);
uint acmDriverAddW(long*, HINSTANCE, LPARAM, uint, uint);
uint acmDriverRemove(HACMDRIVERID, uint);
uint acmDriverOpen(long*, HACMDRIVERID, uint);
uint acmDriverClose(HACMDRIVER, uint);
LRESULT acmDriverMessage(HACMDRIVER, uint, LPARAM, LPARAM);
uint acmDriverPriority(HACMDRIVERID, uint, uint);
uint acmDriverDetailsA(HACMDRIVERID, ACMDRIVERDETAILSA*, uint);
uint acmDriverDetailsW(HACMDRIVERID, ACMDRIVERDETAILSW*, uint);
uint acmFormatTagDetailsA(HACMDRIVER, ACMFORMATTAGDETAILSA*, uint);
uint acmFormatTagDetailsW(HACMDRIVER, ACMFORMATTAGDETAILSW*, uint);
uint acmFormatTagEnumA(HACMDRIVER, ACMFORMATTAGDETAILSA*, ACMFORMATTAGENUMCBA, ulong, uint);
uint acmFormatTagEnumW(HACMDRIVER, ACMFORMATTAGDETAILSW*, ACMFORMATTAGENUMCBW, ulong, uint);
uint acmFormatDetailsA(HACMDRIVER, ACMFORMATDETAILSA*, uint);
uint acmFormatDetailsW(HACMDRIVER, tACMFORMATDETAILSW*, uint);
uint acmFormatEnumA(HACMDRIVER, ACMFORMATDETAILSA*, ACMFORMATENUMCBA, ulong, uint);
uint acmFormatEnumW(HACMDRIVER, tACMFORMATDETAILSW*, ACMFORMATENUMCBW, ulong, uint);
uint acmFormatSuggest(HACMDRIVER, WAVEFORMATEX*, WAVEFORMATEX*, uint, uint);
uint acmFormatChooseA(ACMFORMATCHOOSEA*);
uint acmFormatChooseW(ACMFORMATCHOOSEW*);
uint acmFilterTagDetailsA(HACMDRIVER, ACMFILTERTAGDETAILSA*, uint);
uint acmFilterTagDetailsW(HACMDRIVER, ACMFILTERTAGDETAILSW*, uint);
uint acmFilterTagEnumA(HACMDRIVER, ACMFILTERTAGDETAILSA*, ACMFILTERTAGENUMCBA, ulong, uint);
uint acmFilterTagEnumW(HACMDRIVER, ACMFILTERTAGDETAILSW*, ACMFILTERTAGENUMCBW, ulong, uint);
uint acmFilterDetailsA(HACMDRIVER, ACMFILTERDETAILSA*, uint);
uint acmFilterDetailsW(HACMDRIVER, ACMFILTERDETAILSW*, uint);
uint acmFilterEnumA(HACMDRIVER, ACMFILTERDETAILSA*, ACMFILTERENUMCBA, ulong, uint);
uint acmFilterEnumW(HACMDRIVER, ACMFILTERDETAILSW*, ACMFILTERENUMCBW, ulong, uint);
uint acmFilterChooseA(ACMFILTERCHOOSEA*);
uint acmFilterChooseW(ACMFILTERCHOOSEW*);
uint acmStreamOpen(long*, HACMDRIVER, WAVEFORMATEX*, WAVEFORMATEX*, WAVEFILTER*, ulong, ulong, uint);
uint acmStreamClose(HACMSTREAM, uint);
uint acmStreamSize(HACMSTREAM, uint, uint*, uint);
uint acmStreamReset(HACMSTREAM, uint);
uint acmStreamMessage(HACMSTREAM, uint, LPARAM, LPARAM);
uint acmStreamConvert(HACMSTREAM, ACMSTREAMHEADER*, uint);
uint acmStreamPrepareHeader(HACMSTREAM, ACMSTREAMHEADER*, uint);
uint acmStreamUnprepareHeader(HACMSTREAM, ACMSTREAMHEADER*, uint);
enum MIXERCONTROL_CONTROLTYPE_CUSTOM = 0x00000000;
enum MIXERCONTROL_CONTROLTYPE_BOOLEANMETER = 0x10010000;
enum MIXERCONTROL_CONTROLTYPE_SIGNEDMETER = 0x10020000;
enum MIXERCONTROL_CONTROLTYPE_PEAKMETER = 0x10020001;
enum MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER = 0x10030000;
enum MIXERCONTROL_CONTROLTYPE_BOOLEAN = 0x20010000;
enum MIXERCONTROL_CONTROLTYPE_ONOFF = 0x20010001;
enum MIXERCONTROL_CONTROLTYPE_MUTE = 0x20010002;
enum MIXERCONTROL_CONTROLTYPE_MONO = 0x20010003;
enum MIXERCONTROL_CONTROLTYPE_LOUDNESS = 0x20010004;
enum MIXERCONTROL_CONTROLTYPE_STEREOENH = 0x20010005;
enum MIXERCONTROL_CONTROLTYPE_BASS_BOOST = 0x20012277;
enum MIXERCONTROL_CONTROLTYPE_BUTTON = 0x21010000;
enum MIXERCONTROL_CONTROLTYPE_DECIBELS = 0x30040000;
enum MIXERCONTROL_CONTROLTYPE_SIGNED = 0x30020000;
enum MIXERCONTROL_CONTROLTYPE_UNSIGNED = 0x30030000;
enum MIXERCONTROL_CONTROLTYPE_PERCENT = 0x30050000;
enum MIXERCONTROL_CONTROLTYPE_SLIDER = 0x40020000;
enum MIXERCONTROL_CONTROLTYPE_PAN = 0x40020001;
enum MIXERCONTROL_CONTROLTYPE_QSOUNDPAN = 0x40020002;
enum MIXERCONTROL_CONTROLTYPE_FADER = 0x50030000;
enum MIXERCONTROL_CONTROLTYPE_VOLUME = 0x50030001;
enum MIXERCONTROL_CONTROLTYPE_BASS = 0x50030002;
enum MIXERCONTROL_CONTROLTYPE_TREBLE = 0x50030003;
enum MIXERCONTROL_CONTROLTYPE_EQUALIZER = 0x50030004;
enum MIXERCONTROL_CONTROLTYPE_SINGLESELECT = 0x70010000;
enum MIXERCONTROL_CONTROLTYPE_MUX = 0x70010001;
enum MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT = 0x71010000;
enum MIXERCONTROL_CONTROLTYPE_MIXER = 0x71010001;
enum MIXERCONTROL_CONTROLTYPE_MICROTIME = 0x60030000;
enum MIXERCONTROL_CONTROLTYPE_MILLITIME = 0x61030000;
enum WAVE_MAPPER = 0xffffffff;
enum ENDPOINT_FORMAT_RESET_MIX_ONLY = 0x00000001;
enum ENDPOINT_HARDWARE_SUPPORT_VOLUME = 0x00000001;
enum ENDPOINT_HARDWARE_SUPPORT_MUTE = 0x00000002;
enum ENDPOINT_HARDWARE_SUPPORT_METER = 0x00000004;
enum AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ = 0x00000001;
enum AMBISONICS_PARAM_VERSION_1 = 0x00000001;
enum AUDCLNT_E_NOT_INITIALIZED = 0xffffffff88890001;
enum AUDCLNT_E_ALREADY_INITIALIZED = 0xffffffff88890002;
enum AUDCLNT_E_WRONG_ENDPOINT_TYPE = 0xffffffff88890003;
enum AUDCLNT_E_DEVICE_INVALIDATED = 0xffffffff88890004;
enum AUDCLNT_E_NOT_STOPPED = 0xffffffff88890005;
enum AUDCLNT_E_BUFFER_TOO_LARGE = 0xffffffff88890006;
enum AUDCLNT_E_OUT_OF_ORDER = 0xffffffff88890007;
enum AUDCLNT_E_UNSUPPORTED_FORMAT = 0xffffffff88890008;
enum AUDCLNT_E_INVALID_SIZE = 0xffffffff88890009;
enum AUDCLNT_E_DEVICE_IN_USE = 0xffffffff8889000a;
enum AUDCLNT_E_BUFFER_OPERATION_PENDING = 0xffffffff8889000b;
enum AUDCLNT_E_THREAD_NOT_REGISTERED = 0xffffffff8889000c;
enum AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED = 0xffffffff8889000e;
enum AUDCLNT_E_ENDPOINT_CREATE_FAILED = 0xffffffff8889000f;
enum AUDCLNT_E_SERVICE_NOT_RUNNING = 0xffffffff88890010;
enum AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED = 0xffffffff88890011;
enum AUDCLNT_E_EXCLUSIVE_MODE_ONLY = 0xffffffff88890012;
enum AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL = 0xffffffff88890013;
enum AUDCLNT_E_EVENTHANDLE_NOT_SET = 0xffffffff88890014;
enum AUDCLNT_E_INCORRECT_BUFFER_SIZE = 0xffffffff88890015;
enum AUDCLNT_E_BUFFER_SIZE_ERROR = 0xffffffff88890016;
enum AUDCLNT_E_CPUUSAGE_EXCEEDED = 0xffffffff88890017;
enum AUDCLNT_E_BUFFER_ERROR = 0xffffffff88890018;
enum AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED = 0xffffffff88890019;
enum AUDCLNT_E_INVALID_DEVICE_PERIOD = 0xffffffff88890020;
enum AUDCLNT_E_INVALID_STREAM_FLAG = 0xffffffff88890021;
enum AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE = 0xffffffff88890022;
enum AUDCLNT_E_OUT_OF_OFFLOAD_RESOURCES = 0xffffffff88890023;
enum AUDCLNT_E_OFFLOAD_MODE_ONLY = 0xffffffff88890024;
enum AUDCLNT_E_NONOFFLOAD_MODE_ONLY = 0xffffffff88890025;
enum AUDCLNT_E_RESOURCES_INVALIDATED = 0xffffffff88890026;
enum AUDCLNT_E_RAW_MODE_UNSUPPORTED = 0xffffffff88890027;
enum AUDCLNT_E_ENGINE_PERIODICITY_LOCKED = 0xffffffff88890028;
enum AUDCLNT_E_ENGINE_FORMAT_LOCKED = 0xffffffff88890029;
enum AUDCLNT_E_HEADTRACKING_ENABLED = 0xffffffff88890030;
enum AUDCLNT_E_HEADTRACKING_UNSUPPORTED = 0xffffffff88890040;
enum AUDCLNT_E_EFFECT_NOT_AVAILABLE = 0xffffffff88890041;
enum AUDCLNT_E_EFFECT_STATE_READ_ONLY = 0xffffffff88890042;
enum AUDCLNT_S_BUFFER_EMPTY = 0x08890001;
enum AUDCLNT_S_THREAD_ALREADY_REGISTERED = 0x08890002;
enum AUDCLNT_S_POSITION_STALLED = 0x08890003;
enum AUDCLNT_STREAMFLAGS_CROSSPROCESS = 0x00010000;
enum AUDCLNT_STREAMFLAGS_LOOPBACK = 0x00020000;
enum AUDCLNT_STREAMFLAGS_EVENTCALLBACK = 0x00040000;
enum AUDCLNT_STREAMFLAGS_NOPERSIST = 0x00080000;
enum AUDCLNT_STREAMFLAGS_RATEADJUST = 0x00100000;
enum AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY = 0x08000000;
enum AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM = 0x80000000;
enum AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED = 0x10000000;
enum AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE = 0x20000000;
enum AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED = 0x40000000;
enum SPTLAUDCLNT_E_DESTROYED = 0xffffffff88890100;
enum SPTLAUDCLNT_E_OUT_OF_ORDER = 0xffffffff88890101;
enum SPTLAUDCLNT_E_RESOURCES_INVALIDATED = 0xffffffff88890102;
enum SPTLAUDCLNT_E_NO_MORE_OBJECTS = 0xffffffff88890103;
enum SPTLAUDCLNT_E_PROPERTY_NOT_SUPPORTED = 0xffffffff88890104;
enum SPTLAUDCLNT_E_ERRORS_IN_OBJECT_CALLS = 0xffffffff88890105;
enum SPTLAUDCLNT_E_METADATA_FORMAT_NOT_SUPPORTED = 0xffffffff88890106;
enum SPTLAUDCLNT_E_STREAM_NOT_AVAILABLE = 0xffffffff88890107;
enum SPTLAUDCLNT_E_INVALID_LICENSE = 0xffffffff88890108;
enum SPTLAUDCLNT_E_STREAM_NOT_STOPPED = 0xffffffff8889010a;
enum SPTLAUDCLNT_E_STATIC_OBJECT_NOT_AVAILABLE = 0xffffffff8889010b;
enum SPTLAUDCLNT_E_OBJECT_ALREADY_ACTIVE = 0xffffffff8889010c;
enum SPTLAUDCLNT_E_INTERNAL = 0xffffffff8889010d;
enum DEVICE_STATE_ACTIVE = 0x00000001;
enum DEVICE_STATE_DISABLED = 0x00000002;
enum DEVICE_STATE_NOTPRESENT = 0x00000004;
enum DEVICE_STATE_UNPLUGGED = 0x00000008;
enum DEVICE_STATEMASK_ALL = 0x0000000f;
//enum PKEY_AudioEndpoint_FormFactor = [MISSING];
//enum PKEY_AudioEndpoint_ControlPanelPageProvider = [MISSING];
//enum PKEY_AudioEndpoint_Association = [MISSING];
//enum PKEY_AudioEndpoint_PhysicalSpeakers = [MISSING];
//enum PKEY_AudioEndpoint_GUID = [MISSING];
//enum PKEY_AudioEndpoint_Disable_SysFx = [MISSING];
enum ENDPOINT_SYSFX_ENABLED = 0x00000000;
enum ENDPOINT_SYSFX_DISABLED = 0x00000001;
//enum PKEY_AudioEndpoint_FullRangeSpeakers = [MISSING];
//enum PKEY_AudioEndpoint_Supports_EventDriven_Mode = [MISSING];
//enum PKEY_AudioEndpoint_JackSubType = [MISSING];
//enum PKEY_AudioEndpoint_Default_VolumeInDb = [MISSING];
//enum PKEY_AudioEngine_DeviceFormat = [MISSING];
//enum PKEY_AudioEngine_OEMFormat = [MISSING];
//enum PKEY_AudioEndpointLogo_IconEffects = [MISSING];
//enum PKEY_AudioEndpointLogo_IconPath = [MISSING];
//enum PKEY_AudioEndpointSettings_MenuText = [MISSING];
//enum PKEY_AudioEndpointSettings_LaunchContract = [MISSING];
enum DEVINTERFACE_AUDIO_RENDER = GUID(0xe6327cad, 0xdcec, 0x4949, [0xae, 0x8a, 0x99, 0x1e, 0x97, 0x6a, 0x79, 0xd2]);
enum DEVINTERFACE_AUDIO_CAPTURE = GUID(0x2eef81be, 0x33fa, 0x4800, [0x96, 0x70, 0x1c, 0xd4, 0x74, 0x97, 0x2c, 0x3f]);
enum DEVINTERFACE_MIDI_OUTPUT = GUID(0x6dc23320, 0xab33, 0x4ce4, [0x80, 0xd4, 0xbb, 0xb3, 0xeb, 0xbf, 0x28, 0x14]);
enum DEVINTERFACE_MIDI_INPUT = GUID(0x504be32c, 0xccf6, 0x4d2c, [0xb7, 0x3f, 0x6f, 0x8b, 0x37, 0x47, 0xe2, 0x2b]);
enum EVENTCONTEXT_VOLUMESLIDER = GUID(0xe2c2e9de, 0x9b1, 0x4b04, [0x84, 0xe5, 0x7, 0x93, 0x12, 0x25, 0xee, 0x4]);
enum SPATIAL_AUDIO_STANDARD_COMMANDS_START = 0x000000c8;
enum SPATIAL_AUDIO_POSITION = 0x000000c8;
enum SPTLAUD_MD_CLNT_E_COMMAND_NOT_FOUND = 0xffffffff88890200;
enum SPTLAUD_MD_CLNT_E_OBJECT_NOT_INITIALIZED = 0xffffffff88890201;
enum SPTLAUD_MD_CLNT_E_INVALID_ARGS = 0xffffffff88890202;
enum SPTLAUD_MD_CLNT_E_METADATA_FORMAT_NOT_FOUND = 0xffffffff88890203;
enum SPTLAUD_MD_CLNT_E_VALUE_BUFFER_INCORRECT_SIZE = 0xffffffff88890204;
enum SPTLAUD_MD_CLNT_E_MEMORY_BOUNDS = 0xffffffff88890205;
enum SPTLAUD_MD_CLNT_E_NO_MORE_COMMANDS = 0xffffffff88890206;
enum SPTLAUD_MD_CLNT_E_BUFFER_ALREADY_ATTACHED = 0xffffffff88890207;
enum SPTLAUD_MD_CLNT_E_BUFFER_NOT_ATTACHED = 0xffffffff88890208;
enum SPTLAUD_MD_CLNT_E_FRAMECOUNT_OUT_OF_RANGE = 0xffffffff88890209;
enum SPTLAUD_MD_CLNT_E_NO_ITEMS_FOUND = 0xffffffff88890210;
enum SPTLAUD_MD_CLNT_E_ITEM_COPY_OVERFLOW = 0xffffffff88890211;
enum SPTLAUD_MD_CLNT_E_NO_ITEMS_OPEN = 0xffffffff88890212;
enum SPTLAUD_MD_CLNT_E_ITEMS_ALREADY_OPEN = 0xffffffff88890213;
enum SPTLAUD_MD_CLNT_E_ATTACH_FAILED_INTERNAL_BUFFER = 0xffffffff88890214;
enum SPTLAUD_MD_CLNT_E_DETACH_FAILED_INTERNAL_BUFFER = 0xffffffff88890215;
enum SPTLAUD_MD_CLNT_E_NO_BUFFER_ATTACHED = 0xffffffff88890216;
enum SPTLAUD_MD_CLNT_E_NO_MORE_ITEMS = 0xffffffff88890217;
enum SPTLAUD_MD_CLNT_E_FRAMEOFFSET_OUT_OF_RANGE = 0xffffffff88890218;
enum SPTLAUD_MD_CLNT_E_ITEM_MUST_HAVE_COMMANDS = 0xffffffff88890219;
enum SPTLAUD_MD_CLNT_E_NO_ITEMOFFSET_WRITTEN = 0xffffffff88890220;
enum SPTLAUD_MD_CLNT_E_NO_ITEMS_WRITTEN = 0xffffffff88890221;
enum SPTLAUD_MD_CLNT_E_COMMAND_ALREADY_WRITTEN = 0xffffffff88890222;
enum SPTLAUD_MD_CLNT_E_FORMAT_MISMATCH = 0xffffffff88890223;
enum SPTLAUD_MD_CLNT_E_BUFFER_STILL_ATTACHED = 0xffffffff88890224;
enum SPTLAUD_MD_CLNT_E_ITEMS_LOCKED_FOR_WRITING = 0xffffffff88890225;
enum VIRTUAL_AUDIO_DEVICE_PROCESS_LOOPBACK = "VAD\\Process_Loopback";
enum WAVERR_BADFORMAT = 0x00000020;
enum WAVERR_STILLPLAYING = 0x00000021;
enum WAVERR_UNPREPARED = 0x00000022;
enum WAVERR_SYNC = 0x00000023;
enum WAVERR_LASTERROR = 0x00000023;
enum WHDR_DONE = 0x00000001;
enum WHDR_PREPARED = 0x00000002;
enum WHDR_BEGINLOOP = 0x00000004;
enum WHDR_ENDLOOP = 0x00000008;
enum WHDR_INQUEUE = 0x00000010;
enum WAVECAPS_PITCH = 0x00000001;
enum WAVECAPS_PLAYBACKRATE = 0x00000002;
enum WAVECAPS_VOLUME = 0x00000004;
enum WAVECAPS_LRVOLUME = 0x00000008;
enum WAVECAPS_SYNC = 0x00000010;
enum WAVECAPS_SAMPLEACCURATE = 0x00000020;
enum WAVE_INVALIDFORMAT = 0x00000000;
enum WAVE_FORMAT_1M08 = 0x00000001;
enum WAVE_FORMAT_1S08 = 0x00000002;
enum WAVE_FORMAT_1M16 = 0x00000004;
enum WAVE_FORMAT_1S16 = 0x00000008;
enum WAVE_FORMAT_2M08 = 0x00000010;
enum WAVE_FORMAT_2S08 = 0x00000020;
enum WAVE_FORMAT_2M16 = 0x00000040;
enum WAVE_FORMAT_2S16 = 0x00000080;
enum WAVE_FORMAT_4M08 = 0x00000100;
enum WAVE_FORMAT_4S08 = 0x00000200;
enum WAVE_FORMAT_4M16 = 0x00000400;
enum WAVE_FORMAT_4S16 = 0x00000800;
enum WAVE_FORMAT_44M08 = 0x00000100;
enum WAVE_FORMAT_44S08 = 0x00000200;
enum WAVE_FORMAT_44M16 = 0x00000400;
enum WAVE_FORMAT_44S16 = 0x00000800;
enum WAVE_FORMAT_48M08 = 0x00001000;
enum WAVE_FORMAT_48S08 = 0x00002000;
enum WAVE_FORMAT_48M16 = 0x00004000;
enum WAVE_FORMAT_48S16 = 0x00008000;
enum WAVE_FORMAT_96M08 = 0x00010000;
enum WAVE_FORMAT_96S08 = 0x00020000;
enum WAVE_FORMAT_96M16 = 0x00040000;
enum WAVE_FORMAT_96S16 = 0x00080000;
enum WAVE_FORMAT_PCM = 0x00000001;
enum MIDIERR_UNPREPARED = 0x00000040;
enum MIDIERR_STILLPLAYING = 0x00000041;
enum MIDIERR_NOMAP = 0x00000042;
enum MIDIERR_NOTREADY = 0x00000043;
enum MIDIERR_NODEVICE = 0x00000044;
enum MIDIERR_INVALIDSETUP = 0x00000045;
enum MIDIERR_BADOPENMODE = 0x00000046;
enum MIDIERR_DONT_CONTINUE = 0x00000047;
enum MIDIERR_LASTERROR = 0x00000047;
enum MIDIPATCHSIZE = 0x00000080;
enum MIDI_CACHE_ALL = 0x00000001;
enum MIDI_CACHE_BESTFIT = 0x00000002;
enum MIDI_CACHE_QUERY = 0x00000003;
enum MIDI_UNCACHE = 0x00000004;
enum MOD_MIDIPORT = 0x00000001;
enum MOD_SYNTH = 0x00000002;
enum MOD_SQSYNTH = 0x00000003;
enum MOD_FMSYNTH = 0x00000004;
enum MOD_MAPPER = 0x00000005;
enum MOD_WAVETABLE = 0x00000006;
enum MOD_SWSYNTH = 0x00000007;
enum MIDICAPS_VOLUME = 0x00000001;
enum MIDICAPS_LRVOLUME = 0x00000002;
enum MIDICAPS_CACHE = 0x00000004;
enum MIDICAPS_STREAM = 0x00000008;
enum MHDR_DONE = 0x00000001;
enum MHDR_PREPARED = 0x00000002;
enum MHDR_INQUEUE = 0x00000004;
enum MHDR_ISSTRM = 0x00000008;
enum MEVT_F_SHORT = 0x00000000;
enum MEVT_F_LONG = 0xffffffff80000000;
enum MEVT_F_CALLBACK = 0x40000000;
enum MIDISTRM_ERROR = 0xfffffffffffffffe;
enum MIDIPROP_SET = 0xffffffff80000000;
enum MIDIPROP_GET = 0x40000000;
enum MIDIPROP_TIMEDIV = 0x00000001;
enum MIDIPROP_TEMPO = 0x00000002;
enum AUXCAPS_CDAUDIO = 0x00000001;
enum AUXCAPS_AUXIN = 0x00000002;
enum AUXCAPS_VOLUME = 0x00000001;
enum AUXCAPS_LRVOLUME = 0x00000002;
enum MIXER_SHORT_NAME_CHARS = 0x00000010;
enum MIXER_LONG_NAME_CHARS = 0x00000040;
enum MIXERR_INVALLINE = 0x00000400;
enum MIXERR_INVALCONTROL = 0x00000401;
enum MIXERR_INVALVALUE = 0x00000402;
enum MIXERR_LASTERROR = 0x00000402;
enum MIXER_OBJECTF_HANDLE = 0xffffffff80000000;
enum MIXER_OBJECTF_MIXER = 0x00000000;
enum MIXER_OBJECTF_WAVEOUT = 0x10000000;
enum MIXER_OBJECTF_WAVEIN = 0x20000000;
enum MIXER_OBJECTF_MIDIOUT = 0x30000000;
enum MIXER_OBJECTF_MIDIIN = 0x40000000;
enum MIXER_OBJECTF_AUX = 0x50000000;
enum MIXERLINE_LINEF_ACTIVE = 0x00000001;
enum MIXERLINE_LINEF_DISCONNECTED = 0x00008000;
enum MIXERLINE_LINEF_SOURCE = 0xffffffff80000000;
enum MIXERLINE_COMPONENTTYPE_DST_FIRST = 0x00000000;
enum MIXERLINE_COMPONENTTYPE_DST_LAST = 0x00000008;
enum MIXERLINE_COMPONENTTYPE_SRC_FIRST = 0x00001000;
enum MIXERLINE_COMPONENTTYPE_SRC_LAST = 0x0000100a;
enum MIXERLINE_TARGETTYPE_UNDEFINED = 0x00000000;
enum MIXERLINE_TARGETTYPE_WAVEOUT = 0x00000001;
enum MIXERLINE_TARGETTYPE_WAVEIN = 0x00000002;
enum MIXERLINE_TARGETTYPE_MIDIOUT = 0x00000003;
enum MIXERLINE_TARGETTYPE_MIDIIN = 0x00000004;
enum MIXERLINE_TARGETTYPE_AUX = 0x00000005;
enum MIXER_GETLINEINFOF_DESTINATION = 0x00000000;
enum MIXER_GETLINEINFOF_SOURCE = 0x00000001;
enum MIXER_GETLINEINFOF_LINEID = 0x00000002;
enum MIXER_GETLINEINFOF_COMPONENTTYPE = 0x00000003;
enum MIXER_GETLINEINFOF_TARGETTYPE = 0x00000004;
enum MIXER_GETLINEINFOF_QUERYMASK = 0x0000000f;
enum MIXERCONTROL_CONTROLF_UNIFORM = 0x00000001;
enum MIXERCONTROL_CONTROLF_MULTIPLE = 0x00000002;
enum MIXERCONTROL_CONTROLF_DISABLED = 0xffffffff80000000;
enum MIXERCONTROL_CT_CLASS_MASK = 0xfffffffff0000000;
enum MIXERCONTROL_CT_CLASS_CUSTOM = 0x00000000;
enum MIXERCONTROL_CT_CLASS_METER = 0x10000000;
enum MIXERCONTROL_CT_CLASS_SWITCH = 0x20000000;
enum MIXERCONTROL_CT_CLASS_NUMBER = 0x30000000;
enum MIXERCONTROL_CT_CLASS_SLIDER = 0x40000000;
enum MIXERCONTROL_CT_CLASS_FADER = 0x50000000;
enum MIXERCONTROL_CT_CLASS_TIME = 0x60000000;
enum MIXERCONTROL_CT_CLASS_LIST = 0x70000000;
enum MIXERCONTROL_CT_SUBCLASS_MASK = 0x0f000000;
enum MIXERCONTROL_CT_SC_SWITCH_BOOLEAN = 0x00000000;
enum MIXERCONTROL_CT_SC_SWITCH_BUTTON = 0x01000000;
enum MIXERCONTROL_CT_SC_METER_POLLED = 0x00000000;
enum MIXERCONTROL_CT_SC_TIME_MICROSECS = 0x00000000;
enum MIXERCONTROL_CT_SC_TIME_MILLISECS = 0x01000000;
enum MIXERCONTROL_CT_SC_LIST_SINGLE = 0x00000000;
enum MIXERCONTROL_CT_SC_LIST_MULTIPLE = 0x01000000;
enum MIXERCONTROL_CT_UNITS_MASK = 0x00ff0000;
enum MIXERCONTROL_CT_UNITS_CUSTOM = 0x00000000;
enum MIXERCONTROL_CT_UNITS_BOOLEAN = 0x00010000;
enum MIXERCONTROL_CT_UNITS_SIGNED = 0x00020000;
enum MIXERCONTROL_CT_UNITS_UNSIGNED = 0x00030000;
enum MIXERCONTROL_CT_UNITS_DECIBELS = 0x00040000;
enum MIXERCONTROL_CT_UNITS_PERCENT = 0x00050000;
enum MIXER_GETLINECONTROLSF_ALL = 0x00000000;
enum MIXER_GETLINECONTROLSF_ONEBYID = 0x00000001;
enum MIXER_GETLINECONTROLSF_ONEBYTYPE = 0x00000002;
enum MIXER_GETLINECONTROLSF_QUERYMASK = 0x0000000f;
enum MIXER_GETCONTROLDETAILSF_VALUE = 0x00000000;
enum MIXER_GETCONTROLDETAILSF_LISTTEXT = 0x00000001;
enum MIXER_GETCONTROLDETAILSF_QUERYMASK = 0x0000000f;
enum MIXER_SETCONTROLDETAILSF_VALUE = 0x00000000;
enum MIXER_SETCONTROLDETAILSF_CUSTOM = 0x00000001;
enum MIXER_SETCONTROLDETAILSF_QUERYMASK = 0x0000000f;
enum DRV_MAPPER_PREFERRED_INPUT_GET = 0x00004000;
enum DRV_MAPPER_PREFERRED_OUTPUT_GET = 0x00004002;
enum DRVM_MAPPER = 0x00002000;
enum DRVM_MAPPER_STATUS = 0x00002000;
enum WIDM_MAPPER_STATUS = 0x00002000;
enum WAVEIN_MAPPER_STATUS_DEVICE = 0x00000000;
enum WAVEIN_MAPPER_STATUS_MAPPED = 0x00000001;
enum WAVEIN_MAPPER_STATUS_FORMAT = 0x00000002;
enum WODM_MAPPER_STATUS = 0x00002000;
enum WAVEOUT_MAPPER_STATUS_DEVICE = 0x00000000;
enum WAVEOUT_MAPPER_STATUS_MAPPED = 0x00000001;
enum WAVEOUT_MAPPER_STATUS_FORMAT = 0x00000002;
enum ACMERR_BASE = 0x00000200;
enum ACMERR_NOTPOSSIBLE = 0x00000200;
enum ACMERR_BUSY = 0x00000201;
enum ACMERR_UNPREPARED = 0x00000202;
enum ACMERR_CANCELED = 0x00000203;
enum ACM_METRIC_COUNT_DRIVERS = 0x00000001;
enum ACM_METRIC_COUNT_CODECS = 0x00000002;
enum ACM_METRIC_COUNT_CONVERTERS = 0x00000003;
enum ACM_METRIC_COUNT_FILTERS = 0x00000004;
enum ACM_METRIC_COUNT_DISABLED = 0x00000005;
enum ACM_METRIC_COUNT_HARDWARE = 0x00000006;
enum ACM_METRIC_COUNT_LOCAL_DRIVERS = 0x00000014;
enum ACM_METRIC_COUNT_LOCAL_CODECS = 0x00000015;
enum ACM_METRIC_COUNT_LOCAL_CONVERTERS = 0x00000016;
enum ACM_METRIC_COUNT_LOCAL_FILTERS = 0x00000017;
enum ACM_METRIC_COUNT_LOCAL_DISABLED = 0x00000018;
enum ACM_METRIC_HARDWARE_WAVE_INPUT = 0x0000001e;
enum ACM_METRIC_HARDWARE_WAVE_OUTPUT = 0x0000001f;
enum ACM_METRIC_MAX_SIZE_FORMAT = 0x00000032;
enum ACM_METRIC_MAX_SIZE_FILTER = 0x00000033;
enum ACM_METRIC_DRIVER_SUPPORT = 0x00000064;
enum ACM_METRIC_DRIVER_PRIORITY = 0x00000065;
enum ACM_DRIVERENUMF_NOLOCAL = 0x40000000;
enum ACM_DRIVERENUMF_DISABLED = 0xffffffff80000000;
enum ACM_DRIVERADDF_NAME = 0x00000001;
enum ACM_DRIVERADDF_FUNCTION = 0x00000003;
enum ACM_DRIVERADDF_NOTIFYHWND = 0x00000004;
enum ACM_DRIVERADDF_TYPEMASK = 0x00000007;
enum ACM_DRIVERADDF_LOCAL = 0x00000000;
enum ACM_DRIVERADDF_GLOBAL = 0x00000008;
enum ACMDM_USER = 0x00004000;
enum ACMDM_RESERVED_LOW = 0x00006000;
enum ACMDM_RESERVED_HIGH = 0x00006fff;
enum ACMDM_DRIVER_ABOUT = 0x0000600b;
enum ACM_DRIVERPRIORITYF_ENABLE = 0x00000001;
enum ACM_DRIVERPRIORITYF_DISABLE = 0x00000002;
enum ACM_DRIVERPRIORITYF_ABLEMASK = 0x00000003;
enum ACM_DRIVERPRIORITYF_BEGIN = 0x00010000;
enum ACM_DRIVERPRIORITYF_END = 0x00020000;
enum ACM_DRIVERPRIORITYF_DEFERMASK = 0x00030000;
enum ACMDRIVERDETAILS_SHORTNAME_CHARS = 0x00000020;
enum ACMDRIVERDETAILS_LONGNAME_CHARS = 0x00000080;
enum ACMDRIVERDETAILS_COPYRIGHT_CHARS = 0x00000050;
enum ACMDRIVERDETAILS_LICENSING_CHARS = 0x00000080;
enum ACMDRIVERDETAILS_FEATURES_CHARS = 0x00000200;
enum ACMDRIVERDETAILS_SUPPORTF_CODEC = 0x00000001;
enum ACMDRIVERDETAILS_SUPPORTF_CONVERTER = 0x00000002;
enum ACMDRIVERDETAILS_SUPPORTF_FILTER = 0x00000004;
enum ACMDRIVERDETAILS_SUPPORTF_HARDWARE = 0x00000008;
enum ACMDRIVERDETAILS_SUPPORTF_ASYNC = 0x00000010;
enum ACMDRIVERDETAILS_SUPPORTF_LOCAL = 0x40000000;
enum ACMDRIVERDETAILS_SUPPORTF_DISABLED = 0xffffffff80000000;
enum ACMFORMATTAGDETAILS_FORMATTAG_CHARS = 0x00000030;
enum ACM_FORMATTAGDETAILSF_INDEX = 0x00000000;
enum ACM_FORMATTAGDETAILSF_FORMATTAG = 0x00000001;
enum ACM_FORMATTAGDETAILSF_LARGESTSIZE = 0x00000002;
enum ACM_FORMATTAGDETAILSF_QUERYMASK = 0x0000000f;
enum ACMFORMATDETAILS_FORMAT_CHARS = 0x00000080;
enum ACM_FORMATDETAILSF_INDEX = 0x00000000;
enum ACM_FORMATDETAILSF_FORMAT = 0x00000001;
enum ACM_FORMATDETAILSF_QUERYMASK = 0x0000000f;
enum ACM_FORMATENUMF_WFORMATTAG = 0x00010000;
enum ACM_FORMATENUMF_NCHANNELS = 0x00020000;
enum ACM_FORMATENUMF_NSAMPLESPERSEC = 0x00040000;
enum ACM_FORMATENUMF_WBITSPERSAMPLE = 0x00080000;
enum ACM_FORMATENUMF_CONVERT = 0x00100000;
enum ACM_FORMATENUMF_SUGGEST = 0x00200000;
enum ACM_FORMATENUMF_HARDWARE = 0x00400000;
enum ACM_FORMATENUMF_INPUT = 0x00800000;
enum ACM_FORMATENUMF_OUTPUT = 0x01000000;
enum ACM_FORMATSUGGESTF_WFORMATTAG = 0x00010000;
enum ACM_FORMATSUGGESTF_NCHANNELS = 0x00020000;
enum ACM_FORMATSUGGESTF_NSAMPLESPERSEC = 0x00040000;
enum ACM_FORMATSUGGESTF_WBITSPERSAMPLE = 0x00080000;
enum ACM_FORMATSUGGESTF_TYPEMASK = 0x00ff0000;
enum ACMHELPMSGSTRINGA = "acmchoose_help";
enum ACMHELPMSGSTRINGW = "acmchoose_help";
enum ACMHELPMSGCONTEXTMENUA = "acmchoose_contextmenu";
enum ACMHELPMSGCONTEXTMENUW = "acmchoose_contextmenu";
enum ACMHELPMSGCONTEXTHELPA = "acmchoose_contexthelp";
enum ACMHELPMSGCONTEXTHELPW = "acmchoose_contexthelp";
enum ACMHELPMSGSTRING = "acmchoose_help";
enum ACMHELPMSGCONTEXTMENU = "acmchoose_contextmenu";
enum ACMHELPMSGCONTEXTHELP = "acmchoose_contexthelp";
enum MM_ACM_FORMATCHOOSE = 0x00008000;
enum FORMATCHOOSE_MESSAGE = 0x00000000;
enum FORMATCHOOSE_FORMATTAG_VERIFY = 0x00000000;
enum FORMATCHOOSE_FORMAT_VERIFY = 0x00000001;
enum FORMATCHOOSE_CUSTOM_VERIFY = 0x00000002;
enum ACMFORMATCHOOSE_STYLEF_SHOWHELP = 0x00000004;
enum ACMFORMATCHOOSE_STYLEF_ENABLEHOOK = 0x00000008;
enum ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE = 0x00000010;
enum ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE = 0x00000020;
enum ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT = 0x00000040;
enum ACMFORMATCHOOSE_STYLEF_CONTEXTHELP = 0x00000080;
enum ACMFILTERTAGDETAILS_FILTERTAG_CHARS = 0x00000030;
enum ACM_FILTERTAGDETAILSF_INDEX = 0x00000000;
enum ACM_FILTERTAGDETAILSF_FILTERTAG = 0x00000001;
enum ACM_FILTERTAGDETAILSF_LARGESTSIZE = 0x00000002;
enum ACM_FILTERTAGDETAILSF_QUERYMASK = 0x0000000f;
enum ACMFILTERDETAILS_FILTER_CHARS = 0x00000080;
enum ACM_FILTERDETAILSF_INDEX = 0x00000000;
enum ACM_FILTERDETAILSF_FILTER = 0x00000001;
enum ACM_FILTERDETAILSF_QUERYMASK = 0x0000000f;
enum ACM_FILTERENUMF_DWFILTERTAG = 0x00010000;
enum MM_ACM_FILTERCHOOSE = 0x00008000;
enum FILTERCHOOSE_MESSAGE = 0x00000000;
enum FILTERCHOOSE_FILTERTAG_VERIFY = 0x00000000;
enum FILTERCHOOSE_FILTER_VERIFY = 0x00000001;
enum FILTERCHOOSE_CUSTOM_VERIFY = 0x00000002;
enum ACMFILTERCHOOSE_STYLEF_SHOWHELP = 0x00000004;
enum ACMFILTERCHOOSE_STYLEF_ENABLEHOOK = 0x00000008;
enum ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE = 0x00000010;
enum ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE = 0x00000020;
enum ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT = 0x00000040;
enum ACMFILTERCHOOSE_STYLEF_CONTEXTHELP = 0x00000080;
enum ACMSTREAMHEADER_STATUSF_DONE = 0x00010000;
enum ACMSTREAMHEADER_STATUSF_PREPARED = 0x00020000;
enum ACMSTREAMHEADER_STATUSF_INQUEUE = 0x00100000;
enum ACM_STREAMOPENF_QUERY = 0x00000001;
enum ACM_STREAMOPENF_ASYNC = 0x00000002;
enum ACM_STREAMOPENF_NONREALTIME = 0x00000004;
enum ACM_STREAMSIZEF_SOURCE = 0x00000000;
enum ACM_STREAMSIZEF_DESTINATION = 0x00000001;
enum ACM_STREAMSIZEF_QUERYMASK = 0x0000000f;
enum ACM_STREAMCONVERTF_BLOCKALIGN = 0x00000004;
enum ACM_STREAMCONVERTF_START = 0x00000010;
enum ACM_STREAMCONVERTF_END = 0x00000020;
enum SND_RING = 0x00100000;
enum SND_ALIAS_START = 0x00000000;
enum ACMDM_DRIVER_NOTIFY = 0x00006001;
enum ACMDM_DRIVER_DETAILS = 0x0000600a;
enum ACMDM_HARDWARE_WAVE_CAPS_INPUT = 0x00006014;
enum ACMDM_HARDWARE_WAVE_CAPS_OUTPUT = 0x00006015;
enum ACMDM_FORMATTAG_DETAILS = 0x00006019;
enum ACMDM_FORMAT_DETAILS = 0x0000601a;
enum ACMDM_FORMAT_SUGGEST = 0x0000601b;
enum ACMDM_FILTERTAG_DETAILS = 0x00006032;
enum ACMDM_FILTER_DETAILS = 0x00006033;
enum ACMDM_STREAM_OPEN = 0x0000604c;
enum ACMDM_STREAM_CLOSE = 0x0000604d;
enum ACMDM_STREAM_SIZE = 0x0000604e;
enum ACMDM_STREAM_CONVERT = 0x0000604f;
enum ACMDM_STREAM_RESET = 0x00006050;
enum ACMDM_STREAM_PREPARE = 0x00006051;
enum ACMDM_STREAM_UNPREPARE = 0x00006052;
enum ACMDM_STREAM_UPDATE = 0x00006053;
alias MIDI_WAVE_OPEN_TYPE = uint;
enum : uint
{
    CALLBACK_TYPEMASK                        = 0x00070000,
    CALLBACK_NULL                            = 0x00000000,
    CALLBACK_WINDOW                          = 0x00010000,
    CALLBACK_TASK                            = 0x00020000,
    CALLBACK_FUNCTION                        = 0x00030000,
    CALLBACK_THREAD                          = 0x00020000,
    CALLBACK_EVENT                           = 0x00050000,
    WAVE_FORMAT_QUERY                        = 0x00000001,
    WAVE_ALLOWSYNC                           = 0x00000002,
    WAVE_MAPPED                              = 0x00000004,
    WAVE_FORMAT_DIRECT                       = 0x00000008,
    WAVE_FORMAT_DIRECT_QUERY                 = 0x00000009,
    WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE = 0x00000010,
    MIDI_IO_STATUS                           = 0x00000020,
}

alias SND_FLAGS = uint;
enum : uint
{
    SND_APPLICATION = 0x00000080,
    SND_ALIAS       = 0x00010000,
    SND_ALIAS_ID    = 0x00110000,
    SND_FILENAME    = 0x00020000,
    SND_RESOURCE    = 0x00040004,
    SND_ASYNC       = 0x00000001,
    SND_NODEFAULT   = 0x00000002,
    SND_LOOP        = 0x00000008,
    SND_MEMORY      = 0x00000004,
    SND_NOSTOP      = 0x00000010,
    SND_NOWAIT      = 0x00002000,
    SND_PURGE       = 0x00000040,
    SND_SENTRY      = 0x00080000,
    SND_SYNC        = 0x00000000,
    SND_SYSTEM      = 0x00200000,
}

alias MIXERLINE_COMPONENTTYPE = uint;
enum : uint
{
    MIXERLINE_COMPONENTTYPE_DST_DIGITAL     = 0x00000001,
    MIXERLINE_COMPONENTTYPE_DST_HEADPHONES  = 0x00000005,
    MIXERLINE_COMPONENTTYPE_DST_LINE        = 0x00000002,
    MIXERLINE_COMPONENTTYPE_DST_MONITOR     = 0x00000003,
    MIXERLINE_COMPONENTTYPE_DST_SPEAKERS    = 0x00000004,
    MIXERLINE_COMPONENTTYPE_DST_TELEPHONE   = 0x00000006,
    MIXERLINE_COMPONENTTYPE_DST_UNDEFINED   = 0x00000000,
    MIXERLINE_COMPONENTTYPE_DST_VOICEIN     = 0x00000008,
    MIXERLINE_COMPONENTTYPE_DST_WAVEIN      = 0x00000007,
    MIXERLINE_COMPONENTTYPE_SRC_ANALOG      = 0x0000100a,
    MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY   = 0x00001009,
    MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC = 0x00001005,
    MIXERLINE_COMPONENTTYPE_SRC_DIGITAL     = 0x00001001,
    MIXERLINE_COMPONENTTYPE_SRC_LINE        = 0x00001002,
    MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE  = 0x00001003,
    MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER   = 0x00001007,
    MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER = 0x00001004,
    MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE   = 0x00001006,
    MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED   = 0x00001000,
    MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT     = 0x00001008,
}

struct AUDIO_VOLUME_NOTIFICATION_DATA
{
    GUID guidEventContext;
    BOOL bMuted;
    float fMasterVolume;
    uint nChannels;
    float[1] afChannelVolumes;
}
alias HMIDI = void*;
alias HMIDIIN = void*;
alias HMIDIOUT = void*;
alias HMIDISTRM = void*;
alias HMIXER = void*;
alias HMIXEROBJ = void*;
alias HWAVE = void*;
alias HWAVEOUT = void*;
alias HWAVEIN = void*;
alias HACMDRIVERID = void*;
alias HACMDRIVER = void*;
alias HACMSTREAM = void*;
alias HACMOBJ = void*;
enum IID_IMessageFilter = GUID(0x16, 0x0, 0x0, [0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46]);
interface IMessageFilter : IUnknown
{
    uint HandleInComingCall(uint, HTASK, uint, INTERFACEINFO*);
    uint RetryRejectedCall(HTASK, uint, uint);
    uint MessagePending(HTASK, uint, uint);
}
struct WAVEFORMATEXTENSIBLE
{
    align (1):
    WAVEFORMATEX Format;
    union _Samples_e__Union
    {
        align (1):
        ushort wValidBitsPerSample;
        ushort wSamplesPerBlock;
        ushort wReserved;
    }
    uint dwChannelMask;
    GUID SubFormat;
}
struct WAVEFILTER
{
    align (1):
    uint cbStruct;
    uint dwFilterTag;
    uint fdwFilter;
    uint[5] dwReserved;
}
struct VOLUMEWAVEFILTER
{
    align (1):
    WAVEFILTER wfltr;
    uint dwVolume;
}
struct ECHOWAVEFILTER
{
    align (1):
    WAVEFILTER wfltr;
    uint dwVolume;
    uint dwDelay;
}
struct ACMSTREAMHEADER
{
    align (1):
    uint cbStruct;
    uint fdwStatus;
    ulong dwUser;
    ubyte* pbSrc;
    uint cbSrcLength;
    uint cbSrcLengthUsed;
    ulong dwSrcUser;
    ubyte* pbDst;
    uint cbDstLength;
    uint cbDstLengthUsed;
    ulong dwDstUser;
    uint[15] dwReservedDriver;
}
struct WAVEHDR
{
    align (1):
    PSTR lpData;
    uint dwBufferLength;
    uint dwBytesRecorded;
    ulong dwUser;
    uint dwFlags;
    uint dwLoops;
    WAVEHDR* lpNext;
    ulong reserved;
}
struct WAVEOUTCAPSA
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    uint dwFormats;
    ushort wChannels;
    ushort wReserved1;
    uint dwSupport;
}
struct WAVEOUTCAPSW
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    uint dwFormats;
    ushort wChannels;
    ushort wReserved1;
    uint dwSupport;
}
struct WAVEOUTCAPS2A
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    uint dwFormats;
    ushort wChannels;
    ushort wReserved1;
    uint dwSupport;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct WAVEOUTCAPS2W
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    uint dwFormats;
    ushort wChannels;
    ushort wReserved1;
    uint dwSupport;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct WAVEINCAPSA
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    uint dwFormats;
    ushort wChannels;
    ushort wReserved1;
}
struct WAVEINCAPSW
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    uint dwFormats;
    ushort wChannels;
    ushort wReserved1;
}
struct WAVEINCAPS2A
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    uint dwFormats;
    ushort wChannels;
    ushort wReserved1;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct WAVEINCAPS2W
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    uint dwFormats;
    ushort wChannels;
    ushort wReserved1;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct WAVEFORMAT
{
    align (1):
    ushort wFormatTag;
    ushort nChannels;
    uint nSamplesPerSec;
    uint nAvgBytesPerSec;
    ushort nBlockAlign;
}
struct PCMWAVEFORMAT
{
    align (1):
    WAVEFORMAT wf;
    ushort wBitsPerSample;
}
struct WAVEFORMATEX
{
    align (1):
    ushort wFormatTag;
    ushort nChannels;
    uint nSamplesPerSec;
    uint nAvgBytesPerSec;
    ushort nBlockAlign;
    ushort wBitsPerSample;
    ushort cbSize;
}
struct MIDIOUTCAPSA
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    ushort wTechnology;
    ushort wVoices;
    ushort wNotes;
    ushort wChannelMask;
    uint dwSupport;
}
struct MIDIOUTCAPSW
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    ushort wTechnology;
    ushort wVoices;
    ushort wNotes;
    ushort wChannelMask;
    uint dwSupport;
}
struct MIDIOUTCAPS2A
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    ushort wTechnology;
    ushort wVoices;
    ushort wNotes;
    ushort wChannelMask;
    uint dwSupport;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct MIDIOUTCAPS2W
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    ushort wTechnology;
    ushort wVoices;
    ushort wNotes;
    ushort wChannelMask;
    uint dwSupport;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct MIDIINCAPSA
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    uint dwSupport;
}
struct MIDIINCAPSW
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    uint dwSupport;
}
struct MIDIINCAPS2A
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    uint dwSupport;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct MIDIINCAPS2W
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    uint dwSupport;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct MIDIHDR
{
    align (1):
    PSTR lpData;
    uint dwBufferLength;
    uint dwBytesRecorded;
    ulong dwUser;
    uint dwFlags;
    MIDIHDR* lpNext;
    ulong reserved;
    uint dwOffset;
    ulong[8] dwReserved;
}
struct MIDIEVENT
{
    align (1):
    uint dwDeltaTime;
    uint dwStreamID;
    uint dwEvent;
    uint[1] dwParms;
}
struct MIDISTRMBUFFVER
{
    align (1):
    uint dwVersion;
    uint dwMid;
    uint dwOEMVersion;
}
struct MIDIPROPTIMEDIV
{
    align (1):
    uint cbStruct;
    uint dwTimeDiv;
}
struct MIDIPROPTEMPO
{
    align (1):
    uint cbStruct;
    uint dwTempo;
}
struct AUXCAPSA
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    ushort wTechnology;
    ushort wReserved1;
    uint dwSupport;
}
struct AUXCAPSW
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    ushort wTechnology;
    ushort wReserved1;
    uint dwSupport;
}
struct AUXCAPS2A
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    ushort wTechnology;
    ushort wReserved1;
    uint dwSupport;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct AUXCAPS2W
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    ushort wTechnology;
    ushort wReserved1;
    uint dwSupport;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct MIXERCAPSA
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    uint fdwSupport;
    uint cDestinations;
}
struct MIXERCAPSW
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    uint fdwSupport;
    uint cDestinations;
}
struct MIXERCAPS2A
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    CHAR[32] szPname;
    uint fdwSupport;
    uint cDestinations;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct MIXERCAPS2W
{
    align (1):
    ushort wMid;
    ushort wPid;
    uint vDriverVersion;
    wchar[32] szPname;
    uint fdwSupport;
    uint cDestinations;
    GUID ManufacturerGuid;
    GUID ProductGuid;
    GUID NameGuid;
}
struct MIXERLINEA
{
    align (1):
    uint cbStruct;
    uint dwDestination;
    uint dwSource;
    uint dwLineID;
    uint fdwLine;
    ulong dwUser;
    MIXERLINE_COMPONENTTYPE dwComponentType;
    uint cChannels;
    uint cConnections;
    uint cControls;
    CHAR[16] szShortName;
    CHAR[64] szName;
    struct _Target_e__Struct
    {
        align (1):
        uint dwType;
        uint dwDeviceID;
        ushort wMid;
        ushort wPid;
        uint vDriverVersion;
        CHAR[32] szPname;
    }
}
struct MIXERLINEW
{
    align (1):
    uint cbStruct;
    uint dwDestination;
    uint dwSource;
    uint dwLineID;
    uint fdwLine;
    ulong dwUser;
    MIXERLINE_COMPONENTTYPE dwComponentType;
    uint cChannels;
    uint cConnections;
    uint cControls;
    wchar[16] szShortName;
    wchar[64] szName;
    struct _Target_e__Struct
    {
        align (1):
        uint dwType;
        uint dwDeviceID;
        ushort wMid;
        ushort wPid;
        uint vDriverVersion;
        wchar[32] szPname;
    }
}
struct MIXERCONTROLA
{
    align (1):
    uint cbStruct;
    uint dwControlID;
    uint dwControlType;
    uint fdwControl;
    uint cMultipleItems;
    CHAR[16] szShortName;
    CHAR[64] szName;
    union _Bounds_e__Union
    {
        align (1):
        struct
        {
            align (1):
            int lMinimum;
            int lMaximum;
        }
        struct
        {
            align (1):
            uint dwMinimum;
            uint dwMaximum;
        }
        uint[6] dwReserved;
    }
    union _Metrics_e__Union
    {
        align (1):
        uint cSteps;
        uint cbCustomData;
        uint[6] dwReserved;
    }
}
struct MIXERCONTROLW
{
    align (1):
    uint cbStruct;
    uint dwControlID;
    uint dwControlType;
    uint fdwControl;
    uint cMultipleItems;
    wchar[16] szShortName;
    wchar[64] szName;
    union _Bounds_e__Union
    {
        align (1):
        struct
        {
            align (1):
            int lMinimum;
            int lMaximum;
        }
        struct
        {
            align (1):
            uint dwMinimum;
            uint dwMaximum;
        }
        uint[6] dwReserved;
    }
    union _Metrics_e__Union
    {
        align (1):
        uint cSteps;
        uint cbCustomData;
        uint[6] dwReserved;
    }
}
struct MIXERLINECONTROLSA
{
    align (1):
    uint cbStruct;
    uint dwLineID;
    union
    {
        align (1):
        uint dwControlID;
        uint dwControlType;
    }
    uint cControls;
    uint cbmxctrl;
    MIXERCONTROLA* pamxctrl;
}
struct MIXERLINECONTROLSW
{
    align (1):
    uint cbStruct;
    uint dwLineID;
    union
    {
        align (1):
        uint dwControlID;
        uint dwControlType;
    }
    uint cControls;
    uint cbmxctrl;
    MIXERCONTROLW* pamxctrl;
}
struct MIXERCONTROLDETAILS
{
    align (1):
    uint cbStruct;
    uint dwControlID;
    uint cChannels;
    union
    {
        align (1):
        HWND hwndOwner;
        uint cMultipleItems;
    }
    uint cbDetails;
    void* paDetails;
}
struct MIXERCONTROLDETAILS_LISTTEXTA
{
    align (1):
    uint dwParam1;
    uint dwParam2;
    CHAR[64] szName;
}
struct MIXERCONTROLDETAILS_LISTTEXTW
{
    align (1):
    uint dwParam1;
    uint dwParam2;
    wchar[64] szName;
}
struct MIXERCONTROLDETAILS_BOOLEAN
{
    align (1):
    int fValue;
}
struct MIXERCONTROLDETAILS_SIGNED
{
    align (1):
    int lValue;
}
struct MIXERCONTROLDETAILS_UNSIGNED
{
    align (1):
    uint dwValue;
}
alias AUDCLNT_SHAREMODE = int;
enum : int
{
    AUDCLNT_SHAREMODE_SHARED    = 0x00000000,
    AUDCLNT_SHAREMODE_EXCLUSIVE = 0x00000001,
}

alias AUDIO_STREAM_CATEGORY = int;
enum : int
{
    AudioCategory_Other               = 0x00000000,
    AudioCategory_ForegroundOnlyMedia = 0x00000001,
    AudioCategory_Communications      = 0x00000003,
    AudioCategory_Alerts              = 0x00000004,
    AudioCategory_SoundEffects        = 0x00000005,
    AudioCategory_GameEffects         = 0x00000006,
    AudioCategory_GameMedia           = 0x00000007,
    AudioCategory_GameChat            = 0x00000008,
    AudioCategory_Speech              = 0x00000009,
    AudioCategory_Movie               = 0x0000000a,
    AudioCategory_Media               = 0x0000000b,
    AudioCategory_FarFieldSpeech      = 0x0000000c,
    AudioCategory_UniformSpeech       = 0x0000000d,
    AudioCategory_VoiceTyping         = 0x0000000e,
}

alias AudioSessionState = int;
enum : int
{
    AudioSessionStateInactive = 0x00000000,
    AudioSessionStateActive   = 0x00000001,
    AudioSessionStateExpired  = 0x00000002,
}

alias _AUDCLNT_BUFFERFLAGS = int;
enum : int
{
    AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY = 0x00000001,
    AUDCLNT_BUFFERFLAGS_SILENT             = 0x00000002,
    AUDCLNT_BUFFERFLAGS_TIMESTAMP_ERROR    = 0x00000004,
}

alias AUDCLNT_STREAMOPTIONS = uint;
enum : uint
{
    AUDCLNT_STREAMOPTIONS_NONE         = 0x00000000,
    AUDCLNT_STREAMOPTIONS_RAW          = 0x00000001,
    AUDCLNT_STREAMOPTIONS_MATCH_FORMAT = 0x00000002,
    AUDCLNT_STREAMOPTIONS_AMBISONICS   = 0x00000004,
}

struct AudioClientProperties
{
    uint cbSize;
    BOOL bIsOffload;
    AUDIO_STREAM_CATEGORY eCategory;
    AUDCLNT_STREAMOPTIONS Options;
}
enum IID_IAudioClient = GUID(0x1cb9ad4c, 0xdbfa, 0x4c32, [0xb1, 0x78, 0xc2, 0xf5, 0x68, 0xa7, 0x3, 0xb2]);
interface IAudioClient : IUnknown
{
    HRESULT Initialize(AUDCLNT_SHAREMODE, uint, long, long, const(WAVEFORMATEX)*, const(GUID)*);
    HRESULT GetBufferSize(uint*);
    HRESULT GetStreamLatency(long*);
    HRESULT GetCurrentPadding(uint*);
    HRESULT IsFormatSupported(AUDCLNT_SHAREMODE, const(WAVEFORMATEX)*, WAVEFORMATEX**);
    HRESULT GetMixFormat(WAVEFORMATEX**);
    HRESULT GetDevicePeriod(long*, long*);
    HRESULT Start();
    HRESULT Stop();
    HRESULT Reset();
    HRESULT SetEventHandle(HANDLE);
    HRESULT GetService(const(GUID)*, void**);
}
enum IID_IAudioClient2 = GUID(0x726778cd, 0xf60a, 0x4eda, [0x82, 0xde, 0xe4, 0x76, 0x10, 0xcd, 0x78, 0xaa]);
interface IAudioClient2 : IAudioClient
{
    HRESULT IsOffloadCapable(AUDIO_STREAM_CATEGORY, BOOL*);
    HRESULT SetClientProperties(const(AudioClientProperties)*);
    HRESULT GetBufferSizeLimits(const(WAVEFORMATEX)*, BOOL, long*, long*);
}
struct AudioClient3ActivationParams
{
    GUID tracingContextId;
}
enum IID_IAudioClient3 = GUID(0x7ed4ee07, 0x8e67, 0x4cd4, [0x8c, 0x1a, 0x2b, 0x7a, 0x59, 0x87, 0xad, 0x42]);
interface IAudioClient3 : IAudioClient2
{
    HRESULT GetSharedModeEnginePeriod(const(WAVEFORMATEX)*, uint*, uint*, uint*, uint*);
    HRESULT GetCurrentSharedModeEnginePeriod(WAVEFORMATEX**, uint*);
    HRESULT InitializeSharedAudioStream(uint, uint, const(WAVEFORMATEX)*, const(GUID)*);
}
enum IID_IAudioRenderClient = GUID(0xf294acfc, 0x3146, 0x4483, [0xa7, 0xbf, 0xad, 0xdc, 0xa7, 0xc2, 0x60, 0xe2]);
interface IAudioRenderClient : IUnknown
{
    HRESULT GetBuffer(uint, ubyte**);
    HRESULT ReleaseBuffer(uint, uint);
}
enum IID_IAudioCaptureClient = GUID(0xc8adbd64, 0xe71e, 0x48a0, [0xa4, 0xde, 0x18, 0x5c, 0x39, 0x5c, 0xd3, 0x17]);
interface IAudioCaptureClient : IUnknown
{
    HRESULT GetBuffer(ubyte**, uint*, uint*, ulong*, ulong*);
    HRESULT ReleaseBuffer(uint);
    HRESULT GetNextPacketSize(uint*);
}
enum IID_IAudioClock = GUID(0xcd63314f, 0x3fba, 0x4a1b, [0x81, 0x2c, 0xef, 0x96, 0x35, 0x87, 0x28, 0xe7]);
interface IAudioClock : IUnknown
{
    HRESULT GetFrequency(ulong*);
    HRESULT GetPosition(ulong*, ulong*);
    HRESULT GetCharacteristics(uint*);
}
enum IID_IAudioClock2 = GUID(0x6f49ff73, 0x6727, 0x49ac, [0xa0, 0x8, 0xd9, 0x8c, 0xf5, 0xe7, 0x0, 0x48]);
interface IAudioClock2 : IUnknown
{
    HRESULT GetDevicePosition(ulong*, ulong*);
}
enum IID_IAudioClockAdjustment = GUID(0xf6e4c0a0, 0x46d9, 0x4fb8, [0xbe, 0x21, 0x57, 0xa3, 0xef, 0x2b, 0x62, 0x6c]);
interface IAudioClockAdjustment : IUnknown
{
    HRESULT SetSampleRate(float);
}
enum IID_ISimpleAudioVolume = GUID(0x87ce5498, 0x68d6, 0x44e5, [0x92, 0x15, 0x6d, 0xa4, 0x7e, 0xf8, 0x83, 0xd8]);
interface ISimpleAudioVolume : IUnknown
{
    HRESULT SetMasterVolume(float, const(GUID)*);
    HRESULT GetMasterVolume(float*);
    HRESULT SetMute(const(BOOL), const(GUID)*);
    HRESULT GetMute(BOOL*);
}
alias AUDIO_DUCKING_OPTIONS = uint;
enum : uint
{
    AUDIO_DUCKING_OPTIONS_DEFAULT                   = 0x00000000,
    AUDIO_DUCKING_OPTIONS_DO_NOT_DUCK_OTHER_STREAMS = 0x00000001,
}

enum IID_IAudioClientDuckingControl = GUID(0xc789d381, 0xa28c, 0x4168, [0xb2, 0x8f, 0xd3, 0xa8, 0x37, 0x92, 0x4d, 0xc3]);
interface IAudioClientDuckingControl : IUnknown
{
    HRESULT SetDuckingOptionsForCurrentStream(AUDIO_DUCKING_OPTIONS);
}
alias AUDIO_EFFECT_STATE = int;
enum : int
{
    AUDIO_EFFECT_STATE_OFF = 0x00000000,
    AUDIO_EFFECT_STATE_ON  = 0x00000001,
}

struct AUDIO_EFFECT
{
    GUID id;
    BOOL canSetState;
    AUDIO_EFFECT_STATE state;
}
enum IID_IAudioEffectsChangedNotificationClient = GUID(0xa5ded44f, 0x3c5d, 0x4b2b, [0xbd, 0x1e, 0x5d, 0xc1, 0xee, 0x20, 0xbb, 0xf6]);
interface IAudioEffectsChangedNotificationClient : IUnknown
{
    HRESULT OnAudioEffectsChanged();
}
enum IID_IAudioEffectsManager = GUID(0x4460b3ae, 0x4b44, 0x4527, [0x86, 0x76, 0x75, 0x48, 0xa8, 0xac, 0xd2, 0x60]);
interface IAudioEffectsManager : IUnknown
{
    HRESULT RegisterAudioEffectsChangedNotificationCallback(IAudioEffectsChangedNotificationClient);
    HRESULT UnregisterAudioEffectsChangedNotificationCallback(IAudioEffectsChangedNotificationClient);
    HRESULT GetAudioEffects(AUDIO_EFFECT**, uint*);
    HRESULT SetAudioEffectState(GUID, AUDIO_EFFECT_STATE);
}
enum IID_IAudioStreamVolume = GUID(0x93014887, 0x242d, 0x4068, [0x8a, 0x15, 0xcf, 0x5e, 0x93, 0xb9, 0xf, 0xe3]);
interface IAudioStreamVolume : IUnknown
{
    HRESULT GetChannelCount(uint*);
    HRESULT SetChannelVolume(uint, const(float));
    HRESULT GetChannelVolume(uint, float*);
    HRESULT SetAllVolumes(uint, const(float)*);
    HRESULT GetAllVolumes(uint, float*);
}
alias AMBISONICS_TYPE = int;
enum : int
{
    AMBISONICS_TYPE_FULL3D = 0x00000000,
}

alias AMBISONICS_CHANNEL_ORDERING = int;
enum : int
{
    AMBISONICS_CHANNEL_ORDERING_ACN = 0x00000000,
}

alias AMBISONICS_NORMALIZATION = int;
enum : int
{
    AMBISONICS_NORMALIZATION_SN3D = 0x00000000,
    AMBISONICS_NORMALIZATION_N3D  = 0x00000001,
}

struct AMBISONICS_PARAMS
{
    uint u32Size;
    uint u32Version;
    AMBISONICS_TYPE u32Type;
    AMBISONICS_CHANNEL_ORDERING u32ChannelOrdering;
    AMBISONICS_NORMALIZATION u32Normalization;
    uint u32Order;
    uint u32NumChannels;
    uint* pu32ChannelMap;
}
enum IID_IAudioAmbisonicsControl = GUID(0x28724c91, 0xdf35, 0x4856, [0x9f, 0x76, 0xd6, 0xa2, 0x64, 0x13, 0xf3, 0xdf]);
interface IAudioAmbisonicsControl : IUnknown
{
    HRESULT SetData(const(AMBISONICS_PARAMS)*, uint);
    HRESULT SetHeadTracking(BOOL);
    HRESULT GetHeadTracking(BOOL*);
    HRESULT SetRotation(float, float, float, float);
}
enum IID_IChannelAudioVolume = GUID(0x1c158861, 0xb533, 0x4b30, [0xb1, 0xcf, 0xe8, 0x53, 0xe5, 0x1c, 0x59, 0xb8]);
interface IChannelAudioVolume : IUnknown
{
    HRESULT GetChannelCount(uint*);
    HRESULT SetChannelVolume(uint, const(float), const(GUID)*);
    HRESULT GetChannelVolume(uint, float*);
    HRESULT SetAllVolumes(uint, const(float)*, const(GUID)*);
    HRESULT GetAllVolumes(uint, float*);
}
alias AudioObjectType = uint;
enum : uint
{
    AudioObjectType_None             = 0x00000000,
    AudioObjectType_Dynamic          = 0x00000001,
    AudioObjectType_FrontLeft        = 0x00000002,
    AudioObjectType_FrontRight       = 0x00000004,
    AudioObjectType_FrontCenter      = 0x00000008,
    AudioObjectType_LowFrequency     = 0x00000010,
    AudioObjectType_SideLeft         = 0x00000020,
    AudioObjectType_SideRight        = 0x00000040,
    AudioObjectType_BackLeft         = 0x00000080,
    AudioObjectType_BackRight        = 0x00000100,
    AudioObjectType_TopFrontLeft     = 0x00000200,
    AudioObjectType_TopFrontRight    = 0x00000400,
    AudioObjectType_TopBackLeft      = 0x00000800,
    AudioObjectType_TopBackRight     = 0x00001000,
    AudioObjectType_BottomFrontLeft  = 0x00002000,
    AudioObjectType_BottomFrontRight = 0x00004000,
    AudioObjectType_BottomBackLeft   = 0x00008000,
    AudioObjectType_BottomBackRight  = 0x00010000,
    AudioObjectType_BackCenter       = 0x00020000,
}

alias SPATIAL_AUDIO_STREAM_OPTIONS = uint;
enum : uint
{
    SPATIAL_AUDIO_STREAM_OPTIONS_NONE    = 0x00000000,
    SPATIAL_AUDIO_STREAM_OPTIONS_OFFLOAD = 0x00000001,
}

struct SpatialAudioObjectRenderStreamActivationParams
{
    align (1):
    const(WAVEFORMATEX)* ObjectFormat;
    AudioObjectType StaticObjectTypeMask;
    uint MinDynamicObjectCount;
    uint MaxDynamicObjectCount;
    AUDIO_STREAM_CATEGORY Category;
    HANDLE EventHandle;
    ISpatialAudioObjectRenderStreamNotify NotifyObject;
}
struct SpatialAudioObjectRenderStreamActivationParams2
{
    align (1):
    const(WAVEFORMATEX)* ObjectFormat;
    AudioObjectType StaticObjectTypeMask;
    uint MinDynamicObjectCount;
    uint MaxDynamicObjectCount;
    AUDIO_STREAM_CATEGORY Category;
    HANDLE EventHandle;
    ISpatialAudioObjectRenderStreamNotify NotifyObject;
    SPATIAL_AUDIO_STREAM_OPTIONS Options;
}
enum IID_IAudioFormatEnumerator = GUID(0xdcdaa858, 0x895a, 0x4a22, [0xa5, 0xeb, 0x67, 0xbd, 0xa5, 0x6, 0x9, 0x6d]);
interface IAudioFormatEnumerator : IUnknown
{
    HRESULT GetCount(uint*);
    HRESULT GetFormat(uint, WAVEFORMATEX**);
}
enum IID_ISpatialAudioObjectBase = GUID(0xcce0b8f2, 0x8d4d, 0x4efb, [0xa8, 0xcf, 0x3d, 0x6e, 0xcf, 0x1c, 0x30, 0xe0]);
interface ISpatialAudioObjectBase : IUnknown
{
    HRESULT GetBuffer(ubyte**, uint*);
    HRESULT SetEndOfStream(uint);
    HRESULT IsActive(BOOL*);
    HRESULT GetAudioObjectType(AudioObjectType*);
}
enum IID_ISpatialAudioObject = GUID(0xdde28967, 0x521b, 0x46e5, [0x8f, 0x0, 0xbd, 0x6f, 0x2b, 0xc8, 0xab, 0x1d]);
interface ISpatialAudioObject : ISpatialAudioObjectBase
{
    HRESULT SetPosition(float, float, float);
    HRESULT SetVolume(float);
}
enum IID_ISpatialAudioObjectRenderStreamBase = GUID(0xfeaaf403, 0xc1d8, 0x450d, [0xaa, 0x5, 0xe0, 0xcc, 0xee, 0x75, 0x2, 0xa8]);
interface ISpatialAudioObjectRenderStreamBase : IUnknown
{
    HRESULT GetAvailableDynamicObjectCount(uint*);
    HRESULT GetService(const(GUID)*, void**);
    HRESULT Start();
    HRESULT Stop();
    HRESULT Reset();
    HRESULT BeginUpdatingAudioObjects(uint*, uint*);
    HRESULT EndUpdatingAudioObjects();
}
enum IID_ISpatialAudioObjectRenderStream = GUID(0xbab5f473, 0xb423, 0x477b, [0x85, 0xf5, 0xb5, 0xa3, 0x32, 0xa0, 0x41, 0x53]);
interface ISpatialAudioObjectRenderStream : ISpatialAudioObjectRenderStreamBase
{
    HRESULT ActivateSpatialAudioObject(AudioObjectType, ISpatialAudioObject*);
}
enum IID_ISpatialAudioObjectRenderStreamNotify = GUID(0xdddf83e6, 0x68d7, 0x4c70, [0x88, 0x3f, 0xa1, 0x83, 0x6a, 0xfb, 0x4a, 0x50]);
interface ISpatialAudioObjectRenderStreamNotify : IUnknown
{
    HRESULT OnAvailableDynamicObjectCountChange(ISpatialAudioObjectRenderStreamBase, long, uint);
}
enum IID_ISpatialAudioClient = GUID(0xbbf8e066, 0xaaaa, 0x49be, [0x9a, 0x4d, 0xfd, 0x2a, 0x85, 0x8e, 0xa2, 0x7f]);
interface ISpatialAudioClient : IUnknown
{
    HRESULT GetStaticObjectPosition(AudioObjectType, float*, float*, float*);
    HRESULT GetNativeStaticObjectTypeMask(AudioObjectType*);
    HRESULT GetMaxDynamicObjectCount(uint*);
    HRESULT GetSupportedAudioObjectFormatEnumerator(IAudioFormatEnumerator*);
    HRESULT GetMaxFrameCount(const(WAVEFORMATEX)*, uint*);
    HRESULT IsAudioObjectFormatSupported(const(WAVEFORMATEX)*);
    HRESULT IsSpatialAudioStreamAvailable(const(GUID)*, const(PROPVARIANT)*);
    HRESULT ActivateSpatialAudioStream(const(PROPVARIANT)*, const(GUID)*, void**);
}
enum IID_ISpatialAudioClient2 = GUID(0xcaabe452, 0xa66a, 0x4bee, [0xa9, 0x3e, 0xe3, 0x20, 0x46, 0x3f, 0x6a, 0x53]);
interface ISpatialAudioClient2 : ISpatialAudioClient
{
    HRESULT IsOffloadCapable(AUDIO_STREAM_CATEGORY, BOOL*);
    HRESULT GetMaxFrameCountForCategory(AUDIO_STREAM_CATEGORY, BOOL, const(WAVEFORMATEX)*, uint*);
}
struct SpatialAudioClientActivationParams
{
    GUID tracingContextId;
    GUID appId;
    int majorVersion;
    int minorVersion1;
    int minorVersion2;
    int minorVersion3;
}
alias SpatialAudioHrtfDirectivityType = int;
enum : int
{
    SpatialAudioHrtfDirectivity_OmniDirectional = 0x00000000,
    SpatialAudioHrtfDirectivity_Cardioid        = 0x00000001,
    SpatialAudioHrtfDirectivity_Cone            = 0x00000002,
}

alias SpatialAudioHrtfEnvironmentType = int;
enum : int
{
    SpatialAudioHrtfEnvironment_Small    = 0x00000000,
    SpatialAudioHrtfEnvironment_Medium   = 0x00000001,
    SpatialAudioHrtfEnvironment_Large    = 0x00000002,
    SpatialAudioHrtfEnvironment_Outdoors = 0x00000003,
    SpatialAudioHrtfEnvironment_Average  = 0x00000004,
}

alias SpatialAudioHrtfDistanceDecayType = int;
enum : int
{
    SpatialAudioHrtfDistanceDecay_NaturalDecay = 0x00000000,
    SpatialAudioHrtfDistanceDecay_CustomDecay  = 0x00000001,
}

struct SpatialAudioHrtfDirectivity
{
    align (1):
    SpatialAudioHrtfDirectivityType Type;
    float Scaling;
}
struct SpatialAudioHrtfDirectivityCardioid
{
    align (1):
    SpatialAudioHrtfDirectivity directivity;
    float Order;
}
struct SpatialAudioHrtfDirectivityCone
{
    align (1):
    SpatialAudioHrtfDirectivity directivity;
    float InnerAngle;
    float OuterAngle;
}
union SpatialAudioHrtfDirectivityUnion
{
    SpatialAudioHrtfDirectivityCone Cone;
    SpatialAudioHrtfDirectivityCardioid Cardiod;
    SpatialAudioHrtfDirectivity Omni;
}
struct SpatialAudioHrtfDistanceDecay
{
    align (1):
    SpatialAudioHrtfDistanceDecayType Type;
    float MaxGain;
    float MinGain;
    float UnityGainDistance;
    float CutoffDistance;
}
struct SpatialAudioHrtfActivationParams
{
    align (1):
    const(WAVEFORMATEX)* ObjectFormat;
    AudioObjectType StaticObjectTypeMask;
    uint MinDynamicObjectCount;
    uint MaxDynamicObjectCount;
    AUDIO_STREAM_CATEGORY Category;
    HANDLE EventHandle;
    ISpatialAudioObjectRenderStreamNotify NotifyObject;
    SpatialAudioHrtfDistanceDecay* DistanceDecay;
    SpatialAudioHrtfDirectivityUnion* Directivity;
    SpatialAudioHrtfEnvironmentType* Environment;
    float* Orientation;
}
struct SpatialAudioHrtfActivationParams2
{
    align (1):
    const(WAVEFORMATEX)* ObjectFormat;
    AudioObjectType StaticObjectTypeMask;
    uint MinDynamicObjectCount;
    uint MaxDynamicObjectCount;
    AUDIO_STREAM_CATEGORY Category;
    HANDLE EventHandle;
    ISpatialAudioObjectRenderStreamNotify NotifyObject;
    SpatialAudioHrtfDistanceDecay* DistanceDecay;
    SpatialAudioHrtfDirectivityUnion* Directivity;
    SpatialAudioHrtfEnvironmentType* Environment;
    float* Orientation;
    SPATIAL_AUDIO_STREAM_OPTIONS Options;
}
enum IID_ISpatialAudioObjectForHrtf = GUID(0xd7436ade, 0x1978, 0x4e14, [0xab, 0xa0, 0x55, 0x5b, 0xd8, 0xeb, 0x83, 0xb4]);
interface ISpatialAudioObjectForHrtf : ISpatialAudioObjectBase
{
    HRESULT SetPosition(float, float, float);
    HRESULT SetGain(float);
    HRESULT SetOrientation(const(float)**);
    HRESULT SetEnvironment(SpatialAudioHrtfEnvironmentType);
    HRESULT SetDistanceDecay(SpatialAudioHrtfDistanceDecay*);
    HRESULT SetDirectivity(SpatialAudioHrtfDirectivityUnion*);
}
enum IID_ISpatialAudioObjectRenderStreamForHrtf = GUID(0xe08deef9, 0x5363, 0x406e, [0x9f, 0xdc, 0x8, 0xe, 0xe2, 0x47, 0xbb, 0xe0]);
interface ISpatialAudioObjectRenderStreamForHrtf : ISpatialAudioObjectRenderStreamBase
{
    HRESULT ActivateSpatialAudioObjectForHrtf(AudioObjectType, ISpatialAudioObjectForHrtf*);
}
enum CLSID_MMDeviceEnumerator = GUID(0xbcde0395, 0xe52f, 0x467c, [0x8e, 0x3d, 0xc4, 0x57, 0x92, 0x91, 0x69, 0x2e]);
struct MMDeviceEnumerator
{
}
struct DIRECTX_AUDIO_ACTIVATION_PARAMS
{
    uint cbDirectXAudioActivationParams;
    GUID guidAudioSession;
    uint dwAudioStreamFlags;
}
alias EDataFlow = int;
enum : int
{
    eRender              = 0x00000000,
    eCapture             = 0x00000001,
    eAll                 = 0x00000002,
    EDataFlow_enum_count = 0x00000003,
}

alias ERole = int;
enum : int
{
    eConsole         = 0x00000000,
    eMultimedia      = 0x00000001,
    eCommunications  = 0x00000002,
    ERole_enum_count = 0x00000003,
}

alias EndpointFormFactor = int;
enum : int
{
    RemoteNetworkDevice           = 0x00000000,
    Speakers                      = 0x00000001,
    LineLevel                     = 0x00000002,
    Headphones                    = 0x00000003,
    Microphone                    = 0x00000004,
    Headset                       = 0x00000005,
    Handset                       = 0x00000006,
    UnknownDigitalPassthrough     = 0x00000007,
    SPDIF                         = 0x00000008,
    DigitalAudioDisplayDevice     = 0x00000009,
    UnknownFormFactor             = 0x0000000a,
    EndpointFormFactor_enum_count = 0x0000000b,
}

enum IID_IMMNotificationClient = GUID(0x7991eec9, 0x7e89, 0x4d85, [0x83, 0x90, 0x6c, 0x70, 0x3c, 0xec, 0x60, 0xc0]);
interface IMMNotificationClient : IUnknown
{
    HRESULT OnDeviceStateChanged(const(wchar)*, uint);
    HRESULT OnDeviceAdded(const(wchar)*);
    HRESULT OnDeviceRemoved(const(wchar)*);
    HRESULT OnDefaultDeviceChanged(EDataFlow, ERole, const(wchar)*);
    HRESULT OnPropertyValueChanged(const(wchar)*, const(PROPERTYKEY));
}
enum IID_IMMDevice = GUID(0xd666063f, 0x1587, 0x4e43, [0x81, 0xf1, 0xb9, 0x48, 0xe8, 0x7, 0x36, 0x3f]);
interface IMMDevice : IUnknown
{
    HRESULT Activate(const(GUID)*, CLSCTX, PROPVARIANT*, void**);
    HRESULT OpenPropertyStore(STGM, IPropertyStore*);
    HRESULT GetId(PWSTR*);
    HRESULT GetState(uint*);
}
enum IID_IMMDeviceCollection = GUID(0xbd7a1be, 0x7a1a, 0x44db, [0x83, 0x97, 0xcc, 0x53, 0x92, 0x38, 0x7b, 0x5e]);
interface IMMDeviceCollection : IUnknown
{
    HRESULT GetCount(uint*);
    HRESULT Item(uint, IMMDevice*);
}
enum IID_IMMEndpoint = GUID(0x1be09788, 0x6894, 0x4089, [0x85, 0x86, 0x9a, 0x2a, 0x6c, 0x26, 0x5a, 0xc5]);
interface IMMEndpoint : IUnknown
{
    HRESULT GetDataFlow(EDataFlow*);
}
enum IID_IMMDeviceEnumerator = GUID(0xa95664d2, 0x9614, 0x4f35, [0xa7, 0x46, 0xde, 0x8d, 0xb6, 0x36, 0x17, 0xe6]);
interface IMMDeviceEnumerator : IUnknown
{
    HRESULT EnumAudioEndpoints(EDataFlow, uint, IMMDeviceCollection*);
    HRESULT GetDefaultAudioEndpoint(EDataFlow, ERole, IMMDevice*);
    HRESULT GetDevice(const(wchar)*, IMMDevice*);
    HRESULT RegisterEndpointNotificationCallback(IMMNotificationClient);
    HRESULT UnregisterEndpointNotificationCallback(IMMNotificationClient);
}
enum IID_IMMDeviceActivator = GUID(0x3b0d0ea4, 0xd0a9, 0x4b0e, [0x93, 0x5b, 0x9, 0x51, 0x67, 0x46, 0xfa, 0xc0]);
interface IMMDeviceActivator : IUnknown
{
    HRESULT Activate(const(GUID)*, IMMDevice, PROPVARIANT*, void**);
}
enum IID_IActivateAudioInterfaceCompletionHandler = GUID(0x41d949ab, 0x9862, 0x444a, [0x80, 0xf6, 0xc2, 0x61, 0x33, 0x4d, 0xa5, 0xeb]);
interface IActivateAudioInterfaceCompletionHandler : IUnknown
{
    HRESULT ActivateCompleted(IActivateAudioInterfaceAsyncOperation);
}
enum IID_IActivateAudioInterfaceAsyncOperation = GUID(0x72a22d78, 0xcde4, 0x431d, [0xb8, 0xcc, 0x84, 0x3a, 0x71, 0x19, 0x9b, 0x6d]);
interface IActivateAudioInterfaceAsyncOperation : IUnknown
{
    HRESULT GetActivateResult(HRESULT*, IUnknown*);
}
struct AudioExtensionParams
{
    LPARAM AddPageParam;
    IMMDevice pEndpoint;
    IMMDevice pPnpInterface;
    IMMDevice pPnpDevnode;
}
alias AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE = int;
enum : int
{
    AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_DEFAULT    = 0x00000000,
    AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_USER       = 0x00000001,
    AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_VOLATILE   = 0x00000002,
    AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_ENUM_COUNT = 0x00000003,
}

enum IID_IAudioSystemEffectsPropertyChangeNotificationClient = GUID(0x20049d40, 0x56d5, 0x400e, [0xa2, 0xef, 0x38, 0x55, 0x99, 0xfe, 0xed, 0x49]);
interface IAudioSystemEffectsPropertyChangeNotificationClient : IUnknown
{
    HRESULT OnPropertyChanged(AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE, const(PROPERTYKEY));
}
enum IID_IAudioSystemEffectsPropertyStore = GUID(0x302ae7f9, 0xd7e0, 0x43e4, [0x97, 0x1b, 0x1f, 0x82, 0x93, 0x61, 0x3d, 0x2a]);
interface IAudioSystemEffectsPropertyStore : IUnknown
{
    HRESULT OpenDefaultPropertyStore(uint, IPropertyStore*);
    HRESULT OpenUserPropertyStore(uint, IPropertyStore*);
    HRESULT OpenVolatilePropertyStore(uint, IPropertyStore*);
    HRESULT ResetUserPropertyStore();
    HRESULT ResetVolatilePropertyStore();
    HRESULT RegisterPropertyChangeNotification(IAudioSystemEffectsPropertyChangeNotificationClient);
    HRESULT UnregisterPropertyChangeNotification(IAudioSystemEffectsPropertyChangeNotificationClient);
}
enum CLSID_DeviceTopology = GUID(0x1df639d0, 0x5ec1, 0x47aa, [0x93, 0x79, 0x82, 0x8d, 0xc1, 0xaa, 0x8c, 0x59]);
struct DeviceTopology
{
}
alias DataFlow = int;
enum : int
{
    In      = 0x00000000,
    Out     = 0x00000001,
}

alias PartType = int;
enum : int
{
    Connector = 0x00000000,
    Subunit   = 0x00000001,
}

alias ConnectorType = int;
enum : int
{
    Unknown_Connector = 0x00000000,
    Physical_Internal = 0x00000001,
    Physical_External = 0x00000002,
    Software_IO       = 0x00000003,
    Software_Fixed    = 0x00000004,
    Network           = 0x00000005,
}

enum IID_IPerChannelDbLevel = GUID(0xc2f8e001, 0xf205, 0x4bc9, [0x99, 0xbc, 0xc1, 0x3b, 0x1e, 0x4, 0x8c, 0xcb]);
interface IPerChannelDbLevel : IUnknown
{
    HRESULT GetChannelCount(uint*);
    HRESULT GetLevelRange(uint, float*, float*, float*);
    HRESULT GetLevel(uint, float*);
    HRESULT SetLevel(uint, float, const(GUID)*);
    HRESULT SetLevelUniform(float, const(GUID)*);
    HRESULT SetLevelAllChannels(float*, uint, const(GUID)*);
}
enum IID_IAudioVolumeLevel = GUID(0x7fb7b48f, 0x531d, 0x44a2, [0xbc, 0xb3, 0x5a, 0xd5, 0xa1, 0x34, 0xb3, 0xdc]);
interface IAudioVolumeLevel : IPerChannelDbLevel
{
}
enum IID_IAudioChannelConfig = GUID(0xbb11c46f, 0xec28, 0x493c, [0xb8, 0x8a, 0x5d, 0xb8, 0x80, 0x62, 0xce, 0x98]);
interface IAudioChannelConfig : IUnknown
{
    HRESULT SetChannelConfig(uint, const(GUID)*);
    HRESULT GetChannelConfig(uint*);
}
enum IID_IAudioLoudness = GUID(0x7d8b1437, 0xdd53, 0x4350, [0x9c, 0x1b, 0x1e, 0xe2, 0x89, 0xb, 0xd9, 0x38]);
interface IAudioLoudness : IUnknown
{
    HRESULT GetEnabled(BOOL*);
    HRESULT SetEnabled(BOOL, const(GUID)*);
}
enum IID_IAudioInputSelector = GUID(0x4f03dc02, 0x5e6e, 0x4653, [0x8f, 0x72, 0xa0, 0x30, 0xc1, 0x23, 0xd5, 0x98]);
interface IAudioInputSelector : IUnknown
{
    HRESULT GetSelection(uint*);
    HRESULT SetSelection(uint, const(GUID)*);
}
enum IID_IAudioOutputSelector = GUID(0xbb515f69, 0x94a7, 0x429e, [0x8b, 0x9c, 0x27, 0x1b, 0x3f, 0x11, 0xa3, 0xab]);
interface IAudioOutputSelector : IUnknown
{
    HRESULT GetSelection(uint*);
    HRESULT SetSelection(uint, const(GUID)*);
}
enum IID_IAudioMute = GUID(0xdf45aeea, 0xb74a, 0x4b6b, [0xaf, 0xad, 0x23, 0x66, 0xb6, 0xaa, 0x1, 0x2e]);
interface IAudioMute : IUnknown
{
    HRESULT SetMute(BOOL, const(GUID)*);
    HRESULT GetMute(BOOL*);
}
enum IID_IAudioBass = GUID(0xa2b1a1d9, 0x4db3, 0x425d, [0xa2, 0xb2, 0xbd, 0x33, 0x5c, 0xb3, 0xe2, 0xe5]);
interface IAudioBass : IPerChannelDbLevel
{
}
enum IID_IAudioMidrange = GUID(0x5e54b6d7, 0xb44b, 0x40d9, [0x9a, 0x9e, 0xe6, 0x91, 0xd9, 0xce, 0x6e, 0xdf]);
interface IAudioMidrange : IPerChannelDbLevel
{
}
enum IID_IAudioTreble = GUID(0xa717812, 0x694e, 0x4907, [0xb7, 0x4b, 0xba, 0xfa, 0x5c, 0xfd, 0xca, 0x7b]);
interface IAudioTreble : IPerChannelDbLevel
{
}
enum IID_IAudioAutoGainControl = GUID(0x85401fd4, 0x6de4, 0x4b9d, [0x98, 0x69, 0x2d, 0x67, 0x53, 0xa8, 0x2f, 0x3c]);
interface IAudioAutoGainControl : IUnknown
{
    HRESULT GetEnabled(BOOL*);
    HRESULT SetEnabled(BOOL, const(GUID)*);
}
enum IID_IAudioPeakMeter = GUID(0xdd79923c, 0x599, 0x45e0, [0xb8, 0xb6, 0xc8, 0xdf, 0x7d, 0xb6, 0xe7, 0x96]);
interface IAudioPeakMeter : IUnknown
{
    HRESULT GetChannelCount(uint*);
    HRESULT GetLevel(uint, float*);
}
enum IID_IDeviceSpecificProperty = GUID(0x3b22bcbf, 0x2586, 0x4af0, [0x85, 0x83, 0x20, 0x5d, 0x39, 0x1b, 0x80, 0x7c]);
interface IDeviceSpecificProperty : IUnknown
{
    HRESULT GetType(ushort*);
    HRESULT GetValue(void*, uint*);
    HRESULT SetValue(void*, uint, const(GUID)*);
    HRESULT Get4BRange(int*, int*, int*);
}
enum IID_IPartsList = GUID(0x6daa848c, 0x5eb0, 0x45cc, [0xae, 0xa5, 0x99, 0x8a, 0x2c, 0xda, 0x1f, 0xfb]);
interface IPartsList : IUnknown
{
    HRESULT GetCount(uint*);
    HRESULT GetPart(uint, IPart*);
}
enum IID_IPart = GUID(0xae2de0e4, 0x5bca, 0x4f2d, [0xaa, 0x46, 0x5d, 0x13, 0xf8, 0xfd, 0xb3, 0xa9]);
interface IPart : IUnknown
{
    HRESULT GetName(PWSTR*);
    HRESULT GetLocalId(uint*);
    HRESULT GetGlobalId(PWSTR*);
    HRESULT GetPartType(PartType*);
    HRESULT GetSubType(GUID*);
    HRESULT GetControlInterfaceCount(uint*);
    HRESULT GetControlInterface(uint, IControlInterface*);
    HRESULT EnumPartsIncoming(IPartsList*);
    HRESULT EnumPartsOutgoing(IPartsList*);
    HRESULT GetTopologyObject(IDeviceTopology*);
    HRESULT Activate(uint, const(GUID)*, void**);
    HRESULT RegisterControlChangeCallback(const(GUID)*, IControlChangeNotify);
    HRESULT UnregisterControlChangeCallback(IControlChangeNotify);
}
enum IID_IConnector = GUID(0x9c2c4058, 0x23f5, 0x41de, [0x87, 0x7a, 0xdf, 0x3a, 0xf2, 0x36, 0xa0, 0x9e]);
interface IConnector : IUnknown
{
    HRESULT GetType(ConnectorType*);
    HRESULT GetDataFlow(DataFlow*);
    HRESULT ConnectTo(IConnector);
    HRESULT Disconnect();
    HRESULT IsConnected(BOOL*);
    HRESULT GetConnectedTo(IConnector*);
    HRESULT GetConnectorIdConnectedTo(PWSTR*);
    HRESULT GetDeviceIdConnectedTo(PWSTR*);
}
enum IID_ISubunit = GUID(0x82149a85, 0xdba6, 0x4487, [0x86, 0xbb, 0xea, 0x8f, 0x7f, 0xef, 0xcc, 0x71]);
interface ISubunit : IUnknown
{
}
enum IID_IControlInterface = GUID(0x45d37c3f, 0x5140, 0x444a, [0xae, 0x24, 0x40, 0x7, 0x89, 0xf3, 0xcb, 0xf3]);
interface IControlInterface : IUnknown
{
    HRESULT GetName(PWSTR*);
    HRESULT GetIID(GUID*);
}
enum IID_IControlChangeNotify = GUID(0xa09513ed, 0xc709, 0x4d21, [0xbd, 0x7b, 0x5f, 0x34, 0xc4, 0x7f, 0x39, 0x47]);
interface IControlChangeNotify : IUnknown
{
    HRESULT OnNotify(uint, const(GUID)*);
}
enum IID_IDeviceTopology = GUID(0x2a07407e, 0x6497, 0x4a18, [0x97, 0x87, 0x32, 0xf7, 0x9b, 0xd0, 0xd9, 0x8f]);
interface IDeviceTopology : IUnknown
{
    HRESULT GetConnectorCount(uint*);
    HRESULT GetConnector(uint, IConnector*);
    HRESULT GetSubunitCount(uint*);
    HRESULT GetSubunit(uint, ISubunit*);
    HRESULT GetPartById(uint, IPart*);
    HRESULT GetDeviceId(PWSTR*);
    HRESULT GetSignalPath(IPart, IPart, BOOL, IPartsList*);
}
alias AudioSessionDisconnectReason = int;
enum : int
{
    DisconnectReasonDeviceRemoval         = 0x00000000,
    DisconnectReasonServerShutdown        = 0x00000001,
    DisconnectReasonFormatChanged         = 0x00000002,
    DisconnectReasonSessionLogoff         = 0x00000003,
    DisconnectReasonSessionDisconnected   = 0x00000004,
    DisconnectReasonExclusiveModeOverride = 0x00000005,
}

enum IID_IAudioSessionEvents = GUID(0x24918acc, 0x64b3, 0x37c1, [0x8c, 0xa9, 0x74, 0xa6, 0x6e, 0x99, 0x57, 0xa8]);
interface IAudioSessionEvents : IUnknown
{
    HRESULT OnDisplayNameChanged(const(wchar)*, const(GUID)*);
    HRESULT OnIconPathChanged(const(wchar)*, const(GUID)*);
    HRESULT OnSimpleVolumeChanged(float, BOOL, const(GUID)*);
    HRESULT OnChannelVolumeChanged(uint, float*, uint, const(GUID)*);
    HRESULT OnGroupingParamChanged(const(GUID)*, const(GUID)*);
    HRESULT OnStateChanged(AudioSessionState);
    HRESULT OnSessionDisconnected(AudioSessionDisconnectReason);
}
enum IID_IAudioSessionControl = GUID(0xf4b1a599, 0x7266, 0x4319, [0xa8, 0xca, 0xe7, 0xa, 0xcb, 0x11, 0xe8, 0xcd]);
interface IAudioSessionControl : IUnknown
{
    HRESULT GetState(AudioSessionState*);
    HRESULT GetDisplayName(PWSTR*);
    HRESULT SetDisplayName(const(wchar)*, const(GUID)*);
    HRESULT GetIconPath(PWSTR*);
    HRESULT SetIconPath(const(wchar)*, const(GUID)*);
    HRESULT GetGroupingParam(GUID*);
    HRESULT SetGroupingParam(const(GUID)*, const(GUID)*);
    HRESULT RegisterAudioSessionNotification(IAudioSessionEvents);
    HRESULT UnregisterAudioSessionNotification(IAudioSessionEvents);
}
enum IID_IAudioSessionControl2 = GUID(0xbfb7ff88, 0x7239, 0x4fc9, [0x8f, 0xa2, 0x7, 0xc9, 0x50, 0xbe, 0x9c, 0x6d]);
interface IAudioSessionControl2 : IAudioSessionControl
{
    HRESULT GetSessionIdentifier(PWSTR*);
    HRESULT GetSessionInstanceIdentifier(PWSTR*);
    HRESULT GetProcessId(uint*);
    HRESULT IsSystemSoundsSession();
    HRESULT SetDuckingPreference(BOOL);
}
enum IID_IAudioSessionManager = GUID(0xbfa971f1, 0x4d5e, 0x40bb, [0x93, 0x5e, 0x96, 0x70, 0x39, 0xbf, 0xbe, 0xe4]);
interface IAudioSessionManager : IUnknown
{
    HRESULT GetAudioSessionControl(const(GUID)*, uint, IAudioSessionControl*);
    HRESULT GetSimpleAudioVolume(const(GUID)*, uint, ISimpleAudioVolume*);
}
enum IID_IAudioVolumeDuckNotification = GUID(0xc3b284d4, 0x6d39, 0x4359, [0xb3, 0xcf, 0xb5, 0x6d, 0xdb, 0x3b, 0xb3, 0x9c]);
interface IAudioVolumeDuckNotification : IUnknown
{
    HRESULT OnVolumeDuckNotification(const(wchar)*, uint);
    HRESULT OnVolumeUnduckNotification(const(wchar)*);
}
enum IID_IAudioSessionNotification = GUID(0x641dd20b, 0x4d41, 0x49cc, [0xab, 0xa3, 0x17, 0x4b, 0x94, 0x77, 0xbb, 0x8]);
interface IAudioSessionNotification : IUnknown
{
    HRESULT OnSessionCreated(IAudioSessionControl);
}
enum IID_IAudioSessionEnumerator = GUID(0xe2f5bb11, 0x570, 0x40ca, [0xac, 0xdd, 0x3a, 0xa0, 0x12, 0x77, 0xde, 0xe8]);
interface IAudioSessionEnumerator : IUnknown
{
    HRESULT GetCount(int*);
    HRESULT GetSession(int, IAudioSessionControl*);
}
enum IID_IAudioSessionManager2 = GUID(0x77aa99a0, 0x1bd6, 0x484f, [0x8b, 0xc7, 0x2c, 0x65, 0x4c, 0x9a, 0x9b, 0x6f]);
interface IAudioSessionManager2 : IAudioSessionManager
{
    HRESULT GetSessionEnumerator(IAudioSessionEnumerator*);
    HRESULT RegisterSessionNotification(IAudioSessionNotification);
    HRESULT UnregisterSessionNotification(IAudioSessionNotification);
    HRESULT RegisterDuckNotification(const(wchar)*, IAudioVolumeDuckNotification);
    HRESULT UnregisterDuckNotification(IAudioVolumeDuckNotification);
}
alias SpatialAudioMetadataWriterOverflowMode = int;
enum : int
{
    SpatialAudioMetadataWriterOverflow_Fail          = 0x00000000,
    SpatialAudioMetadataWriterOverflow_MergeWithNew  = 0x00000001,
    SpatialAudioMetadataWriterOverflow_MergeWithLast = 0x00000002,
}

alias SpatialAudioMetadataCopyMode = int;
enum : int
{
    SpatialAudioMetadataCopy_Overwrite            = 0x00000000,
    SpatialAudioMetadataCopy_Append               = 0x00000001,
    SpatialAudioMetadataCopy_AppendMergeWithLast  = 0x00000002,
    SpatialAudioMetadataCopy_AppendMergeWithFirst = 0x00000003,
}

struct SpatialAudioMetadataItemsInfo
{
    align (1):
    ushort FrameCount;
    ushort ItemCount;
    ushort MaxItemCount;
    uint MaxValueBufferLength;
}
struct SpatialAudioObjectRenderStreamForMetadataActivationParams
{
    align (1):
    const(WAVEFORMATEX)* ObjectFormat;
    AudioObjectType StaticObjectTypeMask;
    uint MinDynamicObjectCount;
    uint MaxDynamicObjectCount;
    AUDIO_STREAM_CATEGORY Category;
    HANDLE EventHandle;
    GUID MetadataFormatId;
    ushort MaxMetadataItemCount;
    const(PROPVARIANT)* MetadataActivationParams;
    ISpatialAudioObjectRenderStreamNotify NotifyObject;
}
struct SpatialAudioObjectRenderStreamForMetadataActivationParams2
{
    align (1):
    const(WAVEFORMATEX)* ObjectFormat;
    AudioObjectType StaticObjectTypeMask;
    uint MinDynamicObjectCount;
    uint MaxDynamicObjectCount;
    AUDIO_STREAM_CATEGORY Category;
    HANDLE EventHandle;
    GUID MetadataFormatId;
    uint MaxMetadataItemCount;
    const(PROPVARIANT)* MetadataActivationParams;
    ISpatialAudioObjectRenderStreamNotify NotifyObject;
    SPATIAL_AUDIO_STREAM_OPTIONS Options;
}
enum IID_ISpatialAudioMetadataItems = GUID(0xbcd7c78f, 0x3098, 0x4f22, [0xb5, 0x47, 0xa2, 0xf2, 0x5a, 0x38, 0x12, 0x69]);
interface ISpatialAudioMetadataItems : IUnknown
{
    HRESULT GetFrameCount(ushort*);
    HRESULT GetItemCount(ushort*);
    HRESULT GetMaxItemCount(ushort*);
    HRESULT GetMaxValueBufferLength(uint*);
    HRESULT GetInfo(SpatialAudioMetadataItemsInfo*);
}
enum IID_ISpatialAudioMetadataWriter = GUID(0x1b17ca01, 0x2955, 0x444d, [0xa4, 0x30, 0x53, 0x7d, 0xc5, 0x89, 0xa8, 0x44]);
interface ISpatialAudioMetadataWriter : IUnknown
{
    HRESULT Open(ISpatialAudioMetadataItems);
    HRESULT WriteNextItem(ushort);
    HRESULT WriteNextItemCommand(ubyte, const(void)*, uint);
    HRESULT Close();
}
enum IID_ISpatialAudioMetadataReader = GUID(0xb78e86a2, 0x31d9, 0x4c32, [0x94, 0xd2, 0x7d, 0xf4, 0xf, 0xc7, 0xeb, 0xec]);
interface ISpatialAudioMetadataReader : IUnknown
{
    HRESULT Open(ISpatialAudioMetadataItems);
    HRESULT ReadNextItem(ubyte*, ushort*);
    HRESULT ReadNextItemCommand(ubyte*, void*, uint, uint*);
    HRESULT Close();
}
enum IID_ISpatialAudioMetadataCopier = GUID(0xd224b233, 0xe251, 0x4fd0, [0x9c, 0xa2, 0xd5, 0xec, 0xf9, 0xa6, 0x84, 0x4]);
interface ISpatialAudioMetadataCopier : IUnknown
{
    HRESULT Open(ISpatialAudioMetadataItems);
    HRESULT CopyMetadataForFrames(ushort, SpatialAudioMetadataCopyMode, ISpatialAudioMetadataItems, ushort*);
    HRESULT Close();
}
enum IID_ISpatialAudioMetadataItemsBuffer = GUID(0x42640a16, 0xe1bd, 0x42d9, [0x9f, 0xf6, 0x3, 0x1a, 0xb7, 0x1a, 0x2d, 0xba]);
interface ISpatialAudioMetadataItemsBuffer : IUnknown
{
    HRESULT AttachToBuffer(ubyte*, uint);
    HRESULT AttachToPopulatedBuffer(ubyte*, uint);
    HRESULT DetachBuffer();
}
enum IID_ISpatialAudioMetadataClient = GUID(0x777d4a3b, 0xf6ff, 0x4a26, [0x85, 0xdc, 0x68, 0xd7, 0xcd, 0xed, 0xa1, 0xd4]);
interface ISpatialAudioMetadataClient : IUnknown
{
    HRESULT ActivateSpatialAudioMetadataItems(ushort, ushort, ISpatialAudioMetadataItemsBuffer*, ISpatialAudioMetadataItems*);
    HRESULT GetSpatialAudioMetadataItemsBufferLength(ushort, uint*);
    HRESULT ActivateSpatialAudioMetadataWriter(SpatialAudioMetadataWriterOverflowMode, ISpatialAudioMetadataWriter*);
    HRESULT ActivateSpatialAudioMetadataCopier(ISpatialAudioMetadataCopier*);
    HRESULT ActivateSpatialAudioMetadataReader(ISpatialAudioMetadataReader*);
}
enum IID_ISpatialAudioObjectForMetadataCommands = GUID(0xdf2c94b, 0xf5f9, 0x472d, [0xaf, 0x6b, 0xc4, 0x6e, 0xa, 0xc9, 0xcd, 0x5]);
interface ISpatialAudioObjectForMetadataCommands : ISpatialAudioObjectBase
{
    HRESULT WriteNextMetadataCommand(ubyte, void*, uint);
}
enum IID_ISpatialAudioObjectForMetadataItems = GUID(0xddea49ff, 0x3bc0, 0x4377, [0x8a, 0xad, 0x9f, 0xbc, 0xfd, 0x80, 0x85, 0x66]);
interface ISpatialAudioObjectForMetadataItems : ISpatialAudioObjectBase
{
    HRESULT GetSpatialAudioMetadataItems(ISpatialAudioMetadataItems*);
}
enum IID_ISpatialAudioObjectRenderStreamForMetadata = GUID(0xbbc9c907, 0x48d5, 0x4a2e, [0xa0, 0xc7, 0xf7, 0xf0, 0xd6, 0x7c, 0x1f, 0xb1]);
interface ISpatialAudioObjectRenderStreamForMetadata : ISpatialAudioObjectRenderStreamBase
{
    HRESULT ActivateSpatialAudioObjectForMetadataCommands(AudioObjectType, ISpatialAudioObjectForMetadataCommands*);
    HRESULT ActivateSpatialAudioObjectForMetadataItems(AudioObjectType, ISpatialAudioObjectForMetadataItems*);
}
alias PROCESS_LOOPBACK_MODE = int;
enum : int
{
    PROCESS_LOOPBACK_MODE_INCLUDE_TARGET_PROCESS_TREE = 0x00000000,
    PROCESS_LOOPBACK_MODE_EXCLUDE_TARGET_PROCESS_TREE = 0x00000001,
}

struct AUDIOCLIENT_PROCESS_LOOPBACK_PARAMS
{
    uint TargetProcessId;
    PROCESS_LOOPBACK_MODE ProcessLoopbackMode;
}
alias AUDIOCLIENT_ACTIVATION_TYPE = int;
enum : int
{
    AUDIOCLIENT_ACTIVATION_TYPE_DEFAULT          = 0x00000000,
    AUDIOCLIENT_ACTIVATION_TYPE_PROCESS_LOOPBACK = 0x00000001,
}

struct AUDIOCLIENT_ACTIVATION_PARAMS
{
    AUDIOCLIENT_ACTIVATION_TYPE ActivationType;
    union
    {
        AUDIOCLIENT_PROCESS_LOOPBACK_PARAMS ProcessLoopbackParams;
    }
}
alias PAudioStateMonitorCallback = void function(IAudioStateMonitor, void*);
alias AudioStateMonitorSoundLevel = int;
enum : int
{
    Muted   = 0x00000000,
    Low     = 0x00000001,
    Full    = 0x00000002,
}

enum IID_IAudioStateMonitor = GUID(0x63bd8738, 0xe30d, 0x4c77, [0xbf, 0x5c, 0x83, 0x4e, 0x87, 0xc6, 0x57, 0xe2]);
interface IAudioStateMonitor : IUnknown
{
    HRESULT RegisterCallback(PAudioStateMonitorCallback, void*, long*);
    void UnregisterCallback(long);
    AudioStateMonitorSoundLevel GetSoundLevel();
}
alias ACMDRIVERENUMCB = BOOL function(HACMDRIVERID, ulong, uint);
alias LPACMDRIVERPROC = LRESULT function(ulong, HACMDRIVERID, uint, LPARAM, LPARAM);
struct ACMDRIVERDETAILSA
{
    align (1):
    uint cbStruct;
    uint fccType;
    uint fccComp;
    ushort wMid;
    ushort wPid;
    uint vdwACM;
    uint vdwDriver;
    uint fdwSupport;
    uint cFormatTags;
    uint cFilterTags;
    HICON hicon;
    CHAR[32] szShortName;
    CHAR[128] szLongName;
    CHAR[80] szCopyright;
    CHAR[128] szLicensing;
    CHAR[512] szFeatures;
}
struct ACMDRIVERDETAILSW
{
    align (1):
    uint cbStruct;
    uint fccType;
    uint fccComp;
    ushort wMid;
    ushort wPid;
    uint vdwACM;
    uint vdwDriver;
    uint fdwSupport;
    uint cFormatTags;
    uint cFilterTags;
    HICON hicon;
    wchar[32] szShortName;
    wchar[128] szLongName;
    wchar[80] szCopyright;
    wchar[128] szLicensing;
    wchar[512] szFeatures;
}
struct ACMFORMATTAGDETAILSA
{
    align (1):
    uint cbStruct;
    uint dwFormatTagIndex;
    uint dwFormatTag;
    uint cbFormatSize;
    uint fdwSupport;
    uint cStandardFormats;
    CHAR[48] szFormatTag;
}
struct ACMFORMATTAGDETAILSW
{
    align (1):
    uint cbStruct;
    uint dwFormatTagIndex;
    uint dwFormatTag;
    uint cbFormatSize;
    uint fdwSupport;
    uint cStandardFormats;
    wchar[48] szFormatTag;
}
alias ACMFORMATTAGENUMCBA = BOOL function(HACMDRIVERID, ACMFORMATTAGDETAILSA*, ulong, uint);
alias ACMFORMATTAGENUMCBW = BOOL function(HACMDRIVERID, ACMFORMATTAGDETAILSW*, ulong, uint);
struct ACMFORMATDETAILSA
{
    align (1):
    uint cbStruct;
    uint dwFormatIndex;
    uint dwFormatTag;
    uint fdwSupport;
    WAVEFORMATEX* pwfx;
    uint cbwfx;
    CHAR[128] szFormat;
}
struct tACMFORMATDETAILSW
{
    align (1):
    uint cbStruct;
    uint dwFormatIndex;
    uint dwFormatTag;
    uint fdwSupport;
    WAVEFORMATEX* pwfx;
    uint cbwfx;
    wchar[128] szFormat;
}
alias ACMFORMATENUMCBA = BOOL function(HACMDRIVERID, ACMFORMATDETAILSA*, ulong, uint);
alias ACMFORMATENUMCBW = BOOL function(HACMDRIVERID, tACMFORMATDETAILSW*, ulong, uint);
alias ACMFORMATCHOOSEHOOKPROCA = uint function(HWND, uint, WPARAM, LPARAM);
alias ACMFORMATCHOOSEHOOKPROCW = uint function(HWND, uint, WPARAM, LPARAM);
struct ACMFORMATCHOOSEA
{
    align (1):
    uint cbStruct;
    uint fdwStyle;
    HWND hwndOwner;
    WAVEFORMATEX* pwfx;
    uint cbwfx;
    const(char)* pszTitle;
    CHAR[48] szFormatTag;
    CHAR[128] szFormat;
    PSTR pszName;
    uint cchName;
    uint fdwEnum;
    WAVEFORMATEX* pwfxEnum;
    HINSTANCE hInstance;
    const(char)* pszTemplateName;
    LPARAM lCustData;
    ACMFORMATCHOOSEHOOKPROCA pfnHook;
}
struct ACMFORMATCHOOSEW
{
    align (1):
    uint cbStruct;
    uint fdwStyle;
    HWND hwndOwner;
    WAVEFORMATEX* pwfx;
    uint cbwfx;
    const(wchar)* pszTitle;
    wchar[48] szFormatTag;
    wchar[128] szFormat;
    PWSTR pszName;
    uint cchName;
    uint fdwEnum;
    WAVEFORMATEX* pwfxEnum;
    HINSTANCE hInstance;
    const(wchar)* pszTemplateName;
    LPARAM lCustData;
    ACMFORMATCHOOSEHOOKPROCW pfnHook;
}
struct ACMFILTERTAGDETAILSA
{
    align (1):
    uint cbStruct;
    uint dwFilterTagIndex;
    uint dwFilterTag;
    uint cbFilterSize;
    uint fdwSupport;
    uint cStandardFilters;
    CHAR[48] szFilterTag;
}
struct ACMFILTERTAGDETAILSW
{
    align (1):
    uint cbStruct;
    uint dwFilterTagIndex;
    uint dwFilterTag;
    uint cbFilterSize;
    uint fdwSupport;
    uint cStandardFilters;
    wchar[48] szFilterTag;
}
alias ACMFILTERTAGENUMCBA = BOOL function(HACMDRIVERID, ACMFILTERTAGDETAILSA*, ulong, uint);
alias ACMFILTERTAGENUMCBW = BOOL function(HACMDRIVERID, ACMFILTERTAGDETAILSW*, ulong, uint);
struct ACMFILTERDETAILSA
{
    align (1):
    uint cbStruct;
    uint dwFilterIndex;
    uint dwFilterTag;
    uint fdwSupport;
    WAVEFILTER* pwfltr;
    uint cbwfltr;
    CHAR[128] szFilter;
}
struct ACMFILTERDETAILSW
{
    align (1):
    uint cbStruct;
    uint dwFilterIndex;
    uint dwFilterTag;
    uint fdwSupport;
    WAVEFILTER* pwfltr;
    uint cbwfltr;
    wchar[128] szFilter;
}
alias ACMFILTERENUMCBA = BOOL function(HACMDRIVERID, ACMFILTERDETAILSA*, ulong, uint);
alias ACMFILTERENUMCBW = BOOL function(HACMDRIVERID, ACMFILTERDETAILSW*, ulong, uint);
alias ACMFILTERCHOOSEHOOKPROCA = uint function(HWND, uint, WPARAM, LPARAM);
alias ACMFILTERCHOOSEHOOKPROCW = uint function(HWND, uint, WPARAM, LPARAM);
struct ACMFILTERCHOOSEA
{
    align (1):
    uint cbStruct;
    uint fdwStyle;
    HWND hwndOwner;
    WAVEFILTER* pwfltr;
    uint cbwfltr;
    const(char)* pszTitle;
    CHAR[48] szFilterTag;
    CHAR[128] szFilter;
    PSTR pszName;
    uint cchName;
    uint fdwEnum;
    WAVEFILTER* pwfltrEnum;
    HINSTANCE hInstance;
    const(char)* pszTemplateName;
    LPARAM lCustData;
    ACMFILTERCHOOSEHOOKPROCA pfnHook;
}
struct ACMFILTERCHOOSEW
{
    align (1):
    uint cbStruct;
    uint fdwStyle;
    HWND hwndOwner;
    WAVEFILTER* pwfltr;
    uint cbwfltr;
    const(wchar)* pszTitle;
    wchar[48] szFilterTag;
    wchar[128] szFilter;
    PWSTR pszName;
    uint cchName;
    uint fdwEnum;
    WAVEFILTER* pwfltrEnum;
    HINSTANCE hInstance;
    const(wchar)* pszTemplateName;
    LPARAM lCustData;
    ACMFILTERCHOOSEHOOKPROCW pfnHook;
}
/+ [CONFLICTED] struct ACMSTREAMHEADER
{
    align (1):
    uint cbStruct;
    uint fdwStatus;
    ulong dwUser;
    ubyte* pbSrc;
    uint cbSrcLength;
    uint cbSrcLengthUsed;
    ulong dwSrcUser;
    ubyte* pbDst;
    uint cbDstLength;
    uint cbDstLengthUsed;
    ulong dwDstUser;
    uint[10] dwReservedDriver;
}
+/
struct ACMDRVOPENDESCA
{
    align (1):
    uint cbStruct;
    uint fccType;
    uint fccComp;
    uint dwVersion;
    uint dwFlags;
    uint dwError;
    const(char)* pszSectionName;
    const(char)* pszAliasName;
    uint dnDevNode;
}
struct ACMDRVOPENDESCW
{
    align (1):
    uint cbStruct;
    uint fccType;
    uint fccComp;
    uint dwVersion;
    uint dwFlags;
    uint dwError;
    const(wchar)* pszSectionName;
    const(wchar)* pszAliasName;
    uint dnDevNode;
}
struct ACMDRVSTREAMINSTANCE
{
    align (1):
    uint cbStruct;
    WAVEFORMATEX* pwfxSrc;
    WAVEFORMATEX* pwfxDst;
    WAVEFILTER* pwfltr;
    ulong dwCallback;
    ulong dwInstance;
    uint fdwOpen;
    uint fdwDriver;
    ulong dwDriver;
    HACMSTREAM has;
}
struct ACMDRVSTREAMHEADER
{
    align (1):
    uint cbStruct;
    uint fdwStatus;
    ulong dwUser;
    ubyte* pbSrc;
    uint cbSrcLength;
    uint cbSrcLengthUsed;
    ulong dwSrcUser;
    ubyte* pbDst;
    uint cbDstLength;
    uint cbDstLengthUsed;
    ulong dwDstUser;
    uint fdwConvert;
    ACMDRVSTREAMHEADER* padshNext;
    uint fdwDriver;
    ulong dwDriver;
    uint fdwPrepared;
    ulong dwPrepared;
    ubyte* pbPreparedSrc;
    uint cbPreparedSrcLength;
    ubyte* pbPreparedDst;
    uint cbPreparedDstLength;
}
struct ACMDRVSTREAMSIZE
{
    align (1):
    uint cbStruct;
    uint fdwSize;
    uint cbSrcLength;
    uint cbDstLength;
}
struct ACMDRVFORMATSUGGEST
{
    align (1):
    uint cbStruct;
    uint fdwSuggest;
    WAVEFORMATEX* pwfxSrc;
    uint cbwfxSrc;
    WAVEFORMATEX* pwfxDst;
    uint cbwfxDst;
}
