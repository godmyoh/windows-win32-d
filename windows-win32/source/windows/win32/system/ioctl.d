module windows.win32.system.ioctl;

import windows.win32.guid : GUID;
import windows.win32.devices.properties : DEVPROPKEY;
import windows.win32.foundation : BOOLEAN, CHAR, HANDLE;
import windows.win32.security : SID;
import windows.win32.storage.filesystem : FILE_ID_128, STORAGE_BUS_TYPE;
import windows.win32.storage.vhd : VIRTUAL_STORAGE_TYPE;

version (Windows):
extern (Windows):

enum IOCTL_STORAGE_BASE = 0x0000002d;
enum IOCTL_SCMBUS_BASE = 0x00000059;
enum IOCTL_DISK_BASE = 0x00000007;
enum IOCTL_CHANGER_BASE = 0x00000030;
enum FILE_SPECIAL_ACCESS = 0x00000000;
enum FILE_DEVICE_UNKNOWN = 0x00000022;
enum GUID_DEVINTERFACE_DISK = GUID(0x53f56307, 0xb6bf, 0x11d0, [0x94, 0xf2, 0x0, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b]);
enum GUID_DEVINTERFACE_CDROM = GUID(0x53f56308, 0xb6bf, 0x11d0, [0x94, 0xf2, 0x0, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b]);
enum GUID_DEVINTERFACE_PARTITION = GUID(0x53f5630a, 0xb6bf, 0x11d0, [0x94, 0xf2, 0x0, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b]);
enum GUID_DEVINTERFACE_TAPE = GUID(0x53f5630b, 0xb6bf, 0x11d0, [0x94, 0xf2, 0x0, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b]);
enum GUID_DEVINTERFACE_WRITEONCEDISK = GUID(0x53f5630c, 0xb6bf, 0x11d0, [0x94, 0xf2, 0x0, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b]);
enum GUID_DEVINTERFACE_VOLUME = GUID(0x53f5630d, 0xb6bf, 0x11d0, [0x94, 0xf2, 0x0, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b]);
enum GUID_DEVINTERFACE_MEDIUMCHANGER = GUID(0x53f56310, 0xb6bf, 0x11d0, [0x94, 0xf2, 0x0, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b]);
enum GUID_DEVINTERFACE_FLOPPY = GUID(0x53f56311, 0xb6bf, 0x11d0, [0x94, 0xf2, 0x0, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b]);
enum GUID_DEVINTERFACE_CDCHANGER = GUID(0x53f56312, 0xb6bf, 0x11d0, [0x94, 0xf2, 0x0, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b]);
enum GUID_DEVINTERFACE_STORAGEPORT = GUID(0x2accfe60, 0xc130, 0x11d2, [0xb0, 0x82, 0x0, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b]);
enum GUID_DEVINTERFACE_VMLUN = GUID(0x6f416619, 0x9f29, 0x42a5, [0xb2, 0xb, 0x37, 0xe2, 0x19, 0xca, 0x2, 0xb0]);
enum GUID_DEVINTERFACE_SES = GUID(0x1790c9ec, 0x47d5, 0x4df3, [0xb5, 0xaf, 0x9a, 0xdf, 0x3c, 0xf2, 0x3e, 0x48]);
enum GUID_DEVINTERFACE_ZNSDISK = GUID(0xb87941c5, 0xffdb, 0x43c7, [0xb6, 0xb1, 0x20, 0xb6, 0x32, 0xf0, 0xb1, 0x9]);
enum GUID_DEVINTERFACE_SERVICE_VOLUME = GUID(0x6ead3d82, 0x25ec, 0x46bc, [0xb7, 0xfd, 0xc1, 0xf0, 0xdf, 0x8f, 0x50, 0x37]);
enum GUID_DEVINTERFACE_HIDDEN_VOLUME = GUID(0x7f108a28, 0x9833, 0x4b3b, [0xb7, 0x80, 0x2c, 0x6b, 0x5f, 0xa5, 0xc0, 0x62]);
enum GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB = GUID(0x27447c21, 0xbcc3, 0x4d07, [0xa0, 0x5b, 0xa3, 0x39, 0x5b, 0xb4, 0xee, 0xe7]);
enum GUID_DEVICEDUMP_STORAGE_DEVICE = GUID(0xd8e2592f, 0x1aab, 0x4d56, [0xa7, 0x46, 0x1f, 0x75, 0x85, 0xdf, 0x40, 0xf4]);
enum GUID_DEVICEDUMP_DRIVER_STORAGE_PORT = GUID(0xda82441d, 0x7142, 0x4bc1, [0xb8, 0x44, 0x8, 0x7, 0xc5, 0xa4, 0xb6, 0x7f]);
enum DEVPKEY_Storage_Portable = DEVPROPKEY(GUID(1293860584, 2051, 18292, [152, 66, 183, 125, 181, 2, 101, 233]), 2);
enum DEVPKEY_Storage_Removable_Media = DEVPROPKEY(GUID(1293860584, 2051, 18292, [152, 66, 183, 125, 181, 2, 101, 233]), 3);
enum DEVPKEY_Storage_System_Critical = DEVPROPKEY(GUID(1293860584, 2051, 18292, [152, 66, 183, 125, 181, 2, 101, 233]), 4);
enum DEVPKEY_Storage_Disk_Number = DEVPROPKEY(GUID(1293860584, 2051, 18292, [152, 66, 183, 125, 181, 2, 101, 233]), 5);
enum DEVPKEY_Storage_Partition_Number = DEVPROPKEY(GUID(1293860584, 2051, 18292, [152, 66, 183, 125, 181, 2, 101, 233]), 6);
enum DEVPKEY_Storage_Mbr_Type = DEVPROPKEY(GUID(1293860584, 2051, 18292, [152, 66, 183, 125, 181, 2, 101, 233]), 7);
enum DEVPKEY_Storage_Gpt_Type = DEVPROPKEY(GUID(1293860584, 2051, 18292, [152, 66, 183, 125, 181, 2, 101, 233]), 8);
enum DEVPKEY_Storage_Gpt_Name = DEVPROPKEY(GUID(1293860584, 2051, 18292, [152, 66, 183, 125, 181, 2, 101, 233]), 9);
enum IOCTL_STORAGE_CHECK_VERIFY = 0x002d4800;
enum IOCTL_STORAGE_CHECK_VERIFY2 = 0x002d0800;
enum IOCTL_STORAGE_MEDIA_REMOVAL = 0x002d4804;
enum IOCTL_STORAGE_EJECT_MEDIA = 0x002d4808;
enum IOCTL_STORAGE_LOAD_MEDIA = 0x002d480c;
enum IOCTL_STORAGE_LOAD_MEDIA2 = 0x002d080c;
enum IOCTL_STORAGE_RESERVE = 0x002d4810;
enum IOCTL_STORAGE_RELEASE = 0x002d4814;
enum IOCTL_STORAGE_FIND_NEW_DEVICES = 0x002d4818;
enum IOCTL_STORAGE_MANAGE_BYPASS_IO = 0x002d08c0;
enum IOCTL_STORAGE_EJECTION_CONTROL = 0x002d0940;
enum IOCTL_STORAGE_MCN_CONTROL = 0x002d0944;
enum IOCTL_STORAGE_GET_MEDIA_TYPES = 0x002d0c00;
enum IOCTL_STORAGE_GET_MEDIA_TYPES_EX = 0x002d0c04;
enum IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = 0x002d0c10;
enum IOCTL_STORAGE_GET_HOTPLUG_INFO = 0x002d0c14;
enum IOCTL_STORAGE_SET_HOTPLUG_INFO = 0x002dcc18;
enum IOCTL_STORAGE_RESET_BUS = 0x002d5000;
enum IOCTL_STORAGE_RESET_DEVICE = 0x002d5004;
enum IOCTL_STORAGE_BREAK_RESERVATION = 0x002d5014;
enum IOCTL_STORAGE_PERSISTENT_RESERVE_IN = 0x002d5018;
enum IOCTL_STORAGE_PERSISTENT_RESERVE_OUT = 0x002dd01c;
enum IOCTL_STORAGE_GET_DEVICE_NUMBER = 0x002d1080;
enum IOCTL_STORAGE_GET_DEVICE_NUMBER_EX = 0x002d1084;
enum IOCTL_STORAGE_PREDICT_FAILURE = 0x002d1100;
enum IOCTL_STORAGE_FAILURE_PREDICTION_CONFIG = 0x002d1104;
enum IOCTL_STORAGE_GET_COUNTERS = 0x002d1108;
enum IOCTL_STORAGE_READ_CAPACITY = 0x002d5140;
enum IOCTL_STORAGE_GET_DEVICE_TELEMETRY = 0x002dd1c0;
enum IOCTL_STORAGE_DEVICE_TELEMETRY_NOTIFY = 0x002dd1c4;
enum IOCTL_STORAGE_DEVICE_TELEMETRY_QUERY_CAPS = 0x002dd1c8;
enum IOCTL_STORAGE_GET_DEVICE_TELEMETRY_RAW = 0x002dd1cc;
enum IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD = 0x002dd200;
enum IOCTL_STORAGE_PROTOCOL_COMMAND = 0x002dd3c0;
enum IOCTL_STORAGE_SET_PROPERTY = 0x002d93fc;
enum IOCTL_STORAGE_QUERY_PROPERTY = 0x002d1400;
enum IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES = 0x002d9404;
enum IOCTL_STORAGE_GET_LB_PROVISIONING_MAP_RESOURCES = 0x002d5408;
enum IOCTL_STORAGE_REINITIALIZE_MEDIA = 0x002d9640;
enum IOCTL_STORAGE_GET_BC_PROPERTIES = 0x002d5800;
enum IOCTL_STORAGE_ALLOCATE_BC_STREAM = 0x002dd804;
enum IOCTL_STORAGE_FREE_BC_STREAM = 0x002dd808;
enum IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT = 0x002d1880;
enum IOCTL_STORAGE_START_DATA_INTEGRITY_CHECK = 0x002dd884;
enum IOCTL_STORAGE_STOP_DATA_INTEGRITY_CHECK = 0x002dd888;
enum OBSOLETE_IOCTL_STORAGE_RESET_BUS = 0x002dd000;
enum OBSOLETE_IOCTL_STORAGE_RESET_DEVICE = 0x002dd004;
enum IOCTL_STORAGE_FIRMWARE_GET_INFO = 0x002d1c00;
enum IOCTL_STORAGE_FIRMWARE_DOWNLOAD = 0x002ddc04;
enum IOCTL_STORAGE_FIRMWARE_ACTIVATE = 0x002ddc08;
enum IOCTL_STORAGE_ENABLE_IDLE_POWER = 0x002d1c80;
enum IOCTL_STORAGE_GET_IDLE_POWERUP_REASON = 0x002d1c84;
enum IOCTL_STORAGE_POWER_ACTIVE = 0x002d1c88;
enum IOCTL_STORAGE_POWER_IDLE = 0x002d1c8c;
enum IOCTL_STORAGE_EVENT_NOTIFICATION = 0x002d1c90;
enum IOCTL_STORAGE_DEVICE_POWER_CAP = 0x002d1c94;
enum IOCTL_STORAGE_RPMB_COMMAND = 0x002d1c98;
enum IOCTL_STORAGE_ATTRIBUTE_MANAGEMENT = 0x002ddc9c;
enum IOCTL_STORAGE_DIAGNOSTIC = 0x002d1ca0;
enum IOCTL_STORAGE_GET_PHYSICAL_ELEMENT_STATUS = 0x002d1ca4;
enum IOCTL_STORAGE_REMOVE_ELEMENT_AND_TRUNCATE = 0x002d1cc0;
enum IOCTL_STORAGE_GET_DEVICE_INTERNAL_LOG = 0x002d1cc4;
enum STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_CONFLICT = 0x00000001;
enum STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_NOHWID = 0x00000002;
enum STORAGE_DEVICE_FLAGS_PAGE_83_DEVICEGUID = 0x00000004;
enum RECOVERED_WRITES_VALID = 0x00000001;
enum UNRECOVERED_WRITES_VALID = 0x00000002;
enum RECOVERED_READS_VALID = 0x00000004;
enum UNRECOVERED_READS_VALID = 0x00000008;
enum WRITE_COMPRESSION_INFO_VALID = 0x00000010;
enum READ_COMPRESSION_INFO_VALID = 0x00000020;
enum TAPE_RETURN_STATISTICS = 0x00000000;
enum TAPE_RETURN_ENV_INFO = 0x00000001;
enum TAPE_RESET_STATISTICS = 0x00000002;
enum MEDIA_ERASEABLE = 0x00000001;
enum MEDIA_WRITE_ONCE = 0x00000002;
enum MEDIA_READ_ONLY = 0x00000004;
enum MEDIA_READ_WRITE = 0x00000008;
enum MEDIA_WRITE_PROTECTED = 0x00000100;
enum MEDIA_CURRENTLY_MOUNTED = 0x80000000;
enum STORAGE_FAILURE_PREDICTION_CONFIG_V1 = 0x00000001;
enum SRB_TYPE_SCSI_REQUEST_BLOCK = 0x00000000;
enum SRB_TYPE_STORAGE_REQUEST_BLOCK = 0x00000001;
enum STORAGE_ADDRESS_TYPE_BTL8 = 0x00000000;
enum STORAGE_RPMB_DESCRIPTOR_VERSION_1 = 0x00000001;
enum STORAGE_RPMB_MINIMUM_RELIABLE_WRITE_SIZE = 0x00000200;
enum STORAGE_CRYPTO_CAPABILITY_VERSION_1 = 0x00000001;
enum STORAGE_CRYPTO_DESCRIPTOR_VERSION_1 = 0x00000001;
enum STORAGE_TIER_NAME_LENGTH = 0x00000100;
enum STORAGE_TIER_DESCRIPTION_LENGTH = 0x00000200;
enum STORAGE_TIER_FLAG_NO_SEEK_PENALTY = 0x00020000;
enum STORAGE_TIER_FLAG_WRITE_BACK_CACHE = 0x00200000;
enum STORAGE_TIER_FLAG_READ_CACHE = 0x00400000;
enum STORAGE_TIER_FLAG_PARITY = 0x00800000;
enum STORAGE_TIER_FLAG_SMR = 0x01000000;
enum STORAGE_TEMPERATURE_VALUE_NOT_REPORTED = 0x00008000;
enum STORAGE_TEMPERATURE_THRESHOLD_FLAG_ADAPTER_REQUEST = 0x00000001;
enum STORAGE_COMPONENT_ROLE_CACHE = 0x00000001;
enum STORAGE_COMPONENT_ROLE_TIERING = 0x00000002;
enum STORAGE_COMPONENT_ROLE_DATA = 0x00000004;
enum STORAGE_ATTRIBUTE_BYTE_ADDRESSABLE_IO = 0x00000001;
enum STORAGE_ATTRIBUTE_BLOCK_IO = 0x00000002;
enum STORAGE_ATTRIBUTE_DYNAMIC_PERSISTENCE = 0x00000004;
enum STORAGE_ATTRIBUTE_VOLATILE = 0x00000008;
enum STORAGE_ATTRIBUTE_ASYNC_EVENT_NOTIFICATION = 0x00000010;
enum STORAGE_ATTRIBUTE_PERF_SIZE_INDEPENDENT = 0x00000020;
enum STORAGE_DEVICE_MAX_OPERATIONAL_STATUS = 0x00000010;
enum STORAGE_ADAPTER_SERIAL_NUMBER_V1_MAX_LENGTH = 0x00000080;
enum DeviceDsmActionFlag_NonDestructive = 0x80000000;
enum DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE = 0x00000001;
enum DEVICE_DSM_FLAG_TRIM_NOT_FS_ALLOCATED = 0x80000000;
enum DEVICE_DSM_FLAG_TRIM_BYPASS_RZAT = 0x40000000;
enum DEVICE_DSM_NOTIFY_FLAG_BEGIN = 0x00000001;
enum DEVICE_DSM_NOTIFY_FLAG_END = 0x00000002;
enum STORAGE_OFFLOAD_MAX_TOKEN_LENGTH = 0x00000200;
enum STORAGE_OFFLOAD_TOKEN_ID_LENGTH = 0x000001f8;
enum STORAGE_OFFLOAD_TOKEN_TYPE_ZERO_DATA = 0xffff0001;
enum STORAGE_OFFLOAD_READ_RANGE_TRUNCATED = 0x00000001;
enum STORAGE_OFFLOAD_WRITE_RANGE_TRUNCATED = 0x00000001;
enum STORAGE_OFFLOAD_TOKEN_INVALID = 0x00000002;
enum DEVICE_DSM_FLAG_ALLOCATION_CONSOLIDATEABLE_ONLY = 0x40000000;
enum DEVICE_DSM_PARAMETERS_V1 = 0x00000001;
enum DEVICE_DATA_SET_LBP_STATE_PARAMETERS_VERSION_V1 = 0x00000001;
enum DEVICE_DSM_FLAG_REPAIR_INPUT_TOPOLOGY_ID_PRESENT = 0x40000000;
enum DEVICE_DSM_FLAG_REPAIR_OUTPUT_PARITY_EXTENT = 0x20000000;
enum DEVICE_DSM_FLAG_SCRUB_SKIP_IN_SYNC = 0x10000000;
enum DEVICE_DSM_FLAG_SCRUB_OUTPUT_PARITY_EXTENT = 0x20000000;
enum DEVICE_DSM_FLAG_PHYSICAL_ADDRESSES_OMIT_TOTAL_RANGES = 0x10000000;
enum DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_V1 = 0x00000001;
enum DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_VERSION_V1 = 0x00000001;
enum DEVICE_STORAGE_NO_ERRORS = 0x00000001;
enum DEVICE_DSM_RANGE_ERROR_OUTPUT_V1 = 0x00000001;
enum DEVICE_DSM_RANGE_ERROR_INFO_VERSION_V1 = 0x00000001;
enum IOCTL_STORAGE_BC_VERSION = 0x00000001;
enum STORAGE_PRIORITY_HINT_SUPPORTED = 0x00000001;
enum STORAGE_DIAGNOSTIC_FLAG_ADAPTER_REQUEST = 0x00000001;
enum ERROR_HISTORY_DIRECTORY_ENTRY_DEFAULT_COUNT = 0x00000008;
enum DEVICEDUMP_STRUCTURE_VERSION_V1 = 0x00000001;
enum DEVICEDUMP_MAX_IDSTRING = 0x00000020;
enum MAX_FW_BUCKET_ID_LENGTH = 0x00000084;
enum STORAGE_CRASH_TELEMETRY_REGKEY = "\\Registry\\Machine\\System\\CurrentControlSet\\Control\\CrashControl\\StorageTelemetry";
enum STORAGE_DEVICE_TELEMETRY_REGKEY = "\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Storage\\StorageTelemetry";
enum DDUMP_FLAG_DATA_READ_FROM_DEVICE = 0x00000001;
enum FW_ISSUEID_NO_ISSUE = 0x00000000;
enum FW_ISSUEID_UNKNOWN = 0xffffffff;
enum TC_PUBLIC_DEVICEDUMP_CONTENT_SMART = 0x00000001;
enum TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG = 0x00000002;
enum TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG_MAX = 0x00000010;
enum TC_DEVICEDUMP_SUBSECTION_DESC_LENGTH = 0x00000010;
enum TC_PUBLIC_DATA_TYPE_ATAGP = "ATAGPLogPages";
enum TC_PUBLIC_DATA_TYPE_ATASMART = "ATASMARTPages";
enum CDB_SIZE = 0x00000010;
enum TELEMETRY_COMMAND_SIZE = 0x00000010;
enum DEVICEDUMP_CAP_PRIVATE_SECTION = 0x00000001;
enum DEVICEDUMP_CAP_RESTRICTED_SECTION = 0x00000002;
enum STORAGE_IDLE_POWERUP_REASON_VERSION_V1 = 0x00000001;
enum STORAGE_DEVICE_POWER_CAP_VERSION_V1 = 0x00000001;
enum STORAGE_EVENT_NOTIFICATION_VERSION_V1 = 0x00000001;
enum STORAGE_EVENT_MEDIA_STATUS = 0x0000000000000001;
enum STORAGE_EVENT_DEVICE_STATUS = 0x0000000000000002;
enum STORAGE_EVENT_DEVICE_OPERATION = 0x0000000000000004;
enum READ_COPY_NUMBER_KEY = 0x52434e00;
enum READ_COPY_NUMBER_BYPASS_CACHE_FLAG = 0x00000100;
enum STORAGE_HW_FIRMWARE_REQUEST_FLAG_CONTROLLER = 0x00000001;
enum STORAGE_HW_FIRMWARE_REQUEST_FLAG_LAST_SEGMENT = 0x00000002;
enum STORAGE_HW_FIRMWARE_REQUEST_FLAG_FIRST_SEGMENT = 0x00000004;
enum STORAGE_HW_FIRMWARE_REQUEST_FLAG_REPLACE_EXISTING_IMAGE = 0x40000000;
enum STORAGE_HW_FIRMWARE_REQUEST_FLAG_SWITCH_TO_EXISTING_FIRMWARE = 0x80000000;
enum STORAGE_HW_FIRMWARE_INVALID_SLOT = 0x000000ff;
enum STORAGE_HW_FIRMWARE_REVISION_LENGTH = 0x00000010;
enum STORAGE_PROTOCOL_STRUCTURE_VERSION = 0x00000001;
enum STORAGE_PROTOCOL_COMMAND_FLAG_ADAPTER_REQUEST = 0x80000000;
enum STORAGE_PROTOCOL_STATUS_PENDING = 0x00000000;
enum STORAGE_PROTOCOL_STATUS_SUCCESS = 0x00000001;
enum STORAGE_PROTOCOL_STATUS_ERROR = 0x00000002;
enum STORAGE_PROTOCOL_STATUS_INVALID_REQUEST = 0x00000003;
enum STORAGE_PROTOCOL_STATUS_NO_DEVICE = 0x00000004;
enum STORAGE_PROTOCOL_STATUS_BUSY = 0x00000005;
enum STORAGE_PROTOCOL_STATUS_DATA_OVERRUN = 0x00000006;
enum STORAGE_PROTOCOL_STATUS_INSUFFICIENT_RESOURCES = 0x00000007;
enum STORAGE_PROTOCOL_STATUS_THROTTLED_REQUEST = 0x00000008;
enum STORAGE_PROTOCOL_STATUS_NOT_SUPPORTED = 0x000000ff;
enum STORAGE_PROTOCOL_COMMAND_LENGTH_NVME = 0x00000040;
enum STORAGE_PROTOCOL_SPECIFIC_NVME_ADMIN_COMMAND = 0x00000001;
enum STORAGE_PROTOCOL_SPECIFIC_NVME_NVM_COMMAND = 0x00000002;
enum STORATTRIBUTE_NONE = 0x00000000;
enum STORATTRIBUTE_MANAGEMENT_STATE = 0x00000001;
enum STORAGE_SUPPORTED_FEATURES_BYPASS_IO = 0x00000001;
enum STORAGE_SUPPORTED_FEATURES_MASK = 0x00000001;
enum GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE = GUID(0x4283609d, 0x4dc2, 0x43be, [0xbb, 0xb4, 0x4f, 0x15, 0xdf, 0xce, 0x2c, 0x61]);
enum GUID_SCM_PD_HEALTH_NOTIFICATION = GUID(0x9da2d386, 0x72f5, 0x4ee3, [0x81, 0x55, 0xec, 0xa0, 0x67, 0x8e, 0x3b, 0x6]);
enum GUID_SCM_PD_PASSTHROUGH_INVDIMM = GUID(0x4309ac30, 0xd11, 0x11e4, [0x91, 0x91, 0x8, 0x0, 0x20, 0xc, 0x9a, 0x66]);
enum GUID_DEVINTERFACE_COMPORT = GUID(0x86e0d1e0, 0x8089, 0x11d0, [0x9c, 0xe4, 0x8, 0x0, 0x3e, 0x30, 0x1f, 0x73]);
enum GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR = GUID(0x4d36e978, 0xe325, 0x11ce, [0xbf, 0xc1, 0x8, 0x0, 0x2b, 0xe1, 0x3, 0x18]);
enum FILE_DEVICE_BEEP = 0x00000001;
enum FILE_DEVICE_CD_ROM_FILE_SYSTEM = 0x00000003;
enum FILE_DEVICE_CONTROLLER = 0x00000004;
enum FILE_DEVICE_DATALINK = 0x00000005;
enum FILE_DEVICE_DFS = 0x00000006;
enum FILE_DEVICE_DISK_FILE_SYSTEM = 0x00000008;
enum FILE_DEVICE_FILE_SYSTEM = 0x00000009;
enum FILE_DEVICE_INPORT_PORT = 0x0000000a;
enum FILE_DEVICE_KEYBOARD = 0x0000000b;
enum FILE_DEVICE_MAILSLOT = 0x0000000c;
enum FILE_DEVICE_MIDI_IN = 0x0000000d;
enum FILE_DEVICE_MIDI_OUT = 0x0000000e;
enum FILE_DEVICE_MOUSE = 0x0000000f;
enum FILE_DEVICE_MULTI_UNC_PROVIDER = 0x00000010;
enum FILE_DEVICE_NAMED_PIPE = 0x00000011;
enum FILE_DEVICE_NETWORK = 0x00000012;
enum FILE_DEVICE_NETWORK_BROWSER = 0x00000013;
enum FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x00000014;
enum FILE_DEVICE_NULL = 0x00000015;
enum FILE_DEVICE_PARALLEL_PORT = 0x00000016;
enum FILE_DEVICE_PHYSICAL_NETCARD = 0x00000017;
enum FILE_DEVICE_PRINTER = 0x00000018;
enum FILE_DEVICE_SCANNER = 0x00000019;
enum FILE_DEVICE_SERIAL_MOUSE_PORT = 0x0000001a;
enum FILE_DEVICE_SERIAL_PORT = 0x0000001b;
enum FILE_DEVICE_SCREEN = 0x0000001c;
enum FILE_DEVICE_SOUND = 0x0000001d;
enum FILE_DEVICE_STREAMS = 0x0000001e;
enum FILE_DEVICE_TAPE_FILE_SYSTEM = 0x00000020;
enum FILE_DEVICE_TRANSPORT = 0x00000021;
enum FILE_DEVICE_VIDEO = 0x00000023;
enum FILE_DEVICE_VIRTUAL_DISK = 0x00000024;
enum FILE_DEVICE_WAVE_IN = 0x00000025;
enum FILE_DEVICE_WAVE_OUT = 0x00000026;
enum FILE_DEVICE_8042_PORT = 0x00000027;
enum FILE_DEVICE_NETWORK_REDIRECTOR = 0x00000028;
enum FILE_DEVICE_BATTERY = 0x00000029;
enum FILE_DEVICE_BUS_EXTENDER = 0x0000002a;
enum FILE_DEVICE_MODEM = 0x0000002b;
enum FILE_DEVICE_VDM = 0x0000002c;
enum FILE_DEVICE_MASS_STORAGE = 0x0000002d;
enum FILE_DEVICE_SMB = 0x0000002e;
enum FILE_DEVICE_KS = 0x0000002f;
enum FILE_DEVICE_CHANGER = 0x00000030;
enum FILE_DEVICE_ACPI = 0x00000032;
enum FILE_DEVICE_FULLSCREEN_VIDEO = 0x00000034;
enum FILE_DEVICE_DFS_FILE_SYSTEM = 0x00000035;
enum FILE_DEVICE_DFS_VOLUME = 0x00000036;
enum FILE_DEVICE_SERENUM = 0x00000037;
enum FILE_DEVICE_TERMSRV = 0x00000038;
enum FILE_DEVICE_KSEC = 0x00000039;
enum FILE_DEVICE_FIPS = 0x0000003a;
enum FILE_DEVICE_INFINIBAND = 0x0000003b;
enum FILE_DEVICE_VMBUS = 0x0000003e;
enum FILE_DEVICE_CRYPT_PROVIDER = 0x0000003f;
enum FILE_DEVICE_WPD = 0x00000040;
enum FILE_DEVICE_BLUETOOTH = 0x00000041;
enum FILE_DEVICE_MT_COMPOSITE = 0x00000042;
enum FILE_DEVICE_MT_TRANSPORT = 0x00000043;
enum FILE_DEVICE_BIOMETRIC = 0x00000044;
enum FILE_DEVICE_PMI = 0x00000045;
enum FILE_DEVICE_EHSTOR = 0x00000046;
enum FILE_DEVICE_DEVAPI = 0x00000047;
enum FILE_DEVICE_GPIO = 0x00000048;
enum FILE_DEVICE_USBEX = 0x00000049;
enum FILE_DEVICE_CONSOLE = 0x00000050;
enum FILE_DEVICE_NFP = 0x00000051;
enum FILE_DEVICE_SYSENV = 0x00000052;
enum FILE_DEVICE_VIRTUAL_BLOCK = 0x00000053;
enum FILE_DEVICE_POINT_OF_SERVICE = 0x00000054;
enum FILE_DEVICE_STORAGE_REPLICATION = 0x00000055;
enum FILE_DEVICE_TRUST_ENV = 0x00000056;
enum FILE_DEVICE_UCM = 0x00000057;
enum FILE_DEVICE_UCMTCPCI = 0x00000058;
enum FILE_DEVICE_PERSISTENT_MEMORY = 0x00000059;
enum FILE_DEVICE_NVDIMM = 0x0000005a;
enum FILE_DEVICE_HOLOGRAPHIC = 0x0000005b;
enum FILE_DEVICE_SDFXHCI = 0x0000005c;
enum FILE_DEVICE_UCMUCSI = 0x0000005d;
enum FILE_DEVICE_PRM = 0x0000005e;
enum FILE_DEVICE_EVENT_COLLECTOR = 0x0000005f;
enum FILE_DEVICE_USB4 = 0x00000060;
enum FILE_DEVICE_SOUNDWIRE = 0x00000061;
enum METHOD_BUFFERED = 0x00000000;
enum METHOD_IN_DIRECT = 0x00000001;
enum METHOD_OUT_DIRECT = 0x00000002;
enum METHOD_NEITHER = 0x00000003;
enum METHOD_DIRECT_TO_HARDWARE = 0x00000001;
enum METHOD_DIRECT_FROM_HARDWARE = 0x00000002;
enum FILE_ANY_ACCESS = 0x00000000;
enum FILE_READ_ACCESS = 0x00000001;
enum FILE_WRITE_ACCESS = 0x00000002;
enum STORAGE_DEVICE_NUMA_NODE_UNKNOWN = 0xffffffff;
enum IOCTL_SCMBUS_DEVICE_FUNCTION_BASE = 0x00000000;
enum IOCTL_SCM_LOGICAL_DEVICE_FUNCTION_BASE = 0x00000300;
enum IOCTL_SCM_PHYSICAL_DEVICE_FUNCTION_BASE = 0x00000600;
enum IOCTL_SCM_BUS_GET_LOGICAL_DEVICES = 0x00590000;
enum IOCTL_SCM_BUS_GET_PHYSICAL_DEVICES = 0x00590004;
enum IOCTL_SCM_BUS_GET_REGIONS = 0x00590008;
enum IOCTL_SCM_BUS_QUERY_PROPERTY = 0x0059000c;
enum IOCTL_SCM_BUS_SET_PROPERTY = 0x00598014;
enum IOCTL_SCM_BUS_RUNTIME_FW_ACTIVATE = 0x00598010;
enum IOCTL_SCM_BUS_REFRESH_NAMESPACE = 0x00590018;
enum IOCTL_SCM_LD_GET_INTERLEAVE_SET = 0x00590c00;
enum IOCTL_SCM_PD_QUERY_PROPERTY = 0x00591800;
enum IOCTL_SCM_PD_FIRMWARE_DOWNLOAD = 0x00599804;
enum IOCTL_SCM_PD_FIRMWARE_ACTIVATE = 0x00599808;
enum IOCTL_SCM_PD_PASSTHROUGH = 0x0059d80c;
enum IOCTL_SCM_PD_UPDATE_MANAGEMENT_STATUS = 0x00591810;
enum IOCTL_SCM_PD_REINITIALIZE_MEDIA = 0x00599814;
enum IOCTL_SCM_PD_SET_PROPERTY = 0x00599818;
enum SCM_MAX_SYMLINK_LEN_IN_CHARS = 0x00000100;
enum MAX_INTERFACE_CODES = 0x00000008;
enum SCM_PD_FIRMWARE_REVISION_LENGTH_BYTES = 0x00000020;
enum SCM_PD_PROPERTY_NAME_LENGTH_IN_CHARS = 0x00000080;
enum SCM_PD_MAX_OPERATIONAL_STATUS = 0x00000010;
enum SCM_PD_FIRMWARE_LAST_DOWNLOAD = 0x00000001;
enum IOCTL_DISK_GET_DRIVE_GEOMETRY = 0x00070000;
enum IOCTL_DISK_GET_PARTITION_INFO = 0x00074004;
enum IOCTL_DISK_SET_PARTITION_INFO = 0x0007c008;
enum IOCTL_DISK_GET_DRIVE_LAYOUT = 0x0007400c;
enum IOCTL_DISK_SET_DRIVE_LAYOUT = 0x0007c010;
enum IOCTL_DISK_VERIFY = 0x00070014;
enum IOCTL_DISK_FORMAT_TRACKS = 0x0007c018;
enum IOCTL_DISK_REASSIGN_BLOCKS = 0x0007c01c;
enum IOCTL_DISK_PERFORMANCE = 0x00070020;
enum IOCTL_DISK_IS_WRITABLE = 0x00070024;
enum IOCTL_DISK_LOGGING = 0x00070028;
enum IOCTL_DISK_FORMAT_TRACKS_EX = 0x0007c02c;
enum IOCTL_DISK_HISTOGRAM_STRUCTURE = 0x00070030;
enum IOCTL_DISK_HISTOGRAM_DATA = 0x00070034;
enum IOCTL_DISK_HISTOGRAM_RESET = 0x00070038;
enum IOCTL_DISK_REQUEST_STRUCTURE = 0x0007003c;
enum IOCTL_DISK_REQUEST_DATA = 0x00070040;
enum IOCTL_DISK_PERFORMANCE_OFF = 0x00070060;
enum IOCTL_DISK_CONTROLLER_NUMBER = 0x00070044;
enum SMART_GET_VERSION = 0x00074080;
enum SMART_SEND_DRIVE_COMMAND = 0x0007c084;
enum SMART_RCV_DRIVE_DATA = 0x0007c088;
enum SMART_RCV_DRIVE_DATA_EX = 0x0007008c;
enum IOCTL_DISK_GET_PARTITION_INFO_EX = 0x00070048;
enum IOCTL_DISK_SET_PARTITION_INFO_EX = 0x0007c04c;
enum IOCTL_DISK_GET_DRIVE_LAYOUT_EX = 0x00070050;
enum IOCTL_DISK_SET_DRIVE_LAYOUT_EX = 0x0007c054;
enum IOCTL_DISK_CREATE_DISK = 0x0007c058;
enum IOCTL_DISK_GET_LENGTH_INFO = 0x0007405c;
enum IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = 0x000700a0;
enum IOCTL_DISK_REASSIGN_BLOCKS_EX = 0x0007c0a4;
enum IOCTL_DISK_UPDATE_DRIVE_SIZE = 0x0007c0c8;
enum IOCTL_DISK_GROW_PARTITION = 0x0007c0d0;
enum IOCTL_DISK_GET_CACHE_INFORMATION = 0x000740d4;
enum IOCTL_DISK_SET_CACHE_INFORMATION = 0x0007c0d8;
enum IOCTL_DISK_GET_WRITE_CACHE_STATE = 0x000740dc;
enum OBSOLETE_DISK_GET_WRITE_CACHE_STATE = 0x000740dc;
enum IOCTL_DISK_DELETE_DRIVE_LAYOUT = 0x0007c100;
enum IOCTL_DISK_UPDATE_PROPERTIES = 0x00070140;
enum IOCTL_DISK_FORMAT_DRIVE = 0x0007c3cc;
enum IOCTL_DISK_SENSE_DEVICE = 0x000703e0;
enum IOCTL_DISK_CHECK_VERIFY = 0x00074800;
enum IOCTL_DISK_MEDIA_REMOVAL = 0x00074804;
enum IOCTL_DISK_EJECT_MEDIA = 0x00074808;
enum IOCTL_DISK_LOAD_MEDIA = 0x0007480c;
enum IOCTL_DISK_RESERVE = 0x00074810;
enum IOCTL_DISK_RELEASE = 0x00074814;
enum IOCTL_DISK_FIND_NEW_DEVICES = 0x00074818;
enum IOCTL_DISK_GET_MEDIA_TYPES = 0x00070c00;
enum PARTITION_ENTRY_UNUSED = 0x00000000;
enum PARTITION_FAT_12 = 0x00000001;
enum PARTITION_XENIX_1 = 0x00000002;
enum PARTITION_XENIX_2 = 0x00000003;
enum PARTITION_FAT_16 = 0x00000004;
enum PARTITION_EXTENDED = 0x00000005;
enum PARTITION_HUGE = 0x00000006;
enum PARTITION_IFS = 0x00000007;
enum PARTITION_OS2BOOTMGR = 0x0000000a;
enum PARTITION_FAT32 = 0x0000000b;
enum PARTITION_FAT32_XINT13 = 0x0000000c;
enum PARTITION_XINT13 = 0x0000000e;
enum PARTITION_XINT13_EXTENDED = 0x0000000f;
enum PARTITION_MSFT_RECOVERY = 0x00000027;
enum PARTITION_MAIN_OS = 0x00000028;
enum PARTIITON_OS_DATA = 0x00000029;
enum PARTITION_PRE_INSTALLED = 0x0000002a;
enum PARTITION_BSP = 0x0000002b;
enum PARTITION_DPP = 0x0000002c;
enum PARTITION_WINDOWS_SYSTEM = 0x0000002d;
enum PARTITION_PREP = 0x00000041;
enum PARTITION_LDM = 0x00000042;
enum PARTITION_DM = 0x00000054;
enum PARTITION_EZDRIVE = 0x00000055;
enum PARTITION_UNIX = 0x00000063;
enum PARTITION_SPACES_DATA = 0x000000d7;
enum PARTITION_SPACES = 0x000000e7;
enum PARTITION_GPT = 0x000000ee;
enum PARTITION_SYSTEM = 0x000000ef;
enum VALID_NTFT = 0x000000c0;
enum PARTITION_NTFT = 0x00000080;
enum WMI_DISK_GEOMETRY_GUID = GUID(0x25007f51, 0x57c2, 0x11d1, [0xa5, 0x28, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10]);
enum GPT_ATTRIBUTE_NO_BLOCK_IO_PROTOCOL = 0x0000000000000002;
enum GPT_ATTRIBUTE_LEGACY_BIOS_BOOTABLE = 0x0000000000000004;
enum GPT_BASIC_DATA_ATTRIBUTE_OFFLINE = 0x0800000000000000;
enum GPT_BASIC_DATA_ATTRIBUTE_DAX = 0x0400000000000000;
enum GPT_BASIC_DATA_ATTRIBUTE_SERVICE = 0x0200000000000000;
enum GPT_SPACES_ATTRIBUTE_NO_METADATA = 0x8000000000000000;
enum HIST_NO_OF_BUCKETS = 0x00000018;
enum DISK_LOGGING_START = 0x00000000;
enum DISK_LOGGING_STOP = 0x00000001;
enum DISK_LOGGING_DUMP = 0x00000002;
enum DISK_BINNING = 0x00000003;
enum CAP_ATA_ID_CMD = 0x00000001;
enum CAP_ATAPI_ID_CMD = 0x00000002;
enum CAP_SMART_CMD = 0x00000004;
enum ATAPI_ID_CMD = 0x000000a1;
enum ID_CMD = 0x000000ec;
enum SMART_CMD = 0x000000b0;
enum SMART_CYL_LOW = 0x0000004f;
enum SMART_CYL_HI = 0x000000c2;
enum SMART_NO_ERROR = 0x00000000;
enum SMART_IDE_ERROR = 0x00000001;
enum SMART_INVALID_FLAG = 0x00000002;
enum SMART_INVALID_COMMAND = 0x00000003;
enum SMART_INVALID_BUFFER = 0x00000004;
enum SMART_INVALID_DRIVE = 0x00000005;
enum SMART_INVALID_IOCTL = 0x00000006;
enum SMART_ERROR_NO_MEM = 0x00000007;
enum SMART_INVALID_REGISTER = 0x00000008;
enum SMART_NOT_SUPPORTED = 0x00000009;
enum SMART_NO_IDE_DEVICE = 0x0000000a;
enum SMART_OFFLINE_ROUTINE_OFFLINE = 0x00000000;
enum SMART_SHORT_SELFTEST_OFFLINE = 0x00000001;
enum SMART_EXTENDED_SELFTEST_OFFLINE = 0x00000002;
enum SMART_ABORT_OFFLINE_SELFTEST = 0x0000007f;
enum SMART_SHORT_SELFTEST_CAPTIVE = 0x00000081;
enum SMART_EXTENDED_SELFTEST_CAPTIVE = 0x00000082;
enum READ_ATTRIBUTE_BUFFER_SIZE = 0x00000200;
enum IDENTIFY_BUFFER_SIZE = 0x00000200;
enum READ_THRESHOLD_BUFFER_SIZE = 0x00000200;
enum SMART_LOG_SECTOR_SIZE = 0x00000200;
enum READ_ATTRIBUTES = 0x000000d0;
enum READ_THRESHOLDS = 0x000000d1;
enum ENABLE_DISABLE_AUTOSAVE = 0x000000d2;
enum SAVE_ATTRIBUTE_VALUES = 0x000000d3;
enum EXECUTE_OFFLINE_DIAGS = 0x000000d4;
enum SMART_READ_LOG = 0x000000d5;
enum SMART_WRITE_LOG = 0x000000d6;
enum ENABLE_SMART = 0x000000d8;
enum DISABLE_SMART = 0x000000d9;
enum RETURN_SMART_STATUS = 0x000000da;
enum ENABLE_DISABLE_AUTO_OFFLINE = 0x000000db;
enum IOCTL_DISK_GET_DISK_ATTRIBUTES = 0x000700f0;
enum IOCTL_DISK_SET_DISK_ATTRIBUTES = 0x0007c0f4;
enum DISK_ATTRIBUTE_OFFLINE = 0x0000000000000001;
enum DISK_ATTRIBUTE_READ_ONLY = 0x0000000000000002;
enum IOCTL_DISK_RESET_SNAPSHOT_INFO = 0x0007c210;
enum IOCTL_CHANGER_GET_PARAMETERS = 0x00304000;
enum IOCTL_CHANGER_GET_STATUS = 0x00304004;
enum IOCTL_CHANGER_GET_PRODUCT_DATA = 0x00304008;
enum IOCTL_CHANGER_SET_ACCESS = 0x0030c010;
enum IOCTL_CHANGER_GET_ELEMENT_STATUS = 0x0030c014;
enum IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS = 0x00304018;
enum IOCTL_CHANGER_SET_POSITION = 0x0030401c;
enum IOCTL_CHANGER_EXCHANGE_MEDIUM = 0x00304020;
enum IOCTL_CHANGER_MOVE_MEDIUM = 0x00304024;
enum IOCTL_CHANGER_REINITIALIZE_TRANSPORT = 0x00304028;
enum IOCTL_CHANGER_QUERY_VOLUME_TAGS = 0x0030c02c;
enum MAX_VOLUME_ID_SIZE = 0x00000024;
enum MAX_VOLUME_TEMPLATE_SIZE = 0x00000028;
enum VENDOR_ID_LENGTH = 0x00000008;
enum PRODUCT_ID_LENGTH = 0x00000010;
enum REVISION_LENGTH = 0x00000004;
enum SERIAL_NUMBER_LENGTH = 0x00000020;
enum CHANGER_RESERVED_BIT = 0x80000000;
enum CHANGER_TO_TRANSPORT = 0x00000001;
enum CHANGER_TO_SLOT = 0x00000002;
enum CHANGER_TO_IEPORT = 0x00000004;
enum CHANGER_TO_DRIVE = 0x00000008;
enum LOCK_UNLOCK_IEPORT = 0x00000001;
enum LOCK_UNLOCK_DOOR = 0x00000002;
enum LOCK_UNLOCK_KEYPAD = 0x00000004;
enum LOCK_ELEMENT = 0x00000000;
enum UNLOCK_ELEMENT = 0x00000001;
enum EXTEND_IEPORT = 0x00000002;
enum RETRACT_IEPORT = 0x00000003;
enum ERROR_LABEL_UNREADABLE = 0x00000001;
enum ERROR_LABEL_QUESTIONABLE = 0x00000002;
enum ERROR_SLOT_NOT_PRESENT = 0x00000004;
enum ERROR_DRIVE_NOT_INSTALLED = 0x00000008;
enum ERROR_TRAY_MALFUNCTION = 0x00000010;
enum ERROR_INIT_STATUS_NEEDED = 0x00000011;
enum ERROR_UNHANDLED_ERROR = 0xffffffff;
enum SEARCH_ALL = 0x00000000;
enum SEARCH_PRIMARY = 0x00000001;
enum SEARCH_ALTERNATE = 0x00000002;
enum SEARCH_ALL_NO_SEQ = 0x00000004;
enum SEARCH_PRI_NO_SEQ = 0x00000005;
enum SEARCH_ALT_NO_SEQ = 0x00000006;
enum ASSERT_PRIMARY = 0x00000008;
enum ASSERT_ALTERNATE = 0x00000009;
enum REPLACE_PRIMARY = 0x0000000a;
enum REPLACE_ALTERNATE = 0x0000000b;
enum UNDEFINE_PRIMARY = 0x0000000c;
enum UNDEFINE_ALTERNATE = 0x0000000d;
enum IOCTL_SERIAL_LSRMST_INSERT = 0x001b007c;
enum IOCTL_SERENUM_EXPOSE_HARDWARE = 0x00370200;
enum IOCTL_SERENUM_REMOVE_HARDWARE = 0x00370204;
enum IOCTL_SERENUM_PORT_DESC = 0x00370208;
enum IOCTL_SERENUM_GET_PORT_NAME = 0x0037020c;
enum SERIAL_IOC_FCR_FIFO_ENABLE = 0x00000001;
enum SERIAL_IOC_FCR_RCVR_RESET = 0x00000002;
enum SERIAL_IOC_FCR_XMIT_RESET = 0x00000004;
enum SERIAL_IOC_FCR_DMA_MODE = 0x00000008;
enum SERIAL_IOC_FCR_RES1 = 0x00000010;
enum SERIAL_IOC_FCR_RES2 = 0x00000020;
enum SERIAL_IOC_FCR_RCVR_TRIGGER_LSB = 0x00000040;
enum SERIAL_IOC_FCR_RCVR_TRIGGER_MSB = 0x00000080;
enum SERIAL_IOC_MCR_DTR = 0x00000001;
enum SERIAL_IOC_MCR_RTS = 0x00000002;
enum SERIAL_IOC_MCR_OUT1 = 0x00000004;
enum SERIAL_IOC_MCR_OUT2 = 0x00000008;
enum SERIAL_IOC_MCR_LOOP = 0x00000010;
enum FSCTL_REQUEST_OPLOCK_LEVEL_1 = 0x00090000;
enum FSCTL_REQUEST_OPLOCK_LEVEL_2 = 0x00090004;
enum FSCTL_REQUEST_BATCH_OPLOCK = 0x00090008;
enum FSCTL_OPLOCK_BREAK_ACKNOWLEDGE = 0x0009000c;
enum FSCTL_OPBATCH_ACK_CLOSE_PENDING = 0x00090010;
enum FSCTL_OPLOCK_BREAK_NOTIFY = 0x00090014;
enum FSCTL_LOCK_VOLUME = 0x00090018;
enum FSCTL_UNLOCK_VOLUME = 0x0009001c;
enum FSCTL_DISMOUNT_VOLUME = 0x00090020;
enum FSCTL_IS_VOLUME_MOUNTED = 0x00090028;
enum FSCTL_IS_PATHNAME_VALID = 0x0009002c;
enum FSCTL_MARK_VOLUME_DIRTY = 0x00090030;
enum FSCTL_QUERY_RETRIEVAL_POINTERS = 0x0009003b;
enum FSCTL_GET_COMPRESSION = 0x0009003c;
enum FSCTL_SET_COMPRESSION = 0x0009c040;
enum FSCTL_SET_BOOTLOADER_ACCESSED = 0x0009004f;
enum FSCTL_MARK_AS_SYSTEM_HIVE = 0x0009004f;
enum FSCTL_OPLOCK_BREAK_ACK_NO_2 = 0x00090050;
enum FSCTL_INVALIDATE_VOLUMES = 0x00090054;
enum FSCTL_QUERY_FAT_BPB = 0x00090058;
enum FSCTL_REQUEST_FILTER_OPLOCK = 0x0009005c;
enum FSCTL_FILESYSTEM_GET_STATISTICS = 0x00090060;
enum FSCTL_GET_NTFS_VOLUME_DATA = 0x00090064;
enum FSCTL_GET_NTFS_FILE_RECORD = 0x00090068;
enum FSCTL_GET_VOLUME_BITMAP = 0x0009006f;
enum FSCTL_GET_RETRIEVAL_POINTERS = 0x00090073;
enum FSCTL_MOVE_FILE = 0x00090074;
enum FSCTL_IS_VOLUME_DIRTY = 0x00090078;
enum FSCTL_ALLOW_EXTENDED_DASD_IO = 0x00090083;
enum FSCTL_FIND_FILES_BY_SID = 0x0009008f;
enum FSCTL_SET_OBJECT_ID = 0x00090098;
enum FSCTL_GET_OBJECT_ID = 0x0009009c;
enum FSCTL_DELETE_OBJECT_ID = 0x000900a0;
enum FSCTL_SET_REPARSE_POINT = 0x000900a4;
enum FSCTL_GET_REPARSE_POINT = 0x000900a8;
enum FSCTL_DELETE_REPARSE_POINT = 0x000900ac;
enum FSCTL_ENUM_USN_DATA = 0x000900b3;
enum FSCTL_SECURITY_ID_CHECK = 0x000940b7;
enum FSCTL_READ_USN_JOURNAL = 0x000900bb;
enum FSCTL_SET_OBJECT_ID_EXTENDED = 0x000900bc;
enum FSCTL_CREATE_OR_GET_OBJECT_ID = 0x000900c0;
enum FSCTL_SET_SPARSE = 0x000900c4;
enum FSCTL_SET_ZERO_DATA = 0x000980c8;
enum FSCTL_QUERY_ALLOCATED_RANGES = 0x000940cf;
enum FSCTL_ENABLE_UPGRADE = 0x000980d0;
enum FSCTL_SET_ENCRYPTION = 0x000900d7;
enum FSCTL_ENCRYPTION_FSCTL_IO = 0x000900db;
enum FSCTL_WRITE_RAW_ENCRYPTED = 0x000900df;
enum FSCTL_READ_RAW_ENCRYPTED = 0x000900e3;
enum FSCTL_CREATE_USN_JOURNAL = 0x000900e7;
enum FSCTL_READ_FILE_USN_DATA = 0x000900eb;
enum FSCTL_WRITE_USN_CLOSE_RECORD = 0x000900ef;
enum FSCTL_EXTEND_VOLUME = 0x000900f0;
enum FSCTL_QUERY_USN_JOURNAL = 0x000900f4;
enum FSCTL_DELETE_USN_JOURNAL = 0x000900f8;
enum FSCTL_MARK_HANDLE = 0x000900fc;
enum FSCTL_SIS_COPYFILE = 0x00090100;
enum FSCTL_SIS_LINK_FILES = 0x0009c104;
enum FSCTL_RECALL_FILE = 0x00090117;
enum FSCTL_READ_FROM_PLEX = 0x0009411e;
enum FSCTL_FILE_PREFETCH = 0x00090120;
enum FSCTL_MAKE_MEDIA_COMPATIBLE = 0x00098130;
enum FSCTL_SET_DEFECT_MANAGEMENT = 0x00098134;
enum FSCTL_QUERY_SPARING_INFO = 0x00090138;
enum FSCTL_QUERY_ON_DISK_VOLUME_INFO = 0x0009013c;
enum FSCTL_SET_VOLUME_COMPRESSION_STATE = 0x00090140;
enum FSCTL_TXFS_MODIFY_RM = 0x00098144;
enum FSCTL_TXFS_QUERY_RM_INFORMATION = 0x00094148;
enum FSCTL_TXFS_ROLLFORWARD_REDO = 0x00098150;
enum FSCTL_TXFS_ROLLFORWARD_UNDO = 0x00098154;
enum FSCTL_TXFS_START_RM = 0x00098158;
enum FSCTL_TXFS_SHUTDOWN_RM = 0x0009815c;
enum FSCTL_TXFS_READ_BACKUP_INFORMATION = 0x00094160;
enum FSCTL_TXFS_WRITE_BACKUP_INFORMATION = 0x00098164;
enum FSCTL_TXFS_CREATE_SECONDARY_RM = 0x00098168;
enum FSCTL_TXFS_GET_METADATA_INFO = 0x0009416c;
enum FSCTL_TXFS_GET_TRANSACTED_VERSION = 0x00094170;
enum FSCTL_TXFS_SAVEPOINT_INFORMATION = 0x00098178;
enum FSCTL_TXFS_CREATE_MINIVERSION = 0x0009817c;
enum FSCTL_TXFS_TRANSACTION_ACTIVE = 0x0009418c;
enum FSCTL_SET_ZERO_ON_DEALLOCATION = 0x00090194;
enum FSCTL_SET_REPAIR = 0x00090198;
enum FSCTL_GET_REPAIR = 0x0009019c;
enum FSCTL_WAIT_FOR_REPAIR = 0x000901a0;
enum FSCTL_INITIATE_REPAIR = 0x000901a8;
enum FSCTL_CSC_INTERNAL = 0x000901af;
enum FSCTL_SHRINK_VOLUME = 0x000901b0;
enum FSCTL_SET_SHORT_NAME_BEHAVIOR = 0x000901b4;
enum FSCTL_DFSR_SET_GHOST_HANDLE_STATE = 0x000901b8;
enum FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES = 0x000941e0;
enum FSCTL_TXFS_LIST_TRANSACTIONS = 0x000941e4;
enum FSCTL_QUERY_PAGEFILE_ENCRYPTION = 0x000901e8;
enum FSCTL_RESET_VOLUME_ALLOCATION_HINTS = 0x000901ec;
enum FSCTL_QUERY_DEPENDENT_VOLUME = 0x000901f0;
enum FSCTL_SD_GLOBAL_CHANGE = 0x000901f4;
enum FSCTL_TXFS_READ_BACKUP_INFORMATION2 = 0x000901f8;
enum FSCTL_LOOKUP_STREAM_FROM_CLUSTER = 0x000901fc;
enum FSCTL_TXFS_WRITE_BACKUP_INFORMATION2 = 0x00090200;
enum FSCTL_FILE_TYPE_NOTIFICATION = 0x00090204;
enum FSCTL_FILE_LEVEL_TRIM = 0x00098208;
enum FSCTL_GET_BOOT_AREA_INFO = 0x00090230;
enum FSCTL_GET_RETRIEVAL_POINTER_BASE = 0x00090234;
enum FSCTL_SET_PERSISTENT_VOLUME_STATE = 0x00090238;
enum FSCTL_QUERY_PERSISTENT_VOLUME_STATE = 0x0009023c;
enum FSCTL_REQUEST_OPLOCK = 0x00090240;
enum FSCTL_CSV_TUNNEL_REQUEST = 0x00090244;
enum FSCTL_IS_CSV_FILE = 0x00090248;
enum FSCTL_QUERY_FILE_SYSTEM_RECOGNITION = 0x0009024c;
enum FSCTL_CSV_GET_VOLUME_PATH_NAME = 0x00090250;
enum FSCTL_CSV_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT = 0x00090254;
enum FSCTL_CSV_GET_VOLUME_PATH_NAMES_FOR_VOLUME_NAME = 0x00090258;
enum FSCTL_IS_FILE_ON_CSV_VOLUME = 0x0009025c;
enum FSCTL_CORRUPTION_HANDLING = 0x00090260;
enum FSCTL_OFFLOAD_READ = 0x00094264;
enum FSCTL_OFFLOAD_WRITE = 0x00098268;
enum FSCTL_CSV_INTERNAL = 0x0009026c;
enum FSCTL_SET_PURGE_FAILURE_MODE = 0x00090270;
enum FSCTL_QUERY_FILE_LAYOUT = 0x00090277;
enum FSCTL_IS_VOLUME_OWNED_BYCSVFS = 0x00090278;
enum FSCTL_GET_INTEGRITY_INFORMATION = 0x0009027c;
enum FSCTL_SET_INTEGRITY_INFORMATION = 0x0009c280;
enum FSCTL_QUERY_FILE_REGIONS = 0x00090284;
enum FSCTL_RKF_INTERNAL = 0x000902af;
enum FSCTL_SCRUB_DATA = 0x000902b0;
enum FSCTL_REPAIR_COPIES = 0x0009c2b4;
enum FSCTL_DISABLE_LOCAL_BUFFERING = 0x000902b8;
enum FSCTL_CSV_MGMT_LOCK = 0x000902bc;
enum FSCTL_CSV_QUERY_DOWN_LEVEL_FILE_SYSTEM_CHARACTERISTICS = 0x000902c0;
enum FSCTL_ADVANCE_FILE_ID = 0x000902c4;
enum FSCTL_CSV_SYNC_TUNNEL_REQUEST = 0x000902c8;
enum FSCTL_CSV_QUERY_VETO_FILE_DIRECT_IO = 0x000902cc;
enum FSCTL_WRITE_USN_REASON = 0x000902d0;
enum FSCTL_CSV_CONTROL = 0x000902d4;
enum FSCTL_GET_REFS_VOLUME_DATA = 0x000902d8;
enum FSCTL_CSV_H_BREAKING_SYNC_TUNNEL_REQUEST = 0x000902e4;
enum FSCTL_QUERY_STORAGE_CLASSES = 0x000902ec;
enum FSCTL_QUERY_REGION_INFO = 0x000902f0;
enum FSCTL_USN_TRACK_MODIFIED_RANGES = 0x000902f4;
enum FSCTL_QUERY_SHARED_VIRTUAL_DISK_SUPPORT = 0x00090300;
enum FSCTL_SVHDX_SYNC_TUNNEL_REQUEST = 0x00090304;
enum FSCTL_SVHDX_SET_INITIATOR_INFORMATION = 0x00090308;
enum FSCTL_SET_EXTERNAL_BACKING = 0x0009030c;
enum FSCTL_GET_EXTERNAL_BACKING = 0x00090310;
enum FSCTL_DELETE_EXTERNAL_BACKING = 0x00090314;
enum FSCTL_ENUM_EXTERNAL_BACKING = 0x00090318;
enum FSCTL_ENUM_OVERLAY = 0x0009031f;
enum FSCTL_ADD_OVERLAY = 0x00098330;
enum FSCTL_REMOVE_OVERLAY = 0x00098334;
enum FSCTL_UPDATE_OVERLAY = 0x00098338;
enum FSCTL_SHUFFLE_FILE = 0x0009c340;
enum FSCTL_DUPLICATE_EXTENTS_TO_FILE = 0x00098344;
enum FSCTL_SPARSE_OVERALLOCATE = 0x0009034c;
enum FSCTL_STORAGE_QOS_CONTROL = 0x00090350;
enum FSCTL_INITIATE_FILE_METADATA_OPTIMIZATION = 0x0009035c;
enum FSCTL_QUERY_FILE_METADATA_OPTIMIZATION = 0x00090360;
enum FSCTL_SVHDX_ASYNC_TUNNEL_REQUEST = 0x00090364;
enum FSCTL_GET_WOF_VERSION = 0x00090368;
enum FSCTL_HCS_SYNC_TUNNEL_REQUEST = 0x0009036c;
enum FSCTL_HCS_ASYNC_TUNNEL_REQUEST = 0x00090370;
enum FSCTL_QUERY_EXTENT_READ_CACHE_INFO = 0x00090377;
enum FSCTL_QUERY_REFS_VOLUME_COUNTER_INFO = 0x0009037b;
enum FSCTL_CLEAN_VOLUME_METADATA = 0x0009037c;
enum FSCTL_SET_INTEGRITY_INFORMATION_EX = 0x00090380;
enum FSCTL_SUSPEND_OVERLAY = 0x00090384;
enum FSCTL_VIRTUAL_STORAGE_QUERY_PROPERTY = 0x00090388;
enum FSCTL_FILESYSTEM_GET_STATISTICS_EX = 0x0009038c;
enum FSCTL_QUERY_VOLUME_CONTAINER_STATE = 0x00090390;
enum FSCTL_SET_LAYER_ROOT = 0x00090394;
enum FSCTL_QUERY_DIRECT_ACCESS_EXTENTS = 0x0009039b;
enum FSCTL_NOTIFY_STORAGE_SPACE_ALLOCATION = 0x0009039c;
enum FSCTL_SSDI_STORAGE_REQUEST = 0x000903a0;
enum FSCTL_QUERY_DIRECT_IMAGE_ORIGINAL_BASE = 0x000903a4;
enum FSCTL_READ_UNPRIVILEGED_USN_JOURNAL = 0x000903ab;
enum FSCTL_GHOST_FILE_EXTENTS = 0x000983ac;
enum FSCTL_QUERY_GHOSTED_FILE_EXTENTS = 0x000903b0;
enum FSCTL_UNMAP_SPACE = 0x000903b4;
enum FSCTL_HCS_SYNC_NO_WRITE_TUNNEL_REQUEST = 0x000903b8;
enum FSCTL_START_VIRTUALIZATION_INSTANCE = 0x000903c0;
enum FSCTL_GET_FILTER_FILE_IDENTIFIER = 0x000903c4;
enum FSCTL_STREAMS_QUERY_PARAMETERS = 0x000903c4;
enum FSCTL_STREAMS_ASSOCIATE_ID = 0x000903c8;
enum FSCTL_STREAMS_QUERY_ID = 0x000903cc;
enum FSCTL_GET_RETRIEVAL_POINTERS_AND_REFCOUNT = 0x000903d3;
enum FSCTL_QUERY_VOLUME_NUMA_INFO = 0x000903d4;
enum FSCTL_REFS_DEALLOCATE_RANGES = 0x000903d8;
enum FSCTL_QUERY_REFS_SMR_VOLUME_INFO = 0x000903dc;
enum FSCTL_SET_REFS_SMR_VOLUME_GC_PARAMETERS = 0x000903e0;
enum FSCTL_SET_REFS_FILE_STRICTLY_SEQUENTIAL = 0x000903e4;
enum FSCTL_DUPLICATE_EXTENTS_TO_FILE_EX = 0x000983e8;
enum FSCTL_QUERY_BAD_RANGES = 0x000903ec;
enum FSCTL_SET_DAX_ALLOC_ALIGNMENT_HINT = 0x000903f0;
enum FSCTL_DELETE_CORRUPTED_REFS_CONTAINER = 0x000903f4;
enum FSCTL_SCRUB_UNDISCOVERABLE_ID = 0x000903f8;
enum FSCTL_NOTIFY_DATA_CHANGE = 0x000903fc;
enum FSCTL_START_VIRTUALIZATION_INSTANCE_EX = 0x00090400;
enum FSCTL_ENCRYPTION_KEY_CONTROL = 0x00090404;
enum FSCTL_VIRTUAL_STORAGE_SET_BEHAVIOR = 0x00090408;
enum FSCTL_SET_REPARSE_POINT_EX = 0x0009040c;
enum FSCTL_REARRANGE_FILE = 0x0009c420;
enum FSCTL_VIRTUAL_STORAGE_PASSTHROUGH = 0x00090424;
enum FSCTL_GET_RETRIEVAL_POINTER_COUNT = 0x0009042b;
enum FSCTL_ENABLE_PER_IO_FLAGS = 0x0009042c;
enum FSCTL_QUERY_ASYNC_DUPLICATE_EXTENTS_STATUS = 0x00090430;
enum FSCTL_SMB_SHARE_FLUSH_AND_PURGE = 0x0009043c;
enum FSCTL_REFS_STREAM_SNAPSHOT_MANAGEMENT = 0x00090440;
enum FSCTL_MANAGE_BYPASS_IO = 0x00090448;
enum FSCTL_REFS_DEALLOCATE_RANGES_EX = 0x0009044c;
enum FSCTL_SET_CACHED_RUNS_STATE = 0x00090450;
enum FSCTL_REFS_SET_VOLUME_COMPRESSION_INFO = 0x00090454;
enum FSCTL_REFS_QUERY_VOLUME_COMPRESSION_INFO = 0x00090458;
enum FSCTL_DUPLICATE_CLUSTER = 0x0009045c;
enum FSCTL_CREATE_LCN_WEAK_REFERENCE = 0x00090460;
enum FSCTL_DELETE_LCN_WEAK_REFERENCE = 0x00090464;
enum FSCTL_QUERY_LCN_WEAK_REFERENCE = 0x00090468;
enum FSCTL_DELETE_LCN_WEAK_REFERENCES = 0x0009046c;
enum FSCTL_REFS_SET_VOLUME_DEDUP_INFO = 0x00090470;
enum FSCTL_REFS_QUERY_VOLUME_DEDUP_INFO = 0x00090474;
enum FSCTL_LMR_QUERY_INFO = 0x00090478;
enum GET_VOLUME_BITMAP_FLAG_MASK_METADATA = 0x00000001;
enum FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE = 0x00000001;
enum USN_PAGE_SIZE = 0x00001000;
enum USN_REASON_DATA_OVERWRITE = 0x00000001;
enum USN_REASON_DATA_EXTEND = 0x00000002;
enum USN_REASON_DATA_TRUNCATION = 0x00000004;
enum USN_REASON_NAMED_DATA_OVERWRITE = 0x00000010;
enum USN_REASON_NAMED_DATA_EXTEND = 0x00000020;
enum USN_REASON_NAMED_DATA_TRUNCATION = 0x00000040;
enum USN_REASON_FILE_CREATE = 0x00000100;
enum USN_REASON_FILE_DELETE = 0x00000200;
enum USN_REASON_EA_CHANGE = 0x00000400;
enum USN_REASON_SECURITY_CHANGE = 0x00000800;
enum USN_REASON_RENAME_OLD_NAME = 0x00001000;
enum USN_REASON_RENAME_NEW_NAME = 0x00002000;
enum USN_REASON_INDEXABLE_CHANGE = 0x00004000;
enum USN_REASON_BASIC_INFO_CHANGE = 0x00008000;
enum USN_REASON_HARD_LINK_CHANGE = 0x00010000;
enum USN_REASON_COMPRESSION_CHANGE = 0x00020000;
enum USN_REASON_ENCRYPTION_CHANGE = 0x00040000;
enum USN_REASON_OBJECT_ID_CHANGE = 0x00080000;
enum USN_REASON_REPARSE_POINT_CHANGE = 0x00100000;
enum USN_REASON_STREAM_CHANGE = 0x00200000;
enum USN_REASON_TRANSACTED_CHANGE = 0x00400000;
enum USN_REASON_INTEGRITY_CHANGE = 0x00800000;
enum USN_REASON_DESIRED_STORAGE_CLASS_CHANGE = 0x01000000;
enum USN_REASON_CLOSE = 0x80000000;
enum USN_DELETE_VALID_FLAGS = 0x00000003;
enum MARK_HANDLE_PROTECT_CLUSTERS = 0x00000001;
enum MARK_HANDLE_TXF_SYSTEM_LOG = 0x00000004;
enum MARK_HANDLE_NOT_TXF_SYSTEM_LOG = 0x00000008;
enum MARK_HANDLE_REALTIME = 0x00000020;
enum MARK_HANDLE_NOT_REALTIME = 0x00000040;
enum MARK_HANDLE_CLOUD_SYNC = 0x00000800;
enum MARK_HANDLE_READ_COPY = 0x00000080;
enum MARK_HANDLE_NOT_READ_COPY = 0x00000100;
enum MARK_HANDLE_FILTER_METADATA = 0x00000200;
enum MARK_HANDLE_RETURN_PURGE_FAILURE = 0x00000400;
enum MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION = 0x00001000;
enum MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO = 0x00002000;
enum MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES = 0x00004000;
enum MARK_HANDLE_SUPPRESS_VOLUME_OPEN_FLUSH = 0x00008000;
enum MARK_HANDLE_ENABLE_CPU_CACHE = 0x10000000;
enum VOLUME_IS_DIRTY = 0x00000001;
enum VOLUME_UPGRADE_SCHEDULED = 0x00000002;
enum VOLUME_SESSION_OPEN = 0x00000004;
enum FILE_PREFETCH_TYPE_FOR_CREATE = 0x00000001;
enum FILE_PREFETCH_TYPE_FOR_DIRENUM = 0x00000002;
enum FILE_PREFETCH_TYPE_FOR_CREATE_EX = 0x00000003;
enum FILE_PREFETCH_TYPE_FOR_DIRENUM_EX = 0x00000004;
enum FILE_PREFETCH_TYPE_MAX = 0x00000004;
enum FILESYSTEM_STATISTICS_TYPE_REFS = 0x00000004;
enum FILE_ZERO_DATA_INFORMATION_FLAG_PRESERVE_CACHED_DATA = 0x00000001;
enum FILE_SET_ENCRYPTION = 0x00000001;
enum FILE_CLEAR_ENCRYPTION = 0x00000002;
enum STREAM_SET_ENCRYPTION = 0x00000003;
enum STREAM_CLEAR_ENCRYPTION = 0x00000004;
enum MAXIMUM_ENCRYPTION_VALUE = 0x00000004;
enum ENCRYPTION_FORMAT_DEFAULT = 0x00000001;
enum ENCRYPTED_DATA_INFO_SPARSE_FILE = 0x00000001;
enum COPYFILE_SIS_LINK = 0x00000001;
enum COPYFILE_SIS_REPLACE = 0x00000002;
enum COPYFILE_SIS_FLAGS = 0x00000003;
enum SET_REPAIR_ENABLED = 0x00000001;
enum SET_REPAIR_WARN_ABOUT_DATA_LOSS = 0x00000008;
enum SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT = 0x00000010;
enum SET_REPAIR_VALID_MASK = 0x00000019;
enum FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_IN_USE = 0x0000000000000001;
enum FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_REUSED = 0x0000000000000002;
enum FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_EXIST = 0x0000000000000004;
enum FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_BASE_RECORD = 0x0000000000000008;
enum FILE_INITIATE_REPAIR_HINT1_SYSTEM_FILE = 0x0000000000000010;
enum FILE_INITIATE_REPAIR_HINT1_NOT_IMPLEMENTED = 0x0000000000000020;
enum FILE_INITIATE_REPAIR_HINT1_UNABLE_TO_REPAIR = 0x0000000000000040;
enum FILE_INITIATE_REPAIR_HINT1_REPAIR_DISABLED = 0x0000000000000080;
enum FILE_INITIATE_REPAIR_HINT1_RECURSIVELY_CORRUPTED = 0x0000000000000100;
enum FILE_INITIATE_REPAIR_HINT1_ORPHAN_GENERATED = 0x0000000000000200;
enum FILE_INITIATE_REPAIR_HINT1_REPAIRED = 0x0000000000000400;
enum FILE_INITIATE_REPAIR_HINT1_NOTHING_WRONG = 0x0000000000000800;
enum FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NOT_FOUND = 0x0000000000001000;
enum FILE_INITIATE_REPAIR_HINT1_POTENTIAL_CROSSLINK = 0x0000000000002000;
enum FILE_INITIATE_REPAIR_HINT1_STALE_INFORMATION = 0x0000000000004000;
enum FILE_INITIATE_REPAIR_HINT1_CLUSTERS_ALREADY_IN_USE = 0x0000000000008000;
enum FILE_INITIATE_REPAIR_HINT1_LCN_NOT_EXIST = 0x0000000000010000;
enum FILE_INITIATE_REPAIR_HINT1_INVALID_RUN_LENGTH = 0x0000000000020000;
enum FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_ORPHAN = 0x0000000000040000;
enum FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_IS_BASE_RECORD = 0x0000000000080000;
enum FILE_INITIATE_REPAIR_HINT1_INVALID_ARRAY_LENGTH_COUNT = 0x0000000000100000;
enum FILE_INITIATE_REPAIR_HINT1_SID_VALID = 0x0000000000200000;
enum FILE_INITIATE_REPAIR_HINT1_SID_MISMATCH = 0x0000000000400000;
enum FILE_INITIATE_REPAIR_HINT1_INVALID_PARENT = 0x0000000000800000;
enum FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_IN_USE = 0x0000000001000000;
enum FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_REUSED = 0x0000000002000000;
enum FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_EXIST = 0x0000000004000000;
enum FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_BASE_RECORD = 0x0000000008000000;
enum FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_INDEX = 0x0000000010000000;
enum FILE_INITIATE_REPAIR_HINT1_VALID_INDEX_ENTRY = 0x0000000020000000;
enum FILE_INITIATE_REPAIR_HINT1_OUT_OF_GENERIC_NAMES = 0x0000000040000000;
enum FILE_INITIATE_REPAIR_HINT1_OUT_OF_RESOURCE = 0x0000000080000000;
enum FILE_INITIATE_REPAIR_HINT1_INVALID_LCN = 0x0000000100000000;
enum FILE_INITIATE_REPAIR_HINT1_INVALID_VCN = 0x0000000200000000;
enum FILE_INITIATE_REPAIR_HINT1_NAME_CONFLICT = 0x0000000400000000;
enum FILE_INITIATE_REPAIR_HINT1_ORPHAN = 0x0000000800000000;
enum FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_TOO_SMALL = 0x0000001000000000;
enum FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NON_RESIDENT = 0x0000002000000000;
enum FILE_INITIATE_REPAIR_HINT1_DENY_DEFRAG = 0x0000004000000000;
enum FILE_INITIATE_REPAIR_HINT1_PREVIOUS_PARENT_STILL_VALID = 0x0000008000000000;
enum FILE_INITIATE_REPAIR_HINT1_INDEX_ENTRY_MISMATCH = 0x0000010000000000;
enum FILE_INITIATE_REPAIR_HINT1_INVALID_ORPHAN_RECOVERY_NAME = 0x0000020000000000;
enum FILE_INITIATE_REPAIR_HINT1_MULTIPLE_FILE_NAME_ATTRIBUTES = 0x0000040000000000;
enum TXFS_LOGGING_MODE_SIMPLE = 0x00000001;
enum TXFS_LOGGING_MODE_FULL = 0x00000002;
enum TXFS_TRANSACTION_STATE_NONE = 0x00000000;
enum TXFS_TRANSACTION_STATE_ACTIVE = 0x00000001;
enum TXFS_TRANSACTION_STATE_PREPARED = 0x00000002;
enum TXFS_TRANSACTION_STATE_NOTACTIVE = 0x00000003;
enum TXFS_RM_STATE_NOT_STARTED = 0x00000000;
enum TXFS_RM_STATE_STARTING = 0x00000001;
enum TXFS_RM_STATE_ACTIVE = 0x00000002;
enum TXFS_RM_STATE_SHUTTING_DOWN = 0x00000003;
enum TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN = 0x00000001;
enum TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK = 0x00000002;
enum TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX = 0x00000001;
enum TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN = 0x00000002;
enum TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE = 0x00000004;
enum TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS = 0x00000008;
enum TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT = 0x00000010;
enum TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE = 0x00000020;
enum TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX = 0x00000040;
enum TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN = 0x00000080;
enum TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT = 0x00000200;
enum TXFS_START_RM_FLAG_LOGGING_MODE = 0x00000400;
enum TXFS_START_RM_FLAG_PRESERVE_CHANGES = 0x00000800;
enum TXFS_START_RM_FLAG_PREFER_CONSISTENCY = 0x00001000;
enum TXFS_START_RM_FLAG_PREFER_AVAILABILITY = 0x00002000;
enum TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED = 0x00000001;
enum TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED = 0x00000002;
enum TXFS_TRANSACTED_VERSION_NONTRANSACTED = 0xfffffffe;
enum TXFS_TRANSACTED_VERSION_UNCOMMITTED = 0xffffffff;
enum TXFS_SAVEPOINT_SET = 0x00000001;
enum TXFS_SAVEPOINT_ROLLBACK = 0x00000002;
enum TXFS_SAVEPOINT_CLEAR = 0x00000004;
enum TXFS_SAVEPOINT_CLEAR_ALL = 0x00000010;
enum PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED = 0x00000001;
enum PERSISTENT_VOLUME_STATE_VOLUME_SCRUB_DISABLED = 0x00000002;
enum PERSISTENT_VOLUME_STATE_GLOBAL_METADATA_NO_SEEK_PENALTY = 0x00000004;
enum PERSISTENT_VOLUME_STATE_LOCAL_METADATA_NO_SEEK_PENALTY = 0x00000008;
enum PERSISTENT_VOLUME_STATE_NO_HEAT_GATHERING = 0x00000010;
enum PERSISTENT_VOLUME_STATE_CONTAINS_BACKING_WIM = 0x00000020;
enum PERSISTENT_VOLUME_STATE_BACKED_BY_WIM = 0x00000040;
enum PERSISTENT_VOLUME_STATE_NO_WRITE_AUTO_TIERING = 0x00000080;
enum PERSISTENT_VOLUME_STATE_TXF_DISABLED = 0x00000100;
enum PERSISTENT_VOLUME_STATE_REALLOCATE_ALL_DATA_WRITES = 0x00000200;
enum PERSISTENT_VOLUME_STATE_CHKDSK_RAN_ONCE = 0x00000400;
enum PERSISTENT_VOLUME_STATE_MODIFIED_BY_CHKDSK = 0x00000800;
enum PERSISTENT_VOLUME_STATE_DAX_FORMATTED = 0x00001000;
enum OPLOCK_LEVEL_CACHE_READ = 0x00000001;
enum OPLOCK_LEVEL_CACHE_HANDLE = 0x00000002;
enum OPLOCK_LEVEL_CACHE_WRITE = 0x00000004;
enum REQUEST_OPLOCK_INPUT_FLAG_REQUEST = 0x00000001;
enum REQUEST_OPLOCK_INPUT_FLAG_ACK = 0x00000002;
enum REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE = 0x00000004;
enum REQUEST_OPLOCK_CURRENT_VERSION = 0x00000001;
enum REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED = 0x00000001;
enum REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED = 0x00000002;
enum QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_HOST_VOLUMES = 0x00000001;
enum QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_GUEST_VOLUMES = 0x00000002;
enum SD_GLOBAL_CHANGE_TYPE_MACHINE_SID = 0x00000001;
enum SD_GLOBAL_CHANGE_TYPE_QUERY_STATS = 0x00010000;
enum SD_GLOBAL_CHANGE_TYPE_ENUM_SDS = 0x00020000;
enum LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE = 0x00000001;
enum LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET = 0x00000002;
enum LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE = 0x00000004;
enum LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE = 0x00000008;
enum LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK = 0xff000000;
enum LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA = 0x01000000;
enum LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX = 0x02000000;
enum LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM = 0x03000000;
enum FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN = 0x00000001;
enum FILE_TYPE_NOTIFICATION_FLAG_USAGE_END = 0x00000002;
enum FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE = GUID(0xd0a64a1, 0x38fc, 0x4db8, [0x9f, 0xe7, 0x3f, 0x43, 0x52, 0xcd, 0x7c, 0x5c]);
enum FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE = GUID(0xb7624d64, 0xb9a3, 0x4cf8, [0x80, 0x11, 0x5b, 0x86, 0xc9, 0x40, 0xe7, 0xb7]);
enum FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE = GUID(0x9d453eb7, 0xd2a6, 0x4dbd, [0xa2, 0xe3, 0xfb, 0xd0, 0xed, 0x91, 0x9, 0xa9]);
enum CSV_MGMTLOCK_CHECK_VOLUME_REDIRECTED = 0x00000001;
enum CSV_INVALID_DEVICE_NUMBER = 0xffffffff;
enum CSV_QUERY_MDS_PATH_V2_VERSION_1 = 0x00000001;
enum CSV_QUERY_MDS_PATH_FLAG_STORAGE_ON_THIS_NODE_IS_CONNECTED = 0x00000001;
enum CSV_QUERY_MDS_PATH_FLAG_CSV_DIRECT_IO_ENABLED = 0x00000002;
enum CSV_QUERY_MDS_PATH_FLAG_SMB_BYPASS_CSV_ENABLED = 0x00000004;
enum QUERY_FILE_LAYOUT_RESTART = 0x00000001;
enum QUERY_FILE_LAYOUT_INCLUDE_NAMES = 0x00000002;
enum QUERY_FILE_LAYOUT_INCLUDE_STREAMS = 0x00000004;
enum QUERY_FILE_LAYOUT_INCLUDE_EXTENTS = 0x00000008;
enum QUERY_FILE_LAYOUT_INCLUDE_EXTRA_INFO = 0x00000010;
enum QUERY_FILE_LAYOUT_INCLUDE_STREAMS_WITH_NO_CLUSTERS_ALLOCATED = 0x00000020;
enum QUERY_FILE_LAYOUT_INCLUDE_FULL_PATH_IN_NAMES = 0x00000040;
enum QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION = 0x00000080;
enum QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DSC_ATTRIBUTE = 0x00000100;
enum QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_TXF_ATTRIBUTE = 0x00000200;
enum QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EFS_ATTRIBUTE = 0x00000400;
enum QUERY_FILE_LAYOUT_INCLUDE_ONLY_FILES_WITH_SPECIFIC_ATTRIBUTES = 0x00000800;
enum QUERY_FILE_LAYOUT_INCLUDE_FILES_WITH_DSC_ATTRIBUTE = 0x00001000;
enum QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DATA_ATTRIBUTE = 0x00002000;
enum QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_REPARSE_ATTRIBUTE = 0x00004000;
enum QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EA_ATTRIBUTE = 0x00008000;
enum QUERY_FILE_LAYOUT_SINGLE_INSTANCED = 0x00000001;
enum FILE_LAYOUT_NAME_ENTRY_PRIMARY = 0x00000001;
enum FILE_LAYOUT_NAME_ENTRY_DOS = 0x00000002;
enum STREAM_LAYOUT_ENTRY_IMMOVABLE = 0x00000001;
enum STREAM_LAYOUT_ENTRY_PINNED = 0x00000002;
enum STREAM_LAYOUT_ENTRY_RESIDENT = 0x00000004;
enum STREAM_LAYOUT_ENTRY_NO_CLUSTERS_ALLOCATED = 0x00000008;
enum STREAM_LAYOUT_ENTRY_HAS_INFORMATION = 0x00000010;
enum STREAM_EXTENT_ENTRY_AS_RETRIEVAL_POINTERS = 0x00000001;
enum STREAM_EXTENT_ENTRY_ALL_EXTENTS = 0x00000002;
enum CHECKSUM_TYPE_UNCHANGED = 0xffffffffffffffff;
enum CHECKSUM_TYPE_NONE = 0x00000000;
enum CHECKSUM_TYPE_CRC32 = 0x00000001;
enum CHECKSUM_TYPE_CRC64 = 0x00000002;
enum CHECKSUM_TYPE_ECC = 0x00000003;
enum CHECKSUM_TYPE_FIRST_UNUSED_TYPE = 0x00000004;
enum FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF = 0x00000001;
enum OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_CURRENT_RANGE = 0x00000001;
enum SET_PURGE_FAILURE_MODE_ENABLED = 0x00000001;
enum SET_PURGE_FAILURE_MODE_DISABLED = 0x00000002;
enum FILE_REGION_USAGE_VALID_CACHED_DATA = 0x00000001;
enum FILE_REGION_USAGE_VALID_NONCACHED_DATA = 0x00000002;
enum FILE_REGION_USAGE_OTHER_PAGE_ALIGNMENT = 0x00000004;
enum FILE_REGION_USAGE_LARGE_PAGE_ALIGNMENT = 0x00000008;
enum FILE_REGION_USAGE_HUGE_PAGE_ALIGNMENT = 0x00000010;
enum FILE_REGION_USAGE_QUERY_ALIGNMENT = 0x00000008;
enum FILE_STORAGE_TIER_NAME_LENGTH = 0x00000100;
enum FILE_STORAGE_TIER_DESCRIPTION_LENGTH = 0x00000200;
enum FILE_STORAGE_TIER_FLAG_WRITE_BACK_CACHE = 0x00200000;
enum FILE_STORAGE_TIER_FLAG_READ_CACHE = 0x00400000;
enum FILE_STORAGE_TIER_FLAG_PARITY = 0x00800000;
enum FILE_STORAGE_TIER_FLAG_SMR = 0x01000000;
enum QUERY_STORAGE_CLASSES_FLAGS_MEASURE_WRITE = 0x80000000;
enum QUERY_STORAGE_CLASSES_FLAGS_MEASURE_READ = 0x40000000;
enum QUERY_STORAGE_CLASSES_FLAGS_NO_DEFRAG_VOLUME = 0x20000000;
enum QUERY_FILE_LAYOUT_REPARSE_DATA_INVALID = 0x00000001;
enum QUERY_FILE_LAYOUT_REPARSE_TAG_INVALID = 0x00000002;
enum DUPLICATE_EXTENTS_DATA_EX_SOURCE_ATOMIC = 0x00000001;
enum DUPLICATE_EXTENTS_DATA_EX_ASYNC = 0x00000002;
enum REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V0 = 0x00000000;
enum REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V1 = 0x00000001;
enum REFS_SMR_VOLUME_GC_PARAMETERS_VERSION_V1 = 0x00000001;
enum STREAMS_INVALID_ID = 0x00000000;
enum STREAMS_MAX_ID = 0x0000ffff;
enum STREAMS_ASSOCIATE_ID_CLEAR = 0x00000001;
enum STREAMS_ASSOCIATE_ID_SET = 0x00000002;
enum DAX_ALLOC_ALIGNMENT_FLAG_MANDATORY = 0x00000001;
enum DAX_ALLOC_ALIGNMENT_FLAG_FALLBACK_SPECIFIED = 0x00000002;
enum WOF_CURRENT_VERSION = 0x00000001;
enum WOF_PROVIDER_CLOUD = 0x00000003;
enum WIM_PROVIDER_CURRENT_VERSION = 0x00000001;
enum WIM_PROVIDER_EXTERNAL_FLAG_NOT_ACTIVE = 0x00000001;
enum WIM_PROVIDER_EXTERNAL_FLAG_SUSPENDED = 0x00000002;
enum FILE_PROVIDER_CURRENT_VERSION = 0x00000001;
enum FILE_PROVIDER_SINGLE_FILE = 0x00000001;
enum FILE_PROVIDER_COMPRESSION_MAXIMUM = 0x00000004;
enum FILE_PROVIDER_FLAG_COMPRESS_ON_WRITE = 0x00000001;
enum CONTAINER_VOLUME_STATE_HOSTING_CONTAINER = 0x00000001;
enum CONTAINER_ROOT_INFO_FLAG_SCRATCH_ROOT = 0x00000001;
enum CONTAINER_ROOT_INFO_FLAG_LAYER_ROOT = 0x00000002;
enum CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_ROOT = 0x00000004;
enum CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_TARGET_ROOT = 0x00000008;
enum CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_EXCEPTION_ROOT = 0x00000010;
enum CONTAINER_ROOT_INFO_FLAG_BIND_ROOT = 0x00000020;
enum CONTAINER_ROOT_INFO_FLAG_BIND_TARGET_ROOT = 0x00000040;
enum CONTAINER_ROOT_INFO_FLAG_BIND_EXCEPTION_ROOT = 0x00000080;
enum CONTAINER_ROOT_INFO_FLAG_BIND_DO_NOT_MAP_NAME = 0x00000100;
enum CONTAINER_ROOT_INFO_FLAG_UNION_LAYER_ROOT = 0x00000200;
enum CONTAINER_ROOT_INFO_VALID_FLAGS = 0x000003ff;
enum PROJFS_PROTOCOL_VERSION = 0x00000003;
enum EFS_TRACKED_OFFSET_HEADER_FLAG = 0x00000001;
enum SPACES_TRACKED_OFFSET_HEADER_FLAG = 0x00000002;
alias GPT_ATTRIBUTES = ulong;
enum : ulong
{
    GPT_ATTRIBUTE_PLATFORM_REQUIRED          = 0x0000000000000001,
    GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER = 0x8000000000000000,
    GPT_BASIC_DATA_ATTRIBUTE_HIDDEN          = 0x4000000000000000,
    GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY     = 0x2000000000000000,
    GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY       = 0x1000000000000000,
}

alias USN_DELETE_FLAGS = uint;
enum : uint
{
    USN_DELETE_FLAG_DELETE = 0x00000001,
    USN_DELETE_FLAG_NOTIFY = 0x00000002,
}

alias CHANGER_FEATURES = uint;
enum : uint
{
    CHANGER_BAR_CODE_SCANNER_INSTALLED  = 0x00000001,
    CHANGER_CARTRIDGE_MAGAZINE          = 0x00000100,
    CHANGER_CLEANER_ACCESS_NOT_VALID    = 0x00040000,
    CHANGER_CLEANER_SLOT                = 0x00000040,
    CHANGER_CLOSE_IEPORT                = 0x00000004,
    CHANGER_DEVICE_REINITIALIZE_CAPABLE = 0x08000000,
    CHANGER_DRIVE_CLEANING_REQUIRED     = 0x00010000,
    CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS  = 0x20000000,
    CHANGER_EXCHANGE_MEDIA              = 0x00000020,
    CHANGER_INIT_ELEM_STAT_WITH_RANGE   = 0x00000002,
    CHANGER_KEYPAD_ENABLE_DISABLE       = 0x10000000,
    CHANGER_LOCK_UNLOCK                 = 0x00000080,
    CHANGER_MEDIUM_FLIP                 = 0x00000200,
    CHANGER_OPEN_IEPORT                 = 0x00000008,
    CHANGER_POSITION_TO_ELEMENT         = 0x00000400,
    CHANGER_PREDISMOUNT_EJECT_REQUIRED  = 0x00020000,
    CHANGER_PREMOUNT_EJECT_REQUIRED     = 0x00080000,
    CHANGER_REPORT_IEPORT_STATE         = 0x00000800,
    CHANGER_SERIAL_NUMBER_VALID         = 0x04000000,
    CHANGER_STATUS_NON_VOLATILE         = 0x00000010,
    CHANGER_STORAGE_DRIVE               = 0x00001000,
    CHANGER_STORAGE_IEPORT              = 0x00002000,
    CHANGER_STORAGE_SLOT                = 0x00004000,
    CHANGER_STORAGE_TRANSPORT           = 0x00008000,
    CHANGER_VOLUME_ASSERT               = 0x00400000,
    CHANGER_VOLUME_IDENTIFICATION       = 0x00100000,
    CHANGER_VOLUME_REPLACE              = 0x00800000,
    CHANGER_VOLUME_SEARCH               = 0x00200000,
    CHANGER_VOLUME_UNDEFINE             = 0x01000000,
}

alias TXFS_RMF_LAGS = uint;
enum : uint
{
    TXFS_RM_FLAG_LOGGING_MODE                        = 0x00000001,
    TXFS_RM_FLAG_RENAME_RM                           = 0x00000002,
    TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX             = 0x00000004,
    TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN             = 0x00000008,
    TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS = 0x00000010,
    TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT        = 0x00000020,
    TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE          = 0x00000040,
    TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX          = 0x00000080,
    TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN          = 0x00000100,
    TXFS_RM_FLAG_GROW_LOG                            = 0x00000400,
    TXFS_RM_FLAG_SHRINK_LOG                          = 0x00000800,
    TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE                = 0x00001000,
    TXFS_RM_FLAG_PRESERVE_CHANGES                    = 0x00002000,
    TXFS_RM_FLAG_RESET_RM_AT_NEXT_START              = 0x00004000,
    TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START       = 0x00008000,
    TXFS_RM_FLAG_PREFER_CONSISTENCY                  = 0x00010000,
    TXFS_RM_FLAG_PREFER_AVAILABILITY                 = 0x00020000,
}

alias FILESYSTEM_STATISTICS_TYPE = ushort;
enum : ushort
{
    FILESYSTEM_STATISTICS_TYPE_EXFAT = 0x0003,
    FILESYSTEM_STATISTICS_TYPE_FAT   = 0x0002,
    FILESYSTEM_STATISTICS_TYPE_NTFS  = 0x0001,
}

alias USN_SOURCE_INFO_ID = uint;
enum : uint
{
    USN_SOURCE_AUXILIARY_DATA                = 0x00000002,
    USN_SOURCE_DATA_MANAGEMENT               = 0x00000001,
    USN_SOURCE_REPLICATION_MANAGEMENT        = 0x00000004,
    USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT = 0x00000008,
}

alias FILE_STORAGE_TIER_FLAGS = uint;
enum : uint
{
    FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY = 0x00020000,
}

alias CHANGER_ELEMENT_STATUS_FLAGS = uint;
enum : uint
{
    ELEMENT_STATUS_ACCESS       = 0x00000008,
    ELEMENT_STATUS_AVOLTAG      = 0x20000000,
    ELEMENT_STATUS_EXCEPT       = 0x00000004,
    ELEMENT_STATUS_EXENAB       = 0x00000010,
    ELEMENT_STATUS_FULL         = 0x00000001,
    ELEMENT_STATUS_ID_VALID     = 0x00002000,
    ELEMENT_STATUS_IMPEXP       = 0x00000002,
    ELEMENT_STATUS_INENAB       = 0x00000020,
    ELEMENT_STATUS_INVERT       = 0x00400000,
    ELEMENT_STATUS_LUN_VALID    = 0x00001000,
    ELEMENT_STATUS_NOT_BUS      = 0x00008000,
    ELEMENT_STATUS_PVOLTAG      = 0x10000000,
    ELEMENT_STATUS_SVALID       = 0x00800000,
    ELEMENT_STATUS_PRODUCT_DATA = 0x00000040,
}

alias GET_CHANGER_PARAMETERS_FEATURES1 = uint;
enum : uint
{
    CHANGER_CLEANER_AUTODISMOUNT       = 0x80000004,
    CHANGER_CLEANER_OPS_NOT_SUPPORTED  = 0x80000040,
    CHANGER_IEPORT_USER_CONTROL_CLOSE  = 0x80000100,
    CHANGER_IEPORT_USER_CONTROL_OPEN   = 0x80000080,
    CHANGER_MOVE_EXTENDS_IEPORT        = 0x80000200,
    CHANGER_MOVE_RETRACTS_IEPORT       = 0x80000400,
    CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE = 0x80000002,
    CHANGER_PREDISMOUNT_ALIGN_TO_SLOT  = 0x80000001,
    CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR = 0x80000020,
    CHANGER_SLOTS_USE_TRAYS            = 0x80000010,
    CHANGER_TRUE_EXCHANGE_CAPABLE      = 0x80000008,
}

struct MOVE_FILE_DATA32
{
    uint FileHandle;
    long StartingVcn;
    long StartingLcn;
    uint ClusterCount;
}
struct MARK_HANDLE_INFO32
{
    union
    {
        uint UsnSourceInfo;
        uint CopyNumber;
    }
    uint VolumeHandle;
    uint HandleInfo;
}
struct DUPLICATE_EXTENTS_DATA32
{
    uint FileHandle;
    long SourceFileOffset;
    long TargetFileOffset;
    long ByteCount;
}
struct DUPLICATE_EXTENTS_DATA_EX32
{
    uint Size;
    uint FileHandle;
    long SourceFileOffset;
    long TargetFileOffset;
    long ByteCount;
    uint Flags;
}
struct STORAGE_HOTPLUG_INFO
{
    uint Size;
    BOOLEAN MediaRemovable;
    BOOLEAN MediaHotplug;
    BOOLEAN DeviceHotplug;
    BOOLEAN WriteCacheEnableOverride;
}
struct STORAGE_DEVICE_NUMBER
{
    uint DeviceType;
    uint DeviceNumber;
    uint PartitionNumber;
}
struct STORAGE_DEVICE_NUMBERS
{
    uint Version;
    uint Size;
    uint NumberOfDevices;
    STORAGE_DEVICE_NUMBER[1] Devices;
}
struct STORAGE_DEVICE_NUMBER_EX
{
    uint Version;
    uint Size;
    uint Flags;
    uint DeviceType;
    uint DeviceNumber;
    GUID DeviceGuid;
    uint PartitionNumber;
}
struct STORAGE_BUS_RESET_REQUEST
{
    ubyte PathId;
}
struct STORAGE_BREAK_RESERVATION_REQUEST
{
    uint Length;
    ubyte _unused;
    ubyte PathId;
    ubyte TargetId;
    ubyte Lun;
}
struct PREVENT_MEDIA_REMOVAL
{
    BOOLEAN PreventMediaRemoval;
}
struct CLASS_MEDIA_CHANGE_CONTEXT
{
    uint MediaChangeCount;
    uint NewState;
}
struct TAPE_STATISTICS
{
    uint Version;
    uint Flags;
    long RecoveredWrites;
    long UnrecoveredWrites;
    long RecoveredReads;
    long UnrecoveredReads;
    ubyte CompressionRatioReads;
    ubyte CompressionRatioWrites;
}
struct TAPE_GET_STATISTICS
{
    uint Operation;
}
alias STORAGE_MEDIA_TYPE = int;
enum : int
{
    DDS_4mm            = 0x00000020,
    MiniQic            = 0x00000021,
    Travan             = 0x00000022,
    QIC                = 0x00000023,
    MP_8mm             = 0x00000024,
    AME_8mm            = 0x00000025,
    AIT1_8mm           = 0x00000026,
    DLT                = 0x00000027,
    NCTP               = 0x00000028,
    IBM_3480           = 0x00000029,
    IBM_3490E          = 0x0000002a,
    IBM_Magstar_3590   = 0x0000002b,
    IBM_Magstar_MP     = 0x0000002c,
    STK_DATA_D3        = 0x0000002d,
    SONY_DTF           = 0x0000002e,
    DV_6mm             = 0x0000002f,
    DMI                = 0x00000030,
    SONY_D2            = 0x00000031,
    CLEANER_CARTRIDGE  = 0x00000032,
    CD_ROM             = 0x00000033,
    CD_R               = 0x00000034,
    CD_RW              = 0x00000035,
    DVD_ROM            = 0x00000036,
    DVD_R              = 0x00000037,
    DVD_RW             = 0x00000038,
    MO_3_RW            = 0x00000039,
    MO_5_WO            = 0x0000003a,
    MO_5_RW            = 0x0000003b,
    MO_5_LIMDOW        = 0x0000003c,
    PC_5_WO            = 0x0000003d,
    PC_5_RW            = 0x0000003e,
    PD_5_RW            = 0x0000003f,
    ABL_5_WO           = 0x00000040,
    PINNACLE_APEX_5_RW = 0x00000041,
    SONY_12_WO         = 0x00000042,
    PHILIPS_12_WO      = 0x00000043,
    HITACHI_12_WO      = 0x00000044,
    CYGNET_12_WO       = 0x00000045,
    KODAK_14_WO        = 0x00000046,
    MO_NFR_525         = 0x00000047,
    NIKON_12_RW        = 0x00000048,
    IOMEGA_ZIP         = 0x00000049,
    IOMEGA_JAZ         = 0x0000004a,
    SYQUEST_EZ135      = 0x0000004b,
    SYQUEST_EZFLYER    = 0x0000004c,
    SYQUEST_SYJET      = 0x0000004d,
    AVATAR_F2          = 0x0000004e,
    MP2_8mm            = 0x0000004f,
    DST_S              = 0x00000050,
    DST_M              = 0x00000051,
    DST_L              = 0x00000052,
    VXATape_1          = 0x00000053,
    VXATape_2          = 0x00000054,
    STK_9840           = 0x00000055,
    LTO_Ultrium        = 0x00000056,
    LTO_Accelis        = 0x00000057,
    DVD_RAM            = 0x00000058,
    AIT_8mm            = 0x00000059,
    ADR_1              = 0x0000005a,
    ADR_2              = 0x0000005b,
    STK_9940           = 0x0000005c,
    SAIT               = 0x0000005d,
    VXATape            = 0x0000005e,
}

struct DEVICE_MEDIA_INFO
{
    union DeviceSpecific
    {
        struct DiskInfo
        {
            long Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            uint TracksPerCylinder;
            uint SectorsPerTrack;
            uint BytesPerSector;
            uint NumberMediaSides;
            uint MediaCharacteristics;
        }
        struct RemovableDiskInfo
        {
            long Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            uint TracksPerCylinder;
            uint SectorsPerTrack;
            uint BytesPerSector;
            uint NumberMediaSides;
            uint MediaCharacteristics;
        }
        struct TapeInfo
        {
            STORAGE_MEDIA_TYPE MediaType;
            uint MediaCharacteristics;
            uint CurrentBlockSize;
            STORAGE_BUS_TYPE BusType;
            union BusSpecificData
            {
                struct ScsiInformation
                {
                    ubyte MediumType;
                    ubyte DensityCode;
                }
            }
        }
    }
}
struct GET_MEDIA_TYPES
{
    uint DeviceType;
    uint MediaInfoCount;
    DEVICE_MEDIA_INFO[1] MediaInfo;
}
struct STORAGE_PREDICT_FAILURE
{
    uint PredictFailure;
    ubyte[512] VendorSpecific;
}
struct STORAGE_FAILURE_PREDICTION_CONFIG
{
    uint Version;
    uint Size;
    BOOLEAN Set;
    BOOLEAN Enabled;
    ushort Reserved;
}
alias STORAGE_QUERY_TYPE = int;
enum : int
{
    PropertyStandardQuery   = 0x00000000,
    PropertyExistsQuery     = 0x00000001,
    PropertyMaskQuery       = 0x00000002,
    PropertyQueryMaxDefined = 0x00000003,
}

alias STORAGE_SET_TYPE = int;
enum : int
{
    PropertyStandardSet   = 0x00000000,
    PropertyExistsSet     = 0x00000001,
    PropertySetMaxDefined = 0x00000002,
}

alias STORAGE_PROPERTY_ID = int;
enum : int
{
    StorageDeviceProperty                  = 0x00000000,
    StorageAdapterProperty                 = 0x00000001,
    StorageDeviceIdProperty                = 0x00000002,
    StorageDeviceUniqueIdProperty          = 0x00000003,
    StorageDeviceWriteCacheProperty        = 0x00000004,
    StorageMiniportProperty                = 0x00000005,
    StorageAccessAlignmentProperty         = 0x00000006,
    StorageDeviceSeekPenaltyProperty       = 0x00000007,
    StorageDeviceTrimProperty              = 0x00000008,
    StorageDeviceWriteAggregationProperty  = 0x00000009,
    StorageDeviceDeviceTelemetryProperty   = 0x0000000a,
    StorageDeviceLBProvisioningProperty    = 0x0000000b,
    StorageDevicePowerProperty             = 0x0000000c,
    StorageDeviceCopyOffloadProperty       = 0x0000000d,
    StorageDeviceResiliencyProperty        = 0x0000000e,
    StorageDeviceMediumProductType         = 0x0000000f,
    StorageAdapterRpmbProperty             = 0x00000010,
    StorageAdapterCryptoProperty           = 0x00000011,
    StorageDeviceIoCapabilityProperty      = 0x00000030,
    StorageAdapterProtocolSpecificProperty = 0x00000031,
    StorageDeviceProtocolSpecificProperty  = 0x00000032,
    StorageAdapterTemperatureProperty      = 0x00000033,
    StorageDeviceTemperatureProperty       = 0x00000034,
    StorageAdapterPhysicalTopologyProperty = 0x00000035,
    StorageDevicePhysicalTopologyProperty  = 0x00000036,
    StorageDeviceAttributesProperty        = 0x00000037,
    StorageDeviceManagementStatus          = 0x00000038,
    StorageAdapterSerialNumberProperty     = 0x00000039,
    StorageDeviceLocationProperty          = 0x0000003a,
    StorageDeviceNumaProperty              = 0x0000003b,
    StorageDeviceZonedDeviceProperty       = 0x0000003c,
    StorageDeviceUnsafeShutdownCount       = 0x0000003d,
    StorageDeviceEnduranceProperty         = 0x0000003e,
    StorageDeviceLedStateProperty          = 0x0000003f,
    StorageDeviceSelfEncryptionProperty    = 0x00000040,
    StorageFruIdProperty                   = 0x00000041,
}

struct STORAGE_PROPERTY_QUERY
{
    STORAGE_PROPERTY_ID PropertyId;
    STORAGE_QUERY_TYPE QueryType;
    ubyte[1] AdditionalParameters;
}
struct STORAGE_PROPERTY_SET
{
    STORAGE_PROPERTY_ID PropertyId;
    STORAGE_SET_TYPE SetType;
    ubyte[1] AdditionalParameters;
}
struct STORAGE_DESCRIPTOR_HEADER
{
    uint Version;
    uint Size;
}
struct STORAGE_DEVICE_DESCRIPTOR
{
    uint Version;
    uint Size;
    ubyte DeviceType;
    ubyte DeviceTypeModifier;
    BOOLEAN RemovableMedia;
    BOOLEAN CommandQueueing;
    uint VendorIdOffset;
    uint ProductIdOffset;
    uint ProductRevisionOffset;
    uint SerialNumberOffset;
    STORAGE_BUS_TYPE BusType;
    uint RawPropertiesLength;
    ubyte[1] RawDeviceProperties;
}
struct STORAGE_ADAPTER_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint MaximumTransferLength;
    uint MaximumPhysicalPages;
    uint AlignmentMask;
    BOOLEAN AdapterUsesPio;
    BOOLEAN AdapterScansDown;
    BOOLEAN CommandQueueing;
    BOOLEAN AcceleratedTransfer;
    ubyte BusType;
    ushort BusMajorVersion;
    ushort BusMinorVersion;
    ubyte SrbType;
    ubyte AddressType;
}
struct STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint BytesPerCacheLine;
    uint BytesOffsetForCacheAlignment;
    uint BytesPerLogicalSector;
    uint BytesPerPhysicalSector;
    uint BytesOffsetForSectorAlignment;
}
struct STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint MediumProductType;
}
alias STORAGE_PORT_CODE_SET = int;
enum : int
{
    StoragePortCodeSetReserved  = 0x00000000,
    StoragePortCodeSetStorport  = 0x00000001,
    StoragePortCodeSetSCSIport  = 0x00000002,
    StoragePortCodeSetSpaceport = 0x00000003,
    StoragePortCodeSetATAport   = 0x00000004,
    StoragePortCodeSetUSBport   = 0x00000005,
    StoragePortCodeSetSBP2port  = 0x00000006,
    StoragePortCodeSetSDport    = 0x00000007,
}

struct STORAGE_MINIPORT_DESCRIPTOR
{
    uint Version;
    uint Size;
    STORAGE_PORT_CODE_SET Portdriver;
    BOOLEAN LUNResetSupported;
    BOOLEAN TargetResetSupported;
    ushort IoTimeoutValue;
    BOOLEAN ExtraIoInfoSupported;
    union Flags
    {
        struct
        {
            ubyte _bitfield0;
        }
        ubyte AsBYTE;
    }
    ubyte[2] Reserved0;
    uint Reserved1;
}
alias STORAGE_IDENTIFIER_CODE_SET = int;
enum : int
{
    StorageIdCodeSetReserved = 0x00000000,
    StorageIdCodeSetBinary   = 0x00000001,
    StorageIdCodeSetAscii    = 0x00000002,
    StorageIdCodeSetUtf8     = 0x00000003,
}

alias STORAGE_IDENTIFIER_TYPE = int;
enum : int
{
    StorageIdTypeVendorSpecific           = 0x00000000,
    StorageIdTypeVendorId                 = 0x00000001,
    StorageIdTypeEUI64                    = 0x00000002,
    StorageIdTypeFCPHName                 = 0x00000003,
    StorageIdTypePortRelative             = 0x00000004,
    StorageIdTypeTargetPortGroup          = 0x00000005,
    StorageIdTypeLogicalUnitGroup         = 0x00000006,
    StorageIdTypeMD5LogicalUnitIdentifier = 0x00000007,
    StorageIdTypeScsiNameString           = 0x00000008,
}

alias STORAGE_ID_NAA_FORMAT = int;
enum : int
{
    StorageIdNAAFormatIEEEExtended            = 0x00000002,
    StorageIdNAAFormatIEEERegistered          = 0x00000003,
    StorageIdNAAFormatIEEEERegisteredExtended = 0x00000005,
}

alias STORAGE_ASSOCIATION_TYPE = int;
enum : int
{
    StorageIdAssocDevice = 0x00000000,
    StorageIdAssocPort   = 0x00000001,
    StorageIdAssocTarget = 0x00000002,
}

struct STORAGE_IDENTIFIER
{
    STORAGE_IDENTIFIER_CODE_SET CodeSet;
    STORAGE_IDENTIFIER_TYPE Type;
    ushort IdentifierSize;
    ushort NextOffset;
    STORAGE_ASSOCIATION_TYPE Association;
    ubyte[1] Identifier;
}
struct STORAGE_DEVICE_ID_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint NumberOfIdentifiers;
    ubyte[1] Identifiers;
}
struct DEVICE_SEEK_PENALTY_DESCRIPTOR
{
    uint Version;
    uint Size;
    BOOLEAN IncursSeekPenalty;
}
struct DEVICE_WRITE_AGGREGATION_DESCRIPTOR
{
    uint Version;
    uint Size;
    BOOLEAN BenefitsFromWriteAggregation;
}
struct DEVICE_TRIM_DESCRIPTOR
{
    uint Version;
    uint Size;
    BOOLEAN TrimEnabled;
}
struct DEVICE_LB_PROVISIONING_DESCRIPTOR
{
    uint Version;
    uint Size;
    ubyte _bitfield0;
    ubyte[7] Reserved1;
    ulong OptimalUnmapGranularity;
    ulong UnmapGranularityAlignment;
    uint MaxUnmapLbaCount;
    uint MaxUnmapBlockDescriptorCount;
}
struct STORAGE_LB_PROVISIONING_MAP_RESOURCES
{
    uint Size;
    uint Version;
    ubyte _bitfield1;
    ubyte[3] Reserved1;
    ubyte _bitfield2;
    ubyte[3] Reserved3;
    ulong AvailableMappingResources;
    ulong UsedMappingResources;
}
struct DEVICE_POWER_DESCRIPTOR
{
    uint Version;
    uint Size;
    BOOLEAN DeviceAttentionSupported;
    BOOLEAN AsynchronousNotificationSupported;
    BOOLEAN IdlePowerManagementEnabled;
    BOOLEAN D3ColdEnabled;
    BOOLEAN D3ColdSupported;
    BOOLEAN NoVerifyDuringIdlePower;
    ubyte[2] Reserved;
    uint IdleTimeoutInMS;
}
struct DEVICE_COPY_OFFLOAD_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint MaximumTokenLifetime;
    uint DefaultTokenLifetime;
    ulong MaximumTransferSize;
    ulong OptimalTransferCount;
    uint MaximumDataDescriptors;
    uint MaximumTransferLengthPerDescriptor;
    uint OptimalTransferLengthPerDescriptor;
    ushort OptimalTransferLengthGranularity;
    ubyte[2] Reserved;
}
struct STORAGE_DEVICE_RESILIENCY_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint NameOffset;
    uint NumberOfLogicalCopies;
    uint NumberOfPhysicalCopies;
    uint PhysicalDiskRedundancy;
    uint NumberOfColumns;
    uint Interleave;
}
alias STORAGE_RPMB_FRAME_TYPE = int;
enum : int
{
    StorageRpmbFrameTypeUnknown  = 0x00000000,
    StorageRpmbFrameTypeStandard = 0x00000001,
    StorageRpmbFrameTypeMax      = 0x00000002,
}

struct STORAGE_RPMB_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint SizeInBytes;
    uint MaxReliableWriteSizeInBytes;
    STORAGE_RPMB_FRAME_TYPE FrameFormat;
}
alias STORAGE_CRYPTO_ALGORITHM_ID = int;
enum : int
{
    StorageCryptoAlgorithmUnknown         = 0x00000000,
    StorageCryptoAlgorithmXTSAES          = 0x00000001,
    StorageCryptoAlgorithmBitlockerAESCBC = 0x00000002,
    StorageCryptoAlgorithmAESECB          = 0x00000003,
    StorageCryptoAlgorithmESSIVAESCBC     = 0x00000004,
    StorageCryptoAlgorithmMax             = 0x00000005,
}

alias STORAGE_CRYPTO_KEY_SIZE = int;
enum : int
{
    StorageCryptoKeySizeUnknown = 0x00000000,
    StorageCryptoKeySize128Bits = 0x00000001,
    StorageCryptoKeySize192Bits = 0x00000002,
    StorageCryptoKeySize256Bits = 0x00000003,
    StorageCryptoKeySize512Bits = 0x00000004,
}

struct STORAGE_CRYPTO_CAPABILITY
{
    uint Version;
    uint Size;
    uint CryptoCapabilityIndex;
    STORAGE_CRYPTO_ALGORITHM_ID AlgorithmId;
    STORAGE_CRYPTO_KEY_SIZE KeySize;
    uint DataUnitSizeBitmask;
}
struct STORAGE_CRYPTO_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint NumKeysSupported;
    uint NumCryptoCapabilities;
    STORAGE_CRYPTO_CAPABILITY[1] CryptoCapabilities;
}
alias STORAGE_TIER_MEDIA_TYPE = int;
enum : int
{
    StorageTierMediaTypeUnspecified = 0x00000000,
    StorageTierMediaTypeDisk        = 0x00000001,
    StorageTierMediaTypeSsd         = 0x00000002,
    StorageTierMediaTypeScm         = 0x00000004,
    StorageTierMediaTypeMax         = 0x00000005,
}

alias STORAGE_TIER_CLASS = int;
enum : int
{
    StorageTierClassUnspecified = 0x00000000,
    StorageTierClassCapacity    = 0x00000001,
    StorageTierClassPerformance = 0x00000002,
    StorageTierClassMax         = 0x00000003,
}

struct STORAGE_TIER
{
    GUID Id;
    wchar[256] Name;
    wchar[256] Description;
    ulong Flags;
    ulong ProvisionedCapacity;
    STORAGE_TIER_MEDIA_TYPE MediaType;
    STORAGE_TIER_CLASS Class;
}
struct STORAGE_DEVICE_TIERING_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint Flags;
    uint TotalNumberOfTiers;
    uint NumberOfTiersReturned;
    STORAGE_TIER[1] Tiers;
}
struct STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint NumberOfFaultDomains;
    GUID[1] FaultDomainIds;
}
alias STORAGE_PROTOCOL_TYPE = int;
enum : int
{
    ProtocolTypeUnknown     = 0x00000000,
    ProtocolTypeScsi        = 0x00000001,
    ProtocolTypeAta         = 0x00000002,
    ProtocolTypeNvme        = 0x00000003,
    ProtocolTypeSd          = 0x00000004,
    ProtocolTypeUfs         = 0x00000005,
    ProtocolTypeProprietary = 0x0000007e,
    ProtocolTypeMaxReserved = 0x0000007f,
}

alias STORAGE_PROTOCOL_NVME_DATA_TYPE = int;
enum : int
{
    NVMeDataTypeUnknown  = 0x00000000,
    NVMeDataTypeIdentify = 0x00000001,
    NVMeDataTypeLogPage  = 0x00000002,
    NVMeDataTypeFeature  = 0x00000003,
}

alias STORAGE_PROTOCOL_ATA_DATA_TYPE = int;
enum : int
{
    AtaDataTypeUnknown  = 0x00000000,
    AtaDataTypeIdentify = 0x00000001,
    AtaDataTypeLogPage  = 0x00000002,
}

alias STORAGE_PROTOCOL_UFS_DATA_TYPE = int;
enum : int
{
    UfsDataTypeUnknown               = 0x00000000,
    UfsDataTypeQueryDescriptor       = 0x00000001,
    UfsDataTypeQueryAttribute        = 0x00000002,
    UfsDataTypeQueryFlag             = 0x00000003,
    UfsDataTypeQueryDmeAttribute     = 0x00000004,
    UfsDataTypeQueryDmePeerAttribute = 0x00000005,
    UfsDataTypeMax                   = 0x00000006,
}

union STORAGE_PROTOCOL_DATA_SUBVALUE_GET_LOG_PAGE
{
    struct
    {
        uint _bitfield0;
    }
    uint AsUlong;
}
struct STORAGE_PROTOCOL_SPECIFIC_DATA
{
    STORAGE_PROTOCOL_TYPE ProtocolType;
    uint DataType;
    uint ProtocolDataRequestValue;
    uint ProtocolDataRequestSubValue;
    uint ProtocolDataOffset;
    uint ProtocolDataLength;
    uint FixedProtocolReturnData;
    uint ProtocolDataRequestSubValue2;
    uint ProtocolDataRequestSubValue3;
    uint ProtocolDataRequestSubValue4;
}
struct STORAGE_PROTOCOL_SPECIFIC_DATA_EXT
{
    STORAGE_PROTOCOL_TYPE ProtocolType;
    uint DataType;
    uint ProtocolDataValue;
    uint ProtocolDataSubValue;
    uint ProtocolDataOffset;
    uint ProtocolDataLength;
    uint FixedProtocolReturnData;
    uint ProtocolDataSubValue2;
    uint ProtocolDataSubValue3;
    uint ProtocolDataSubValue4;
    uint ProtocolDataSubValue5;
    uint[5] Reserved;
}
struct STORAGE_PROTOCOL_DATA_DESCRIPTOR
{
    uint Version;
    uint Size;
    STORAGE_PROTOCOL_SPECIFIC_DATA ProtocolSpecificData;
}
struct STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT
{
    uint Version;
    uint Size;
    STORAGE_PROTOCOL_SPECIFIC_DATA_EXT ProtocolSpecificData;
}
struct STORAGE_TEMPERATURE_INFO
{
    ushort Index;
    short Temperature;
    short OverThreshold;
    short UnderThreshold;
    BOOLEAN OverThresholdChangable;
    BOOLEAN UnderThresholdChangable;
    BOOLEAN EventGenerated;
    ubyte Reserved0;
    uint Reserved1;
}
struct STORAGE_TEMPERATURE_DATA_DESCRIPTOR
{
    uint Version;
    uint Size;
    short CriticalTemperature;
    short WarningTemperature;
    ushort InfoCount;
    ubyte[2] Reserved0;
    uint[2] Reserved1;
    STORAGE_TEMPERATURE_INFO[1] TemperatureInfo;
}
struct STORAGE_TEMPERATURE_THRESHOLD
{
    uint Version;
    uint Size;
    ushort Flags;
    ushort Index;
    short Threshold;
    BOOLEAN OverThreshold;
    ubyte Reserved;
}
alias STORAGE_DEVICE_FORM_FACTOR = int;
enum : int
{
    FormFactorUnknown    = 0x00000000,
    FormFactor3_5        = 0x00000001,
    FormFactor2_5        = 0x00000002,
    FormFactor1_8        = 0x00000003,
    FormFactor1_8Less    = 0x00000004,
    FormFactorEmbedded   = 0x00000005,
    FormFactorMemoryCard = 0x00000006,
    FormFactormSata      = 0x00000007,
    FormFactorM_2        = 0x00000008,
    FormFactorPCIeBoard  = 0x00000009,
    FormFactorDimm       = 0x0000000a,
}

alias STORAGE_COMPONENT_HEALTH_STATUS = int;
enum : int
{
    HealthStatusUnknown   = 0x00000000,
    HealthStatusNormal    = 0x00000001,
    HealthStatusThrottled = 0x00000002,
    HealthStatusWarning   = 0x00000003,
    HealthStatusDisabled  = 0x00000004,
    HealthStatusFailed    = 0x00000005,
}

union STORAGE_SPEC_VERSION
{
    struct
    {
        union MinorVersion
        {
            struct
            {
                ubyte SubMinor;
                ubyte Minor;
            }
            ushort AsUshort;
        }
        ushort MajorVersion;
    }
    uint AsUlong;
}
struct STORAGE_PHYSICAL_DEVICE_DATA
{
    uint DeviceId;
    uint Role;
    STORAGE_COMPONENT_HEALTH_STATUS HealthStatus;
    STORAGE_PROTOCOL_TYPE CommandProtocol;
    STORAGE_SPEC_VERSION SpecVersion;
    STORAGE_DEVICE_FORM_FACTOR FormFactor;
    ubyte[8] Vendor;
    ubyte[40] Model;
    ubyte[16] FirmwareRevision;
    ulong Capacity;
    ubyte[32] PhysicalLocation;
    uint[2] Reserved;
}
struct STORAGE_PHYSICAL_ADAPTER_DATA
{
    uint AdapterId;
    STORAGE_COMPONENT_HEALTH_STATUS HealthStatus;
    STORAGE_PROTOCOL_TYPE CommandProtocol;
    STORAGE_SPEC_VERSION SpecVersion;
    ubyte[8] Vendor;
    ubyte[40] Model;
    ubyte[16] FirmwareRevision;
    ubyte[32] PhysicalLocation;
    BOOLEAN ExpanderConnected;
    ubyte[3] Reserved0;
    uint[3] Reserved1;
}
struct STORAGE_PHYSICAL_NODE_DATA
{
    uint NodeId;
    uint AdapterCount;
    uint AdapterDataLength;
    uint AdapterDataOffset;
    uint DeviceCount;
    uint DeviceDataLength;
    uint DeviceDataOffset;
    uint[3] Reserved;
}
struct STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint NodeCount;
    uint Reserved;
    STORAGE_PHYSICAL_NODE_DATA[1] Node;
}
struct STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint LunMaxIoCount;
    uint AdapterMaxIoCount;
}
struct STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR
{
    uint Version;
    uint Size;
    ulong Attributes;
}
alias STORAGE_DISK_HEALTH_STATUS = int;
enum : int
{
    DiskHealthUnknown   = 0x00000000,
    DiskHealthUnhealthy = 0x00000001,
    DiskHealthWarning   = 0x00000002,
    DiskHealthHealthy   = 0x00000003,
    DiskHealthMax       = 0x00000004,
}

alias STORAGE_DISK_OPERATIONAL_STATUS = int;
enum : int
{
    DiskOpStatusNone              = 0x00000000,
    DiskOpStatusUnknown           = 0x00000001,
    DiskOpStatusOk                = 0x00000002,
    DiskOpStatusPredictingFailure = 0x00000003,
    DiskOpStatusInService         = 0x00000004,
    DiskOpStatusHardwareError     = 0x00000005,
    DiskOpStatusNotUsable         = 0x00000006,
    DiskOpStatusTransientError    = 0x00000007,
    DiskOpStatusMissing           = 0x00000008,
}

alias STORAGE_OPERATIONAL_STATUS_REASON = int;
enum : int
{
    DiskOpReasonUnknown                      = 0x00000000,
    DiskOpReasonScsiSenseCode                = 0x00000001,
    DiskOpReasonMedia                        = 0x00000002,
    DiskOpReasonIo                           = 0x00000003,
    DiskOpReasonThresholdExceeded            = 0x00000004,
    DiskOpReasonLostData                     = 0x00000005,
    DiskOpReasonEnergySource                 = 0x00000006,
    DiskOpReasonConfiguration                = 0x00000007,
    DiskOpReasonDeviceController             = 0x00000008,
    DiskOpReasonMediaController              = 0x00000009,
    DiskOpReasonComponent                    = 0x0000000a,
    DiskOpReasonNVDIMM_N                     = 0x0000000b,
    DiskOpReasonBackgroundOperation          = 0x0000000c,
    DiskOpReasonInvalidFirmware              = 0x0000000d,
    DiskOpReasonHealthCheck                  = 0x0000000e,
    DiskOpReasonLostDataPersistence          = 0x0000000f,
    DiskOpReasonDisabledByPlatform           = 0x00000010,
    DiskOpReasonLostWritePersistence         = 0x00000011,
    DiskOpReasonDataPersistenceLossImminent  = 0x00000012,
    DiskOpReasonWritePersistenceLossImminent = 0x00000013,
    DiskOpReasonMax                          = 0x00000014,
}

struct STORAGE_OPERATIONAL_REASON
{
    uint Version;
    uint Size;
    STORAGE_OPERATIONAL_STATUS_REASON Reason;
    union RawBytes
    {
        struct ScsiSenseKey
        {
            ubyte SenseKey;
            ubyte ASC;
            ubyte ASCQ;
            ubyte Reserved;
        }
        struct NVDIMM_N
        {
            ubyte CriticalHealth;
            ubyte[2] ModuleHealth;
            ubyte ErrorThresholdStatus;
        }
        uint AsUlong;
    }
}
struct STORAGE_DEVICE_MANAGEMENT_STATUS
{
    uint Version;
    uint Size;
    STORAGE_DISK_HEALTH_STATUS Health;
    uint NumberOfOperationalStatus;
    uint NumberOfAdditionalReasons;
    STORAGE_DISK_OPERATIONAL_STATUS[16] OperationalStatus;
    STORAGE_OPERATIONAL_REASON[1] AdditionalReasons;
}
struct STORAGE_ADAPTER_SERIAL_NUMBER
{
    uint Version;
    uint Size;
    wchar[128] SerialNumber;
}
alias STORAGE_ZONED_DEVICE_TYPES = int;
enum : int
{
    ZonedDeviceTypeUnknown       = 0x00000000,
    ZonedDeviceTypeHostManaged   = 0x00000001,
    ZonedDeviceTypeHostAware     = 0x00000002,
    ZonedDeviceTypeDeviceManaged = 0x00000003,
}

alias STORAGE_ZONE_TYPES = int;
enum : int
{
    ZoneTypeUnknown                  = 0x00000000,
    ZoneTypeConventional             = 0x00000001,
    ZoneTypeSequentialWriteRequired  = 0x00000002,
    ZoneTypeSequentialWritePreferred = 0x00000003,
    ZoneTypeMax                      = 0x00000004,
}

struct STORAGE_ZONE_GROUP
{
    uint ZoneCount;
    STORAGE_ZONE_TYPES ZoneType;
    ulong ZoneSize;
}
struct STORAGE_ZONED_DEVICE_DESCRIPTOR
{
    uint Version;
    uint Size;
    STORAGE_ZONED_DEVICE_TYPES DeviceType;
    uint ZoneCount;
    union ZoneAttributes
    {
        struct SequentialRequiredZone
        {
            uint MaxOpenZoneCount;
            BOOLEAN UnrestrictedRead;
            ubyte[3] Reserved;
        }
        struct SequentialPreferredZone
        {
            uint OptimalOpenZoneCount;
            uint Reserved;
        }
    }
    uint ZoneGroupCount;
    STORAGE_ZONE_GROUP[1] ZoneGroup;
}
struct DEVICE_LOCATION
{
    uint Socket;
    uint Slot;
    uint Adapter;
    uint Port;
    union
    {
        struct
        {
            uint Channel;
            uint Device;
        }
        struct
        {
            uint Target;
            uint Lun;
        }
    }
}
struct STORAGE_DEVICE_LOCATION_DESCRIPTOR
{
    uint Version;
    uint Size;
    DEVICE_LOCATION Location;
    uint StringOffset;
}
struct STORAGE_DEVICE_NUMA_PROPERTY
{
    uint Version;
    uint Size;
    uint NumaNode;
}
struct STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT
{
    uint Version;
    uint Size;
    uint UnsafeShutdownCount;
}
struct STORAGE_HW_ENDURANCE_INFO
{
    uint ValidFields;
    uint GroupId;
    struct Flags
    {
        uint _bitfield0;
    }
    uint LifePercentage;
    ubyte[16] BytesReadCount;
    ubyte[16] ByteWriteCount;
}
struct STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR
{
    uint Version;
    uint Size;
    STORAGE_HW_ENDURANCE_INFO EnduranceInfo;
}
struct STORAGE_DEVICE_LED_STATE_DESCRIPTOR
{
    uint Version;
    uint Size;
    ulong State;
}
struct STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY
{
    uint Version;
    uint Size;
    BOOLEAN SupportsSelfEncryption;
}
alias STORAGE_ENCRYPTION_TYPE = int;
enum : int
{
    StorageEncryptionTypeUnknown = 0x00000000,
    StorageEncryptionTypeEDrive  = 0x00000001,
    StorageEncryptionTypeTcgOpal = 0x00000002,
}

struct STORAGE_DEVICE_SELF_ENCRYPTION_PROPERTY_V2
{
    uint Version;
    uint Size;
    BOOLEAN SupportsSelfEncryption;
    STORAGE_ENCRYPTION_TYPE EncryptionType;
}
struct STORAGE_FRU_ID_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint IdentifierSize;
    ubyte[1] Identifier;
}
struct DEVICE_DATA_SET_RANGE
{
    long StartingOffset;
    ulong LengthInBytes;
}
struct DEVICE_MANAGE_DATA_SET_ATTRIBUTES
{
    uint Size;
    uint Action;
    uint Flags;
    uint ParameterBlockOffset;
    uint ParameterBlockLength;
    uint DataSetRangesOffset;
    uint DataSetRangesLength;
}
struct DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT
{
    uint Size;
    uint Action;
    uint Flags;
    uint OperationStatus;
    uint ExtendedError;
    uint TargetDetailedError;
    uint ReservedStatus;
    uint OutputBlockOffset;
    uint OutputBlockLength;
}
struct DEVICE_DSM_DEFINITION
{
    uint Action;
    BOOLEAN SingleRange;
    uint ParameterBlockAlignment;
    uint ParameterBlockLength;
    BOOLEAN HasOutput;
    uint OutputBlockAlignment;
    uint OutputBlockLength;
}
struct DEVICE_DSM_NOTIFICATION_PARAMETERS
{
    uint Size;
    uint Flags;
    uint NumFileTypeIDs;
    GUID[1] FileTypeID;
}
struct STORAGE_OFFLOAD_TOKEN
{
    ubyte[4] TokenType;
    ubyte[2] Reserved;
    ubyte[2] TokenIdLength;
    union
    {
        struct StorageOffloadZeroDataToken
        {
            ubyte[504] Reserved2;
        }
        ubyte[504] Token;
    }
}
struct DEVICE_DSM_OFFLOAD_READ_PARAMETERS
{
    uint Flags;
    uint TimeToLive;
    uint[2] Reserved;
}
struct STORAGE_OFFLOAD_READ_OUTPUT
{
    uint OffloadReadFlags;
    uint Reserved;
    ulong LengthProtected;
    uint TokenLength;
    STORAGE_OFFLOAD_TOKEN Token;
}
struct DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS
{
    uint Flags;
    uint Reserved;
    ulong TokenOffset;
    STORAGE_OFFLOAD_TOKEN Token;
}
struct STORAGE_OFFLOAD_WRITE_OUTPUT
{
    uint OffloadWriteFlags;
    uint Reserved;
    ulong LengthCopied;
}
struct DEVICE_DATA_SET_LBP_STATE_PARAMETERS
{
    uint Version;
    uint Size;
    uint Flags;
    uint OutputVersion;
}
struct DEVICE_DATA_SET_LB_PROVISIONING_STATE
{
    uint Size;
    uint Version;
    ulong SlabSizeInBytes;
    uint SlabOffsetDeltaInBytes;
    uint SlabAllocationBitMapBitCount;
    uint SlabAllocationBitMapLength;
    uint[1] SlabAllocationBitMap;
}
struct DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2
{
    uint Size;
    uint Version;
    ulong SlabSizeInBytes;
    ulong SlabOffsetDeltaInBytes;
    uint SlabAllocationBitMapBitCount;
    uint SlabAllocationBitMapLength;
    uint[1] SlabAllocationBitMap;
}
struct DEVICE_DATA_SET_REPAIR_PARAMETERS
{
    uint NumberOfRepairCopies;
    uint SourceCopy;
    uint[1] RepairCopies;
}
struct DEVICE_DATA_SET_REPAIR_OUTPUT
{
    DEVICE_DATA_SET_RANGE ParityExtent;
}
struct DEVICE_DATA_SET_SCRUB_OUTPUT
{
    ulong BytesProcessed;
    ulong BytesRepaired;
    ulong BytesFailed;
}
struct DEVICE_DATA_SET_SCRUB_EX_OUTPUT
{
    ulong BytesProcessed;
    ulong BytesRepaired;
    ulong BytesFailed;
    DEVICE_DATA_SET_RANGE ParityExtent;
    ulong BytesScrubbed;
}
struct DEVICE_DSM_TIERING_QUERY_INPUT
{
    uint Version;
    uint Size;
    uint Flags;
    uint NumberOfTierIds;
    GUID[1] TierIds;
}
struct STORAGE_TIER_REGION
{
    GUID TierId;
    ulong Offset;
    ulong Length;
}
struct DEVICE_DSM_TIERING_QUERY_OUTPUT
{
    uint Version;
    uint Size;
    uint Flags;
    uint Reserved;
    ulong Alignment;
    uint TotalNumberOfRegions;
    uint NumberOfRegionsReturned;
    STORAGE_TIER_REGION[1] Regions;
}
struct DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS
{
    uint Size;
    ubyte TargetPriority;
    ubyte[3] Reserved;
}
struct DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT
{
    ulong TopologyRangeBytes;
    ubyte[16] TopologyId;
}
struct DEVICE_STORAGE_ADDRESS_RANGE
{
    long StartAddress;
    ulong LengthInBytes;
}
struct DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT
{
    uint Version;
    uint Flags;
    uint TotalNumberOfRanges;
    uint NumberOfRangesReturned;
    DEVICE_STORAGE_ADDRESS_RANGE[1] Ranges;
}
struct DEVICE_DSM_REPORT_ZONES_PARAMETERS
{
    uint Size;
    ubyte ReportOption;
    ubyte Partial;
    ubyte[2] Reserved;
}
alias STORAGE_ZONES_ATTRIBUTES = int;
enum : int
{
    ZonesAttributeTypeAndLengthMayDifferent       = 0x00000000,
    ZonesAttributeTypeSameLengthSame              = 0x00000001,
    ZonesAttributeTypeSameLastZoneLengthDifferent = 0x00000002,
    ZonesAttributeTypeMayDifferentLengthSame      = 0x00000003,
}

alias STORAGE_ZONE_CONDITION = int;
enum : int
{
    ZoneConditionConventional     = 0x00000000,
    ZoneConditionEmpty            = 0x00000001,
    ZoneConditionImplicitlyOpened = 0x00000002,
    ZoneConditionExplicitlyOpened = 0x00000003,
    ZoneConditionClosed           = 0x00000004,
    ZoneConditionReadOnly         = 0x0000000d,
    ZoneConditionFull             = 0x0000000e,
    ZoneConditionOffline          = 0x0000000f,
}

struct STORAGE_ZONE_DESCRIPTOR
{
    uint Size;
    STORAGE_ZONE_TYPES ZoneType;
    STORAGE_ZONE_CONDITION ZoneCondition;
    BOOLEAN ResetWritePointerRecommend;
    ubyte[3] Reserved0;
    ulong ZoneSize;
    ulong WritePointerOffset;
}
struct DEVICE_DSM_REPORT_ZONES_DATA
{
    uint Size;
    uint ZoneCount;
    STORAGE_ZONES_ATTRIBUTES Attributes;
    uint Reserved0;
    STORAGE_ZONE_DESCRIPTOR[1] ZoneDescriptors;
}
struct DEVICE_STORAGE_RANGE_ATTRIBUTES
{
    ulong LengthInBytes;
    union
    {
        uint AllFlags;
        struct
        {
            uint _bitfield0;
        }
    }
    uint Reserved;
}
struct DEVICE_DSM_RANGE_ERROR_INFO
{
    uint Version;
    uint Flags;
    uint TotalNumberOfRanges;
    uint NumberOfRangesReturned;
    DEVICE_STORAGE_RANGE_ATTRIBUTES[1] Ranges;
}
struct DEVICE_DSM_LOST_QUERY_PARAMETERS
{
    uint Version;
    ulong Granularity;
}
struct DEVICE_DSM_LOST_QUERY_OUTPUT
{
    uint Version;
    uint Size;
    ulong Alignment;
    uint NumberOfBits;
    uint[1] BitMap;
}
struct DEVICE_DSM_FREE_SPACE_OUTPUT
{
    uint Version;
    ulong FreeSpace;
}
struct DEVICE_DSM_CONVERSION_OUTPUT
{
    uint Version;
    GUID Source;
}
struct STORAGE_GET_BC_PROPERTIES_OUTPUT
{
    uint MaximumRequestsPerPeriod;
    uint MinimumPeriod;
    ulong MaximumRequestSize;
    uint EstimatedTimePerRequest;
    uint NumOutStandingRequests;
    ulong RequestSize;
}
struct STORAGE_ALLOCATE_BC_STREAM_INPUT
{
    uint Version;
    uint RequestsPerPeriod;
    uint Period;
    BOOLEAN RetryFailures;
    BOOLEAN Discardable;
    BOOLEAN[2] Reserved1;
    uint AccessType;
    uint AccessMode;
}
struct STORAGE_ALLOCATE_BC_STREAM_OUTPUT
{
    ulong RequestSize;
    uint NumOutStandingRequests;
}
struct STORAGE_PRIORITY_HINT_SUPPORT
{
    uint SupportFlags;
}
alias STORAGE_DIAGNOSTIC_LEVEL = int;
enum : int
{
    StorageDiagnosticLevelDefault = 0x00000000,
    StorageDiagnosticLevelMax     = 0x00000001,
}

alias STORAGE_DIAGNOSTIC_TARGET_TYPE = int;
enum : int
{
    StorageDiagnosticTargetTypeUndefined   = 0x00000000,
    StorageDiagnosticTargetTypePort        = 0x00000001,
    StorageDiagnosticTargetTypeMiniport    = 0x00000002,
    StorageDiagnosticTargetTypeHbaFirmware = 0x00000003,
    StorageDiagnosticTargetTypeMax         = 0x00000004,
}

struct STORAGE_DIAGNOSTIC_REQUEST
{
    uint Version;
    uint Size;
    uint Flags;
    STORAGE_DIAGNOSTIC_TARGET_TYPE TargetType;
    STORAGE_DIAGNOSTIC_LEVEL Level;
}
struct STORAGE_DIAGNOSTIC_DATA
{
    uint Version;
    uint Size;
    GUID ProviderId;
    uint BufferSize;
    uint Reserved;
    ubyte[1] DiagnosticDataBuffer;
}
struct PHYSICAL_ELEMENT_STATUS_REQUEST
{
    uint Version;
    uint Size;
    uint StartingElement;
    ubyte Filter;
    ubyte ReportType;
    ubyte[2] Reserved;
}
struct PHYSICAL_ELEMENT_STATUS_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint ElementIdentifier;
    ubyte PhysicalElementType;
    ubyte PhysicalElementHealth;
    ubyte[2] Reserved1;
    ulong AssociatedCapacity;
    uint[4] Reserved2;
}
struct PHYSICAL_ELEMENT_STATUS
{
    uint Version;
    uint Size;
    uint DescriptorCount;
    uint ReturnedDescriptorCount;
    uint ElementIdentifierBeingDepoped;
    uint Reserved;
    PHYSICAL_ELEMENT_STATUS_DESCRIPTOR[1] Descriptors;
}
struct REMOVE_ELEMENT_AND_TRUNCATE_REQUEST
{
    uint Version;
    uint Size;
    ulong RequestCapacity;
    uint ElementIdentifier;
    uint Reserved;
}
alias DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE = int;
enum : int
{
    DeviceInternalStatusDataRequestTypeUndefined = 0x00000000,
    DeviceCurrentInternalStatusDataHeader        = 0x00000001,
    DeviceCurrentInternalStatusData              = 0x00000002,
    DeviceSavedInternalStatusDataHeader          = 0x00000003,
    DeviceSavedInternalStatusData                = 0x00000004,
}

alias DEVICE_INTERNAL_STATUS_DATA_SET = int;
enum : int
{
    DeviceStatusDataSetUndefined = 0x00000000,
    DeviceStatusDataSet1         = 0x00000001,
    DeviceStatusDataSet2         = 0x00000002,
    DeviceStatusDataSet3         = 0x00000003,
    DeviceStatusDataSet4         = 0x00000004,
    DeviceStatusDataSetMax       = 0x00000005,
}

struct GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST
{
    uint Version;
    uint Size;
    DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE RequestDataType;
    DEVICE_INTERNAL_STATUS_DATA_SET RequestDataSet;
}
struct DEVICE_INTERNAL_STATUS_DATA
{
    uint Version;
    uint Size;
    ulong T10VendorId;
    uint DataSet1Length;
    uint DataSet2Length;
    uint DataSet3Length;
    uint DataSet4Length;
    ubyte StatusDataVersion;
    ubyte[3] Reserved;
    ubyte[128] ReasonIdentifier;
    uint StatusDataLength;
    ubyte[1] StatusData;
}
alias STORAGE_SANITIZE_METHOD = int;
enum : int
{
    StorageSanitizeMethodDefault     = 0x00000000,
    StorageSanitizeMethodBlockErase  = 0x00000001,
    StorageSanitizeMethodCryptoErase = 0x00000002,
}

struct STORAGE_REINITIALIZE_MEDIA
{
    uint Version;
    uint Size;
    uint TimeoutInSeconds;
    struct SanitizeOption
    {
        uint _bitfield0;
    }
}
struct STORAGE_MEDIA_SERIAL_NUMBER_DATA
{
    ushort Reserved;
    ushort SerialNumberLength;
    ubyte[1] SerialNumber;
}
struct STORAGE_READ_CAPACITY
{
    uint Version;
    uint Size;
    uint BlockLength;
    long NumberOfBlocks;
    long DiskLength;
}
alias WRITE_CACHE_TYPE = int;
enum : int
{
    WriteCacheTypeUnknown      = 0x00000000,
    WriteCacheTypeNone         = 0x00000001,
    WriteCacheTypeWriteBack    = 0x00000002,
    WriteCacheTypeWriteThrough = 0x00000003,
}

alias WRITE_CACHE_ENABLE = int;
enum : int
{
    WriteCacheEnableUnknown = 0x00000000,
    WriteCacheDisabled      = 0x00000001,
    WriteCacheEnabled       = 0x00000002,
}

alias WRITE_CACHE_CHANGE = int;
enum : int
{
    WriteCacheChangeUnknown = 0x00000000,
    WriteCacheNotChangeable = 0x00000001,
    WriteCacheChangeable    = 0x00000002,
}

alias WRITE_THROUGH = int;
enum : int
{
    WriteThroughUnknown      = 0x00000000,
    WriteThroughNotSupported = 0x00000001,
    WriteThroughSupported    = 0x00000002,
}

struct STORAGE_WRITE_CACHE_PROPERTY
{
    uint Version;
    uint Size;
    WRITE_CACHE_TYPE WriteCacheType;
    WRITE_CACHE_ENABLE WriteCacheEnabled;
    WRITE_CACHE_CHANGE WriteCacheChangeable;
    WRITE_THROUGH WriteThroughSupported;
    BOOLEAN FlushCacheSupported;
    BOOLEAN UserDefinedPowerProtection;
    BOOLEAN NVCacheEnabled;
}
struct PERSISTENT_RESERVE_COMMAND
{
    uint Version;
    uint Size;
    union
    {
        struct PR_IN
        {
            ubyte _bitfield0;
            ushort AllocationLength;
        }
        struct PR_OUT
        {
            ubyte _bitfield1;
            ubyte _bitfield2;
            ubyte[1] ParameterList;
        }
    }
}
alias DEVICEDUMP_COLLECTION_TYPEIDE_NOTIFICATION_TYPE = int;
enum : int
{
    TCCollectionBugCheck             = 0x00000001,
    TCCollectionApplicationRequested = 0x00000002,
    TCCollectionDeviceRequested      = 0x00000003,
}

struct DEVICEDUMP_SUBSECTION_POINTER
{
    align (1):
    uint dwSize;
    uint dwFlags;
    uint dwOffset;
}
struct DEVICEDUMP_STRUCTURE_VERSION
{
    align (1):
    uint dwSignature;
    uint dwVersion;
    uint dwSize;
}
struct DEVICEDUMP_SECTION_HEADER
{
    align (1):
    GUID guidDeviceDataId;
    ubyte[16] sOrganizationID;
    uint dwFirmwareRevision;
    ubyte[32] sModelNumber;
    ubyte[32] szDeviceManufacturingID;
    uint dwFlags;
    uint bRestrictedPrivateDataVersion;
    uint dwFirmwareIssueId;
    ubyte[132] szIssueDescriptionString;
}
struct GP_LOG_PAGE_DESCRIPTOR
{
    align (1):
    ushort LogAddress;
    ushort LogSectors;
}
struct DEVICEDUMP_PUBLIC_SUBSECTION
{
    align (1):
    uint dwFlags;
    GP_LOG_PAGE_DESCRIPTOR[16] GPLogTable;
    CHAR[16] szDescription;
    ubyte[1] bData;
}
struct DEVICEDUMP_RESTRICTED_SUBSECTION
{
    ubyte[1] bData;
}
struct DEVICEDUMP_PRIVATE_SUBSECTION
{
    align (1):
    uint dwFlags;
    GP_LOG_PAGE_DESCRIPTOR GPLogId;
    ubyte[1] bData;
}
struct DEVICEDUMP_STORAGEDEVICE_DATA
{
    align (1):
    DEVICEDUMP_STRUCTURE_VERSION Descriptor;
    DEVICEDUMP_SECTION_HEADER SectionHeader;
    uint dwBufferSize;
    uint dwReasonForCollection;
    DEVICEDUMP_SUBSECTION_POINTER PublicData;
    DEVICEDUMP_SUBSECTION_POINTER RestrictedData;
    DEVICEDUMP_SUBSECTION_POINTER PrivateData;
}
struct DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD
{
    align (1):
    ubyte[16] Cdb;
    ubyte[16] Command;
    ulong StartTime;
    ulong EndTime;
    uint OperationStatus;
    uint OperationError;
    union StackSpecific
    {
        struct ExternalStack
        {
            align (1):
            uint dwReserved;
        }
        struct AtaPort
        {
            align (1):
            uint dwAtaPortSpecific;
        }
        struct StorPort
        {
            align (1):
            uint SrbTag;
        }
    }
}
struct DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP
{
    align (1):
    DEVICEDUMP_STRUCTURE_VERSION Descriptor;
    uint dwReasonForCollection;
    ubyte[16] cDriverName;
    uint uiNumRecords;
    DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD[1] RecordArray;
}
struct STORAGE_IDLE_POWER
{
    uint Version;
    uint Size;
    uint _bitfield0;
    uint D3IdleTimeout;
}
alias STORAGE_POWERUP_REASON_TYPE = int;
enum : int
{
    StoragePowerupUnknown         = 0x00000000,
    StoragePowerupIO              = 0x00000001,
    StoragePowerupDeviceAttention = 0x00000002,
}

struct STORAGE_IDLE_POWERUP_REASON
{
    uint Version;
    uint Size;
    STORAGE_POWERUP_REASON_TYPE PowerupReason;
}
alias STORAGE_DEVICE_POWER_CAP_UNITS = int;
enum : int
{
    StorageDevicePowerCapUnitsPercent    = 0x00000000,
    StorageDevicePowerCapUnitsMilliwatts = 0x00000001,
}

struct STORAGE_DEVICE_POWER_CAP
{
    uint Version;
    uint Size;
    STORAGE_DEVICE_POWER_CAP_UNITS Units;
    ulong MaxPower;
}
struct STORAGE_RPMB_DATA_FRAME
{
    ubyte[196] Stuff;
    ubyte[32] KeyOrMAC;
    ubyte[256] Data;
    ubyte[16] Nonce;
    ubyte[4] WriteCounter;
    ubyte[2] Address;
    ubyte[2] BlockCount;
    ubyte[2] OperationResult;
    ubyte[2] RequestOrResponseType;
}
alias STORAGE_RPMB_COMMAND_TYPE = int;
enum : int
{
    StorRpmbProgramAuthKey                 = 0x00000001,
    StorRpmbQueryWriteCounter              = 0x00000002,
    StorRpmbAuthenticatedWrite             = 0x00000003,
    StorRpmbAuthenticatedRead              = 0x00000004,
    StorRpmbReadResultRequest              = 0x00000005,
    StorRpmbAuthenticatedDeviceConfigWrite = 0x00000006,
    StorRpmbAuthenticatedDeviceConfigRead  = 0x00000007,
}

struct STORAGE_EVENT_NOTIFICATION
{
    uint Version;
    uint Size;
    ulong Events;
}
alias STORAGE_COUNTER_TYPE = int;
enum : int
{
    StorageCounterTypeUnknown                 = 0x00000000,
    StorageCounterTypeTemperatureCelsius      = 0x00000001,
    StorageCounterTypeTemperatureCelsiusMax   = 0x00000002,
    StorageCounterTypeReadErrorsTotal         = 0x00000003,
    StorageCounterTypeReadErrorsCorrected     = 0x00000004,
    StorageCounterTypeReadErrorsUncorrected   = 0x00000005,
    StorageCounterTypeWriteErrorsTotal        = 0x00000006,
    StorageCounterTypeWriteErrorsCorrected    = 0x00000007,
    StorageCounterTypeWriteErrorsUncorrected  = 0x00000008,
    StorageCounterTypeManufactureDate         = 0x00000009,
    StorageCounterTypeStartStopCycleCount     = 0x0000000a,
    StorageCounterTypeStartStopCycleCountMax  = 0x0000000b,
    StorageCounterTypeLoadUnloadCycleCount    = 0x0000000c,
    StorageCounterTypeLoadUnloadCycleCountMax = 0x0000000d,
    StorageCounterTypeWearPercentage          = 0x0000000e,
    StorageCounterTypeWearPercentageWarning   = 0x0000000f,
    StorageCounterTypeWearPercentageMax       = 0x00000010,
    StorageCounterTypePowerOnHours            = 0x00000011,
    StorageCounterTypeReadLatency100NSMax     = 0x00000012,
    StorageCounterTypeWriteLatency100NSMax    = 0x00000013,
    StorageCounterTypeFlushLatency100NSMax    = 0x00000014,
    StorageCounterTypeMax                     = 0x00000015,
}

struct STORAGE_COUNTER
{
    STORAGE_COUNTER_TYPE Type;
    union Value
    {
        struct ManufactureDate
        {
            uint Week;
            uint Year;
        }
        ulong AsUlonglong;
    }
}
struct STORAGE_COUNTERS
{
    uint Version;
    uint Size;
    uint NumberOfCounters;
    STORAGE_COUNTER[1] Counters;
}
struct STORAGE_HW_FIRMWARE_INFO_QUERY
{
    uint Version;
    uint Size;
    uint Flags;
    uint Reserved;
}
struct STORAGE_HW_FIRMWARE_SLOT_INFO
{
    uint Version;
    uint Size;
    ubyte SlotNumber;
    ubyte _bitfield0;
    ubyte[6] Reserved1;
    ubyte[16] Revision;
}
struct STORAGE_HW_FIRMWARE_INFO
{
    uint Version;
    uint Size;
    ubyte _bitfield0;
    ubyte SlotCount;
    ubyte ActiveSlot;
    ubyte PendingActivateSlot;
    BOOLEAN FirmwareShared;
    ubyte[3] Reserved;
    uint ImagePayloadAlignment;
    uint ImagePayloadMaxSize;
    STORAGE_HW_FIRMWARE_SLOT_INFO[1] Slot;
}
struct STORAGE_HW_FIRMWARE_DOWNLOAD
{
    uint Version;
    uint Size;
    uint Flags;
    ubyte Slot;
    ubyte[3] Reserved;
    ulong Offset;
    ulong BufferSize;
    ubyte[1] ImageBuffer;
}
struct STORAGE_HW_FIRMWARE_DOWNLOAD_V2
{
    uint Version;
    uint Size;
    uint Flags;
    ubyte Slot;
    ubyte[3] Reserved;
    ulong Offset;
    ulong BufferSize;
    uint ImageSize;
    uint Reserved2;
    ubyte[1] ImageBuffer;
}
struct STORAGE_HW_FIRMWARE_ACTIVATE
{
    uint Version;
    uint Size;
    uint Flags;
    ubyte Slot;
    ubyte[3] Reserved0;
}
struct STORAGE_PROTOCOL_COMMAND
{
    uint Version;
    uint Length;
    STORAGE_PROTOCOL_TYPE ProtocolType;
    uint Flags;
    uint ReturnStatus;
    uint ErrorCode;
    uint CommandLength;
    uint ErrorInfoLength;
    uint DataToDeviceTransferLength;
    uint DataFromDeviceTransferLength;
    uint TimeOutValue;
    uint ErrorInfoOffset;
    uint DataToDeviceBufferOffset;
    uint DataFromDeviceBufferOffset;
    uint CommandSpecific;
    uint Reserved0;
    uint FixedProtocolReturnData;
    uint[3] Reserved1;
    ubyte[1] Command;
}
alias STORAGE_ATTRIBUTE_MGMT_ACTION = int;
enum : int
{
    StorAttributeMgmt_ClearAttribute = 0x00000000,
    StorAttributeMgmt_SetAttribute   = 0x00000001,
    StorAttributeMgmt_ResetAttribute = 0x00000002,
}

struct STORAGE_ATTRIBUTE_MGMT
{
    uint Version;
    uint Size;
    STORAGE_ATTRIBUTE_MGMT_ACTION Action;
    uint Attribute;
}
struct SCM_PD_HEALTH_NOTIFICATION_DATA
{
    GUID DeviceGuid;
}
struct SCM_LOGICAL_DEVICE_INSTANCE
{
    uint Version;
    uint Size;
    GUID DeviceGuid;
    wchar[256] SymbolicLink;
}
struct SCM_LOGICAL_DEVICES
{
    uint Version;
    uint Size;
    uint DeviceCount;
    SCM_LOGICAL_DEVICE_INSTANCE[1] Devices;
}
struct SCM_PHYSICAL_DEVICE_INSTANCE
{
    uint Version;
    uint Size;
    uint NfitHandle;
    wchar[256] SymbolicLink;
}
struct SCM_PHYSICAL_DEVICES
{
    uint Version;
    uint Size;
    uint DeviceCount;
    SCM_PHYSICAL_DEVICE_INSTANCE[1] Devices;
}
alias SCM_REGION_FLAG = int;
enum : int
{
    ScmRegionFlagNone  = 0x00000000,
    ScmRegionFlagLabel = 0x00000001,
}

struct SCM_REGION
{
    uint Version;
    uint Size;
    uint Flags;
    uint NfitHandle;
    GUID LogicalDeviceGuid;
    GUID AddressRangeType;
    uint AssociatedId;
    ulong Length;
    ulong StartingDPA;
    ulong BaseSPA;
    ulong SPAOffset;
    ulong RegionOffset;
}
struct SCM_REGIONS
{
    uint Version;
    uint Size;
    uint RegionCount;
    SCM_REGION[1] Regions;
}
alias SCM_BUS_QUERY_TYPE = int;
enum : int
{
    ScmBusQuery_Descriptor  = 0x00000000,
    ScmBusQuery_IsSupported = 0x00000001,
    ScmBusQuery_Max         = 0x00000002,
}

alias SCM_BUS_SET_TYPE = int;
enum : int
{
    ScmBusSet_Descriptor  = 0x00000000,
    ScmBusSet_IsSupported = 0x00000001,
    ScmBusSet_Max         = 0x00000002,
}

alias SCM_BUS_PROPERTY_ID = int;
enum : int
{
    ScmBusProperty_RuntimeFwActivationInfo = 0x00000000,
    ScmBusProperty_DedicatedMemoryInfo     = 0x00000001,
    ScmBusProperty_DedicatedMemoryState    = 0x00000002,
    ScmBusProperty_Max                     = 0x00000003,
}

struct SCM_BUS_PROPERTY_QUERY
{
    uint Version;
    uint Size;
    SCM_BUS_PROPERTY_ID PropertyId;
    SCM_BUS_QUERY_TYPE QueryType;
    ubyte[1] AdditionalParameters;
}
alias SCM_BUS_FIRMWARE_ACTIVATION_STATE = int;
enum : int
{
    ScmBusFirmwareActivationState_Idle  = 0x00000000,
    ScmBusFirmwareActivationState_Armed = 0x00000001,
    ScmBusFirmwareActivationState_Busy  = 0x00000002,
}

struct SCM_BUS_RUNTIME_FW_ACTIVATION_INFO
{
    uint Version;
    uint Size;
    BOOLEAN RuntimeFwActivationSupported;
    SCM_BUS_FIRMWARE_ACTIVATION_STATE FirmwareActivationState;
    struct FirmwareActivationCapability
    {
        uint _bitfield0;
    }
    ulong EstimatedFirmwareActivationTimeInUSecs;
    ulong EstimatedProcessorAccessQuiesceTimeInUSecs;
    ulong EstimatedIOAccessQuiesceTimeInUSecs;
    ulong PlatformSupportedMaxIOAccessQuiesceTimeInUSecs;
}
struct SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO
{
    GUID DeviceGuid;
    uint DeviceNumber;
    struct Flags
    {
        uint _bitfield0;
    }
    ulong DeviceSize;
}
struct SCM_BUS_DEDICATED_MEMORY_DEVICES_INFO
{
    uint Version;
    uint Size;
    uint DeviceCount;
    SCM_BUS_DEDICATED_MEMORY_DEVICE_INFO[1] Devices;
}
struct SCM_BUS_PROPERTY_SET
{
    uint Version;
    uint Size;
    SCM_BUS_PROPERTY_ID PropertyId;
    SCM_BUS_SET_TYPE SetType;
    ubyte[1] AdditionalParameters;
}
struct SCM_BUS_DEDICATED_MEMORY_STATE
{
    BOOLEAN ActivateState;
}
struct SCM_INTERLEAVED_PD_INFO
{
    uint DeviceHandle;
    GUID DeviceGuid;
}
struct SCM_LD_INTERLEAVE_SET_INFO
{
    uint Version;
    uint Size;
    uint InterleaveSetSize;
    SCM_INTERLEAVED_PD_INFO[1] InterleaveSet;
}
alias SCM_PD_QUERY_TYPE = int;
enum : int
{
    ScmPhysicalDeviceQuery_Descriptor  = 0x00000000,
    ScmPhysicalDeviceQuery_IsSupported = 0x00000001,
    ScmPhysicalDeviceQuery_Max         = 0x00000002,
}

alias SCM_PD_SET_TYPE = int;
enum : int
{
    ScmPhysicalDeviceSet_Descriptor  = 0x00000000,
    ScmPhysicalDeviceSet_IsSupported = 0x00000001,
    ScmPhysicalDeviceSet_Max         = 0x00000002,
}

alias SCM_PD_PROPERTY_ID = int;
enum : int
{
    ScmPhysicalDeviceProperty_DeviceInfo                  = 0x00000000,
    ScmPhysicalDeviceProperty_ManagementStatus            = 0x00000001,
    ScmPhysicalDeviceProperty_FirmwareInfo                = 0x00000002,
    ScmPhysicalDeviceProperty_LocationString              = 0x00000003,
    ScmPhysicalDeviceProperty_DeviceSpecificInfo          = 0x00000004,
    ScmPhysicalDeviceProperty_DeviceHandle                = 0x00000005,
    ScmPhysicalDeviceProperty_FruIdString                 = 0x00000006,
    ScmPhysicalDeviceProperty_RuntimeFwActivationInfo     = 0x00000007,
    ScmPhysicalDeviceProperty_RuntimeFwActivationArmState = 0x00000008,
    ScmPhysicalDeviceProperty_Max                         = 0x00000009,
}

struct SCM_PD_PROPERTY_QUERY
{
    uint Version;
    uint Size;
    SCM_PD_PROPERTY_ID PropertyId;
    SCM_PD_QUERY_TYPE QueryType;
    ubyte[1] AdditionalParameters;
}
struct SCM_PD_PROPERTY_SET
{
    uint Version;
    uint Size;
    SCM_PD_PROPERTY_ID PropertyId;
    SCM_PD_SET_TYPE SetType;
    ubyte[1] AdditionalParameters;
}
struct SCM_PD_RUNTIME_FW_ACTIVATION_ARM_STATE
{
    BOOLEAN ArmState;
}
struct SCM_PD_DESCRIPTOR_HEADER
{
    uint Version;
    uint Size;
}
struct SCM_PD_DEVICE_HANDLE
{
    uint Version;
    uint Size;
    GUID DeviceGuid;
    uint DeviceHandle;
}
struct SCM_PD_DEVICE_INFO
{
    uint Version;
    uint Size;
    GUID DeviceGuid;
    uint UnsafeShutdownCount;
    ulong PersistentMemorySizeInBytes;
    ulong VolatileMemorySizeInBytes;
    ulong TotalMemorySizeInBytes;
    uint SlotNumber;
    uint DeviceHandle;
    ushort PhysicalId;
    ubyte NumberOfFormatInterfaceCodes;
    ushort[8] FormatInterfaceCodes;
    uint VendorId;
    uint ProductId;
    uint SubsystemDeviceId;
    uint SubsystemVendorId;
    ubyte ManufacturingLocation;
    ubyte ManufacturingWeek;
    ubyte ManufacturingYear;
    uint SerialNumber4Byte;
    uint SerialNumberLengthInChars;
    CHAR[1] SerialNumber;
}
struct SCM_PD_DEVICE_SPECIFIC_PROPERTY
{
    wchar[128] Name;
    long Value;
}
struct SCM_PD_DEVICE_SPECIFIC_INFO
{
    uint Version;
    uint Size;
    uint NumberOfProperties;
    SCM_PD_DEVICE_SPECIFIC_PROPERTY[1] DeviceSpecificProperties;
}
struct SCM_PD_FIRMWARE_SLOT_INFO
{
    uint Version;
    uint Size;
    ubyte SlotNumber;
    ubyte _bitfield0;
    ubyte[6] Reserved1;
    ubyte[32] Revision;
}
struct SCM_PD_FIRMWARE_INFO
{
    uint Version;
    uint Size;
    ubyte ActiveSlot;
    ubyte NextActiveSlot;
    ubyte SlotCount;
    SCM_PD_FIRMWARE_SLOT_INFO[1] Slots;
}
alias SCM_PD_HEALTH_STATUS = int;
enum : int
{
    ScmPhysicalDeviceHealth_Unknown   = 0x00000000,
    ScmPhysicalDeviceHealth_Unhealthy = 0x00000001,
    ScmPhysicalDeviceHealth_Warning   = 0x00000002,
    ScmPhysicalDeviceHealth_Healthy   = 0x00000003,
    ScmPhysicalDeviceHealth_Max       = 0x00000004,
}

alias SCM_PD_OPERATIONAL_STATUS = int;
enum : int
{
    ScmPhysicalDeviceOpStatus_Unknown           = 0x00000000,
    ScmPhysicalDeviceOpStatus_Ok                = 0x00000001,
    ScmPhysicalDeviceOpStatus_PredictingFailure = 0x00000002,
    ScmPhysicalDeviceOpStatus_InService         = 0x00000003,
    ScmPhysicalDeviceOpStatus_HardwareError     = 0x00000004,
    ScmPhysicalDeviceOpStatus_NotUsable         = 0x00000005,
    ScmPhysicalDeviceOpStatus_TransientError    = 0x00000006,
    ScmPhysicalDeviceOpStatus_Missing           = 0x00000007,
    ScmPhysicalDeviceOpStatus_Max               = 0x00000008,
}

alias SCM_PD_OPERATIONAL_STATUS_REASON = int;
enum : int
{
    ScmPhysicalDeviceOpReason_Unknown                      = 0x00000000,
    ScmPhysicalDeviceOpReason_Media                        = 0x00000001,
    ScmPhysicalDeviceOpReason_ThresholdExceeded            = 0x00000002,
    ScmPhysicalDeviceOpReason_LostData                     = 0x00000003,
    ScmPhysicalDeviceOpReason_EnergySource                 = 0x00000004,
    ScmPhysicalDeviceOpReason_Configuration                = 0x00000005,
    ScmPhysicalDeviceOpReason_DeviceController             = 0x00000006,
    ScmPhysicalDeviceOpReason_MediaController              = 0x00000007,
    ScmPhysicalDeviceOpReason_Component                    = 0x00000008,
    ScmPhysicalDeviceOpReason_BackgroundOperation          = 0x00000009,
    ScmPhysicalDeviceOpReason_InvalidFirmware              = 0x0000000a,
    ScmPhysicalDeviceOpReason_HealthCheck                  = 0x0000000b,
    ScmPhysicalDeviceOpReason_LostDataPersistence          = 0x0000000c,
    ScmPhysicalDeviceOpReason_DisabledByPlatform           = 0x0000000d,
    ScmPhysicalDeviceOpReason_PermanentError               = 0x0000000e,
    ScmPhysicalDeviceOpReason_LostWritePersistence         = 0x0000000f,
    ScmPhysicalDeviceOpReason_FatalError                   = 0x00000010,
    ScmPhysicalDeviceOpReason_DataPersistenceLossImminent  = 0x00000011,
    ScmPhysicalDeviceOpReason_WritePersistenceLossImminent = 0x00000012,
    ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock     = 0x00000013,
    ScmPhysicalDeviceOpReason_PerformanceDegradation       = 0x00000014,
    ScmPhysicalDeviceOpReason_ExcessiveTemperature         = 0x00000015,
    ScmPhysicalDeviceOpReason_InternalFailure              = 0x00000016,
    ScmPhysicalDeviceOpReason_Max                          = 0x00000017,
}

struct SCM_PD_MANAGEMENT_STATUS
{
    uint Version;
    uint Size;
    SCM_PD_HEALTH_STATUS Health;
    uint NumberOfOperationalStatus;
    uint NumberOfAdditionalReasons;
    SCM_PD_OPERATIONAL_STATUS[16] OperationalStatus;
    SCM_PD_OPERATIONAL_STATUS_REASON[1] AdditionalReasons;
}
struct SCM_PD_LOCATION_STRING
{
    uint Version;
    uint Size;
    wchar[1] Location;
}
struct SCM_PD_FRU_ID_STRING
{
    uint Version;
    uint Size;
    uint IdentifierSize;
    ubyte[1] Identifier;
}
struct SCM_PD_FIRMWARE_DOWNLOAD
{
    uint Version;
    uint Size;
    uint Flags;
    ubyte Slot;
    ubyte[3] Reserved;
    ulong Offset;
    uint FirmwareImageSizeInBytes;
    ubyte[1] FirmwareImage;
}
struct SCM_PD_FIRMWARE_ACTIVATE
{
    uint Version;
    uint Size;
    uint Flags;
    ubyte Slot;
}
alias SCM_PD_LAST_FW_ACTIVATION_STATUS = int;
enum : int
{
    ScmPdLastFwActivationStatus_None                 = 0x00000000,
    ScmPdLastFwActivationStatus_Success              = 0x00000001,
    ScmPdLastFwActivationStatus_FwNotFound           = 0x00000002,
    ScmPdLastFwActivationStatus_ColdRebootRequired   = 0x00000003,
    ScmPdLastFwActivaitonStatus_ActivationInProgress = 0x00000004,
    ScmPdLastFwActivaitonStatus_Retry                = 0x00000005,
    ScmPdLastFwActivaitonStatus_FwUnsupported        = 0x00000006,
    ScmPdLastFwActivaitonStatus_UnknownError         = 0x00000007,
}

alias SCM_PD_FIRMWARE_ACTIVATION_STATE = int;
enum : int
{
    ScmPdFirmwareActivationState_Idle  = 0x00000000,
    ScmPdFirmwareActivationState_Armed = 0x00000001,
    ScmPdFirmwareActivationState_Busy  = 0x00000002,
}

struct SCM_PD_RUNTIME_FW_ACTIVATION_INFO
{
    uint Version;
    uint Size;
    SCM_PD_LAST_FW_ACTIVATION_STATUS LastFirmwareActivationStatus;
    SCM_PD_FIRMWARE_ACTIVATION_STATE FirmwareActivationState;
}
struct SCM_PD_PASSTHROUGH_INPUT
{
    uint Version;
    uint Size;
    GUID ProtocolGuid;
    uint DataSize;
    ubyte[1] Data;
}
struct SCM_PD_PASSTHROUGH_OUTPUT
{
    uint Version;
    uint Size;
    GUID ProtocolGuid;
    uint DataSize;
    ubyte[1] Data;
}
struct SCM_PD_PASSTHROUGH_INVDIMM_INPUT
{
    uint Opcode;
    uint OpcodeParametersLength;
    ubyte[1] OpcodeParameters;
}
struct SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT
{
    ushort GeneralStatus;
    ushort ExtendedStatus;
    uint OutputDataLength;
    ubyte[1] OutputData;
}
struct SCM_PD_REINITIALIZE_MEDIA_INPUT
{
    uint Version;
    uint Size;
    struct Options
    {
        uint _bitfield0;
    }
}
alias SCM_PD_MEDIA_REINITIALIZATION_STATUS = int;
enum : int
{
    ScmPhysicalDeviceReinit_Success        = 0x00000000,
    ScmPhysicalDeviceReinit_RebootNeeded   = 0x00000001,
    ScmPhysicalDeviceReinit_ColdBootNeeded = 0x00000002,
    ScmPhysicalDeviceReinit_Max            = 0x00000003,
}

struct SCM_PD_REINITIALIZE_MEDIA_OUTPUT
{
    uint Version;
    uint Size;
    SCM_PD_MEDIA_REINITIALIZATION_STATUS Status;
}
alias MEDIA_TYPE = int;
enum : int
{
    Unknown        = 0x00000000,
    F5_1Pt2_512    = 0x00000001,
    F3_1Pt44_512   = 0x00000002,
    F3_2Pt88_512   = 0x00000003,
    F3_20Pt8_512   = 0x00000004,
    F3_720_512     = 0x00000005,
    F5_360_512     = 0x00000006,
    F5_320_512     = 0x00000007,
    F5_320_1024    = 0x00000008,
    F5_180_512     = 0x00000009,
    F5_160_512     = 0x0000000a,
    RemovableMedia = 0x0000000b,
    FixedMedia     = 0x0000000c,
    F3_120M_512    = 0x0000000d,
    F3_640_512     = 0x0000000e,
    F5_640_512     = 0x0000000f,
    F5_720_512     = 0x00000010,
    F3_1Pt2_512    = 0x00000011,
    F3_1Pt23_1024  = 0x00000012,
    F5_1Pt23_1024  = 0x00000013,
    F3_128Mb_512   = 0x00000014,
    F3_230Mb_512   = 0x00000015,
    F8_256_128     = 0x00000016,
    F3_200Mb_512   = 0x00000017,
    F3_240M_512    = 0x00000018,
    F3_32M_512     = 0x00000019,
}

struct FORMAT_PARAMETERS
{
    MEDIA_TYPE MediaType;
    uint StartCylinderNumber;
    uint EndCylinderNumber;
    uint StartHeadNumber;
    uint EndHeadNumber;
}
struct FORMAT_EX_PARAMETERS
{
    MEDIA_TYPE MediaType;
    uint StartCylinderNumber;
    uint EndCylinderNumber;
    uint StartHeadNumber;
    uint EndHeadNumber;
    ushort FormatGapLength;
    ushort SectorsPerTrack;
    ushort[1] SectorNumber;
}
struct DISK_GEOMETRY
{
    long Cylinders;
    MEDIA_TYPE MediaType;
    uint TracksPerCylinder;
    uint SectorsPerTrack;
    uint BytesPerSector;
}
struct PARTITION_INFORMATION
{
    long StartingOffset;
    long PartitionLength;
    uint HiddenSectors;
    uint PartitionNumber;
    ubyte PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;
}
struct SET_PARTITION_INFORMATION
{
    ubyte PartitionType;
}
struct DRIVE_LAYOUT_INFORMATION
{
    uint PartitionCount;
    uint Signature;
    PARTITION_INFORMATION[1] PartitionEntry;
}
struct VERIFY_INFORMATION
{
    long StartingOffset;
    uint Length;
}
struct REASSIGN_BLOCKS
{
    ushort Reserved;
    ushort Count;
    uint[1] BlockNumber;
}
struct REASSIGN_BLOCKS_EX
{
    align (1):
    ushort Reserved;
    ushort Count;
    long[1] BlockNumber;
}
alias PARTITION_STYLE = int;
enum : int
{
    PARTITION_STYLE_MBR = 0x00000000,
    PARTITION_STYLE_GPT = 0x00000001,
    PARTITION_STYLE_RAW = 0x00000002,
}

struct PARTITION_INFORMATION_GPT
{
    GUID PartitionType;
    GUID PartitionId;
    GPT_ATTRIBUTES Attributes;
    wchar[36] Name;
}
struct PARTITION_INFORMATION_MBR
{
    ubyte PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    uint HiddenSectors;
    GUID PartitionId;
}
struct SET_PARTITION_INFORMATION_EX
{
    PARTITION_STYLE PartitionStyle;
    union
    {
        SET_PARTITION_INFORMATION Mbr;
        PARTITION_INFORMATION_GPT Gpt;
    }
}
struct CREATE_DISK_GPT
{
    GUID DiskId;
    uint MaxPartitionCount;
}
struct CREATE_DISK_MBR
{
    uint Signature;
}
struct CREATE_DISK
{
    PARTITION_STYLE PartitionStyle;
    union
    {
        CREATE_DISK_MBR Mbr;
        CREATE_DISK_GPT Gpt;
    }
}
struct GET_LENGTH_INFORMATION
{
    long Length;
}
struct PARTITION_INFORMATION_EX
{
    PARTITION_STYLE PartitionStyle;
    long StartingOffset;
    long PartitionLength;
    uint PartitionNumber;
    BOOLEAN RewritePartition;
    BOOLEAN IsServicePartition;
    union
    {
        PARTITION_INFORMATION_MBR Mbr;
        PARTITION_INFORMATION_GPT Gpt;
    }
}
struct DRIVE_LAYOUT_INFORMATION_GPT
{
    GUID DiskId;
    long StartingUsableOffset;
    long UsableLength;
    uint MaxPartitionCount;
}
struct DRIVE_LAYOUT_INFORMATION_MBR
{
    uint Signature;
    uint CheckSum;
}
struct DRIVE_LAYOUT_INFORMATION_EX
{
    uint PartitionStyle;
    uint PartitionCount;
    union
    {
        DRIVE_LAYOUT_INFORMATION_MBR Mbr;
        DRIVE_LAYOUT_INFORMATION_GPT Gpt;
    }
    PARTITION_INFORMATION_EX[1] PartitionEntry;
}
alias DETECTION_TYPE = int;
enum : int
{
    DetectNone    = 0x00000000,
    DetectInt13   = 0x00000001,
    DetectExInt13 = 0x00000002,
}

struct DISK_INT13_INFO
{
    ushort DriveSelect;
    uint MaxCylinders;
    ushort SectorsPerTrack;
    ushort MaxHeads;
    ushort NumberDrives;
}
struct DISK_EX_INT13_INFO
{
    ushort ExBufferSize;
    ushort ExFlags;
    uint ExCylinders;
    uint ExHeads;
    uint ExSectorsPerTrack;
    ulong ExSectorsPerDrive;
    ushort ExSectorSize;
    ushort ExReserved;
}
struct DISK_DETECTION_INFO
{
    uint SizeOfDetectInfo;
    DETECTION_TYPE DetectionType;
    union
    {
        struct
        {
            DISK_INT13_INFO Int13;
            DISK_EX_INT13_INFO ExInt13;
        }
    }
}
struct DISK_PARTITION_INFO
{
    uint SizeOfPartitionInfo;
    PARTITION_STYLE PartitionStyle;
    union
    {
        struct Mbr
        {
            uint Signature;
            uint CheckSum;
        }
        struct Gpt
        {
            GUID DiskId;
        }
    }
}
struct DISK_GEOMETRY_EX
{
    DISK_GEOMETRY Geometry;
    long DiskSize;
    ubyte[1] Data;
}
struct DISK_CONTROLLER_NUMBER
{
    uint ControllerNumber;
    uint DiskNumber;
}
alias DISK_CACHE_RETENTION_PRIORITY = int;
enum : int
{
    EqualPriority      = 0x00000000,
    KeepPrefetchedData = 0x00000001,
    KeepReadData       = 0x00000002,
}

struct DISK_CACHE_INFORMATION
{
    BOOLEAN ParametersSavable;
    BOOLEAN ReadCacheEnabled;
    BOOLEAN WriteCacheEnabled;
    DISK_CACHE_RETENTION_PRIORITY ReadRetentionPriority;
    DISK_CACHE_RETENTION_PRIORITY WriteRetentionPriority;
    ushort DisablePrefetchTransferLength;
    BOOLEAN PrefetchScalar;
    union
    {
        struct ScalarPrefetch
        {
            ushort Minimum;
            ushort Maximum;
            ushort MaximumBlocks;
        }
        struct BlockPrefetch
        {
            ushort Minimum;
            ushort Maximum;
        }
    }
}
struct DISK_GROW_PARTITION
{
    uint PartitionNumber;
    long BytesToGrow;
}
struct HISTOGRAM_BUCKET
{
    uint Reads;
    uint Writes;
}
struct DISK_HISTOGRAM
{
    long DiskSize;
    long Start;
    long End;
    long Average;
    long AverageRead;
    long AverageWrite;
    uint Granularity;
    uint Size;
    uint ReadCount;
    uint WriteCount;
    HISTOGRAM_BUCKET* Histogram;
}
struct DISK_PERFORMANCE
{
    long BytesRead;
    long BytesWritten;
    long ReadTime;
    long WriteTime;
    long IdleTime;
    uint ReadCount;
    uint WriteCount;
    uint QueueDepth;
    uint SplitCount;
    long QueryTime;
    uint StorageDeviceNumber;
    wchar[8] StorageManagerName;
}
struct DISK_RECORD
{
    long ByteOffset;
    long StartTime;
    long EndTime;
    void* VirtualAddress;
    uint NumberOfBytes;
    ubyte DeviceNumber;
    BOOLEAN ReadRequest;
}
struct DISK_LOGGING
{
    ubyte Function;
    void* BufferAddress;
    uint BufferSize;
}
alias BIN_TYPES = int;
enum : int
{
    RequestSize     = 0x00000000,
    RequestLocation = 0x00000001,
}

struct BIN_RANGE
{
    long StartValue;
    long Length;
}
struct PERF_BIN
{
    uint NumberOfBins;
    uint TypeOfBin;
    BIN_RANGE[1] BinsRanges;
}
struct BIN_COUNT
{
    BIN_RANGE BinRange;
    uint BinCount;
}
struct BIN_RESULTS
{
    uint NumberOfBins;
    BIN_COUNT[1] BinCounts;
}
struct GETVERSIONINPARAMS
{
    align (1):
    ubyte bVersion;
    ubyte bRevision;
    ubyte bReserved;
    ubyte bIDEDeviceMap;
    uint fCapabilities;
    uint[4] dwReserved;
}
struct IDEREGS
{
    ubyte bFeaturesReg;
    ubyte bSectorCountReg;
    ubyte bSectorNumberReg;
    ubyte bCylLowReg;
    ubyte bCylHighReg;
    ubyte bDriveHeadReg;
    ubyte bCommandReg;
    ubyte bReserved;
}
struct SENDCMDINPARAMS
{
    align (1):
    uint cBufferSize;
    IDEREGS irDriveRegs;
    ubyte bDriveNumber;
    ubyte[3] bReserved;
    uint[4] dwReserved;
    ubyte[1] bBuffer;
}
struct DRIVERSTATUS
{
    align (1):
    ubyte bDriverError;
    ubyte bIDEError;
    ubyte[2] bReserved;
    uint[2] dwReserved;
}
struct SENDCMDOUTPARAMS
{
    align (1):
    uint cBufferSize;
    DRIVERSTATUS DriverStatus;
    ubyte[1] bBuffer;
}
struct GET_DISK_ATTRIBUTES
{
    uint Version;
    uint Reserved1;
    ulong Attributes;
}
struct SET_DISK_ATTRIBUTES
{
    uint Version;
    BOOLEAN Persist;
    ubyte[3] Reserved1;
    ulong Attributes;
    ulong AttributesMask;
    uint[4] Reserved2;
}
alias ELEMENT_TYPE = int;
enum : int
{
    AllElements       = 0x00000000,
    ChangerTransport  = 0x00000001,
    ChangerSlot       = 0x00000002,
    ChangerIEPort     = 0x00000003,
    ChangerDrive      = 0x00000004,
    ChangerDoor       = 0x00000005,
    ChangerKeypad     = 0x00000006,
    ChangerMaxElement = 0x00000007,
}

struct CHANGER_ELEMENT
{
    ELEMENT_TYPE ElementType;
    uint ElementAddress;
}
struct CHANGER_ELEMENT_LIST
{
    CHANGER_ELEMENT Element;
    uint NumberOfElements;
}
struct GET_CHANGER_PARAMETERS
{
    uint Size;
    ushort NumberTransportElements;
    ushort NumberStorageElements;
    ushort NumberCleanerSlots;
    ushort NumberIEElements;
    ushort NumberDataTransferElements;
    ushort NumberOfDoors;
    ushort FirstSlotNumber;
    ushort FirstDriveNumber;
    ushort FirstTransportNumber;
    ushort FirstIEPortNumber;
    ushort FirstCleanerSlotAddress;
    ushort MagazineSize;
    uint DriveCleanTimeout;
    CHANGER_FEATURES Features0;
    GET_CHANGER_PARAMETERS_FEATURES1 Features1;
    ubyte MoveFromTransport;
    ubyte MoveFromSlot;
    ubyte MoveFromIePort;
    ubyte MoveFromDrive;
    ubyte ExchangeFromTransport;
    ubyte ExchangeFromSlot;
    ubyte ExchangeFromIePort;
    ubyte ExchangeFromDrive;
    ubyte LockUnlockCapabilities;
    ubyte PositionCapabilities;
    ubyte[2] Reserved1;
    uint[2] Reserved2;
}
struct CHANGER_PRODUCT_DATA
{
    ubyte[8] VendorId;
    ubyte[16] ProductId;
    ubyte[4] Revision;
    ubyte[32] SerialNumber;
    ubyte DeviceType;
}
struct CHANGER_SET_ACCESS
{
    CHANGER_ELEMENT Element;
    uint Control;
}
struct CHANGER_READ_ELEMENT_STATUS
{
    CHANGER_ELEMENT_LIST ElementList;
    BOOLEAN VolumeTagInfo;
}
struct CHANGER_ELEMENT_STATUS
{
    CHANGER_ELEMENT Element;
    CHANGER_ELEMENT SrcElementAddress;
    CHANGER_ELEMENT_STATUS_FLAGS Flags;
    uint ExceptionCode;
    ubyte TargetId;
    ubyte Lun;
    ushort Reserved;
    ubyte[36] PrimaryVolumeID;
    ubyte[36] AlternateVolumeID;
}
struct CHANGER_ELEMENT_STATUS_EX
{
    CHANGER_ELEMENT Element;
    CHANGER_ELEMENT SrcElementAddress;
    CHANGER_ELEMENT_STATUS_FLAGS Flags;
    uint ExceptionCode;
    ubyte TargetId;
    ubyte Lun;
    ushort Reserved;
    ubyte[36] PrimaryVolumeID;
    ubyte[36] AlternateVolumeID;
    ubyte[8] VendorIdentification;
    ubyte[16] ProductIdentification;
    ubyte[32] SerialNumber;
}
struct CHANGER_INITIALIZE_ELEMENT_STATUS
{
    CHANGER_ELEMENT_LIST ElementList;
    BOOLEAN BarCodeScan;
}
struct CHANGER_SET_POSITION
{
    CHANGER_ELEMENT Transport;
    CHANGER_ELEMENT Destination;
    BOOLEAN Flip;
}
struct CHANGER_EXCHANGE_MEDIUM
{
    CHANGER_ELEMENT Transport;
    CHANGER_ELEMENT Source;
    CHANGER_ELEMENT Destination1;
    CHANGER_ELEMENT Destination2;
    BOOLEAN Flip1;
    BOOLEAN Flip2;
}
struct CHANGER_MOVE_MEDIUM
{
    CHANGER_ELEMENT Transport;
    CHANGER_ELEMENT Source;
    CHANGER_ELEMENT Destination;
    BOOLEAN Flip;
}
struct CHANGER_SEND_VOLUME_TAG_INFORMATION
{
    CHANGER_ELEMENT StartingElement;
    uint ActionCode;
    ubyte[40] VolumeIDTemplate;
}
struct READ_ELEMENT_ADDRESS_INFO
{
    uint NumberOfElements;
    CHANGER_ELEMENT_STATUS[1] ElementStatus;
}
alias CHANGER_DEVICE_PROBLEM_TYPE = int;
enum : int
{
    DeviceProblemNone                 = 0x00000000,
    DeviceProblemHardware             = 0x00000001,
    DeviceProblemCHMError             = 0x00000002,
    DeviceProblemDoorOpen             = 0x00000003,
    DeviceProblemCalibrationError     = 0x00000004,
    DeviceProblemTargetFailure        = 0x00000005,
    DeviceProblemCHMMoveError         = 0x00000006,
    DeviceProblemCHMZeroError         = 0x00000007,
    DeviceProblemCartridgeInsertError = 0x00000008,
    DeviceProblemPositionError        = 0x00000009,
    DeviceProblemSensorError          = 0x0000000a,
    DeviceProblemCartridgeEjectError  = 0x0000000b,
    DeviceProblemGripperError         = 0x0000000c,
    DeviceProblemDriveError           = 0x0000000d,
}

struct PATHNAME_BUFFER
{
    uint PathNameLength;
    wchar[1] Name;
}
struct FSCTL_QUERY_FAT_BPB_BUFFER
{
    ubyte[36] First0x24BytesOfBootSector;
}
struct NTFS_VOLUME_DATA_BUFFER
{
    long VolumeSerialNumber;
    long NumberSectors;
    long TotalClusters;
    long FreeClusters;
    long TotalReserved;
    uint BytesPerSector;
    uint BytesPerCluster;
    uint BytesPerFileRecordSegment;
    uint ClustersPerFileRecordSegment;
    long MftValidDataLength;
    long MftStartLcn;
    long Mft2StartLcn;
    long MftZoneStart;
    long MftZoneEnd;
}
struct NTFS_EXTENDED_VOLUME_DATA
{
    uint ByteCount;
    ushort MajorVersion;
    ushort MinorVersion;
    uint BytesPerPhysicalSector;
    ushort LfsMajorVersion;
    ushort LfsMinorVersion;
    uint MaxDeviceTrimExtentCount;
    uint MaxDeviceTrimByteCount;
    uint MaxVolumeTrimExtentCount;
    uint MaxVolumeTrimByteCount;
}
struct REFS_VOLUME_DATA_BUFFER
{
    uint ByteCount;
    uint MajorVersion;
    uint MinorVersion;
    uint BytesPerPhysicalSector;
    long VolumeSerialNumber;
    long NumberSectors;
    long TotalClusters;
    long FreeClusters;
    long TotalReserved;
    uint BytesPerSector;
    uint BytesPerCluster;
    long MaximumSizeOfResidentFile;
    ushort FastTierDataFillRatio;
    ushort SlowTierDataFillRatio;
    uint DestagesFastTierToSlowTierRate;
    long[9] Reserved;
}
struct STARTING_LCN_INPUT_BUFFER
{
    long StartingLcn;
}
struct STARTING_LCN_INPUT_BUFFER_EX
{
    long StartingLcn;
    uint Flags;
}
struct VOLUME_BITMAP_BUFFER
{
    long StartingLcn;
    long BitmapSize;
    ubyte[1] Buffer;
}
struct STARTING_VCN_INPUT_BUFFER
{
    long StartingVcn;
}
struct RETRIEVAL_POINTERS_BUFFER
{
    uint ExtentCount;
    long StartingVcn;
    struct
    {
        long NextVcn;
        long Lcn;
    }
}
struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER
{
    uint ExtentCount;
    long StartingVcn;
    struct
    {
        long NextVcn;
        long Lcn;
        uint ReferenceCount;
    }
}
struct RETRIEVAL_POINTER_COUNT
{
    uint ExtentCount;
}
struct NTFS_FILE_RECORD_INPUT_BUFFER
{
    long FileReferenceNumber;
}
struct NTFS_FILE_RECORD_OUTPUT_BUFFER
{
    long FileReferenceNumber;
    uint FileRecordLength;
    ubyte[1] FileRecordBuffer;
}
struct MOVE_FILE_DATA
{
    HANDLE FileHandle;
    long StartingVcn;
    long StartingLcn;
    uint ClusterCount;
}
struct MOVE_FILE_RECORD_DATA
{
    HANDLE FileHandle;
    long SourceFileRecord;
    long TargetFileRecord;
}
struct FIND_BY_SID_DATA
{
    uint Restart;
    SID Sid;
}
struct FIND_BY_SID_OUTPUT
{
    uint NextEntryOffset;
    uint FileIndex;
    uint FileNameLength;
    wchar[1] FileName;
}
struct MFT_ENUM_DATA_V0
{
    ulong StartFileReferenceNumber;
    long LowUsn;
    long HighUsn;
}
struct MFT_ENUM_DATA_V1
{
    ulong StartFileReferenceNumber;
    long LowUsn;
    long HighUsn;
    ushort MinMajorVersion;
    ushort MaxMajorVersion;
}
struct CREATE_USN_JOURNAL_DATA
{
    ulong MaximumSize;
    ulong AllocationDelta;
}
struct READ_FILE_USN_DATA
{
    ushort MinMajorVersion;
    ushort MaxMajorVersion;
}
struct READ_USN_JOURNAL_DATA_V0
{
    long StartUsn;
    uint ReasonMask;
    uint ReturnOnlyOnClose;
    ulong Timeout;
    ulong BytesToWaitFor;
    ulong UsnJournalID;
}
struct READ_USN_JOURNAL_DATA_V1
{
    long StartUsn;
    uint ReasonMask;
    uint ReturnOnlyOnClose;
    ulong Timeout;
    ulong BytesToWaitFor;
    ulong UsnJournalID;
    ushort MinMajorVersion;
    ushort MaxMajorVersion;
}
struct USN_TRACK_MODIFIED_RANGES
{
    uint Flags;
    uint Unused;
    ulong ChunkSize;
    long FileSizeThreshold;
}
struct USN_RANGE_TRACK_OUTPUT
{
    long Usn;
}
struct USN_RECORD_V2
{
    uint RecordLength;
    ushort MajorVersion;
    ushort MinorVersion;
    ulong FileReferenceNumber;
    ulong ParentFileReferenceNumber;
    long Usn;
    long TimeStamp;
    uint Reason;
    uint SourceInfo;
    uint SecurityId;
    uint FileAttributes;
    ushort FileNameLength;
    ushort FileNameOffset;
    wchar[1] FileName;
}
struct USN_RECORD_V3
{
    uint RecordLength;
    ushort MajorVersion;
    ushort MinorVersion;
    FILE_ID_128 FileReferenceNumber;
    FILE_ID_128 ParentFileReferenceNumber;
    long Usn;
    long TimeStamp;
    uint Reason;
    uint SourceInfo;
    uint SecurityId;
    uint FileAttributes;
    ushort FileNameLength;
    ushort FileNameOffset;
    wchar[1] FileName;
}
struct USN_RECORD_COMMON_HEADER
{
    uint RecordLength;
    ushort MajorVersion;
    ushort MinorVersion;
}
struct USN_RECORD_EXTENT
{
    long Offset;
    long Length;
}
struct USN_RECORD_V4
{
    USN_RECORD_COMMON_HEADER Header;
    FILE_ID_128 FileReferenceNumber;
    FILE_ID_128 ParentFileReferenceNumber;
    long Usn;
    uint Reason;
    USN_SOURCE_INFO_ID SourceInfo;
    uint RemainingExtents;
    ushort NumberOfExtents;
    ushort ExtentSize;
    USN_RECORD_EXTENT[1] Extents;
}
union USN_RECORD_UNION
{
    USN_RECORD_COMMON_HEADER Header;
    USN_RECORD_V2 V2;
    USN_RECORD_V3 V3;
    USN_RECORD_V4 V4;
}
struct USN_JOURNAL_DATA_V0
{
    ulong UsnJournalID;
    long FirstUsn;
    long NextUsn;
    long LowestValidUsn;
    long MaxUsn;
    ulong MaximumSize;
    ulong AllocationDelta;
}
struct USN_JOURNAL_DATA_V1
{
    ulong UsnJournalID;
    long FirstUsn;
    long NextUsn;
    long LowestValidUsn;
    long MaxUsn;
    ulong MaximumSize;
    ulong AllocationDelta;
    ushort MinSupportedMajorVersion;
    ushort MaxSupportedMajorVersion;
}
struct USN_JOURNAL_DATA_V2
{
    ulong UsnJournalID;
    long FirstUsn;
    long NextUsn;
    long LowestValidUsn;
    long MaxUsn;
    ulong MaximumSize;
    ulong AllocationDelta;
    ushort MinSupportedMajorVersion;
    ushort MaxSupportedMajorVersion;
    uint Flags;
    ulong RangeTrackChunkSize;
    long RangeTrackFileSizeThreshold;
}
struct DELETE_USN_JOURNAL_DATA
{
    ulong UsnJournalID;
    USN_DELETE_FLAGS DeleteFlags;
}
struct MARK_HANDLE_INFO
{
    union
    {
        uint UsnSourceInfo;
        uint CopyNumber;
    }
    HANDLE VolumeHandle;
    uint HandleInfo;
}
struct BULK_SECURITY_TEST_DATA
{
    uint DesiredAccess;
    uint[1] SecurityIds;
}
struct FILE_PREFETCH
{
    uint Type;
    uint Count;
    ulong[1] Prefetch;
}
struct FILE_PREFETCH_EX
{
    uint Type;
    uint Count;
    void* Context;
    ulong[1] Prefetch;
}
struct FILESYSTEM_STATISTICS
{
    FILESYSTEM_STATISTICS_TYPE FileSystemType;
    ushort Version;
    uint SizeOfCompleteStructure;
    uint UserFileReads;
    uint UserFileReadBytes;
    uint UserDiskReads;
    uint UserFileWrites;
    uint UserFileWriteBytes;
    uint UserDiskWrites;
    uint MetaDataReads;
    uint MetaDataReadBytes;
    uint MetaDataDiskReads;
    uint MetaDataWrites;
    uint MetaDataWriteBytes;
    uint MetaDataDiskWrites;
}
struct FAT_STATISTICS
{
    uint CreateHits;
    uint SuccessfulCreates;
    uint FailedCreates;
    uint NonCachedReads;
    uint NonCachedReadBytes;
    uint NonCachedWrites;
    uint NonCachedWriteBytes;
    uint NonCachedDiskReads;
    uint NonCachedDiskWrites;
}
struct EXFAT_STATISTICS
{
    uint CreateHits;
    uint SuccessfulCreates;
    uint FailedCreates;
    uint NonCachedReads;
    uint NonCachedReadBytes;
    uint NonCachedWrites;
    uint NonCachedWriteBytes;
    uint NonCachedDiskReads;
    uint NonCachedDiskWrites;
}
struct NTFS_STATISTICS
{
    uint LogFileFullExceptions;
    uint OtherExceptions;
    uint MftReads;
    uint MftReadBytes;
    uint MftWrites;
    uint MftWriteBytes;
    struct MftWritesUserLevel
    {
        ushort Write;
        ushort Create;
        ushort SetInfo;
        ushort Flush;
    }
    ushort MftWritesFlushForLogFileFull;
    ushort MftWritesLazyWriter;
    ushort MftWritesUserRequest;
    uint Mft2Writes;
    uint Mft2WriteBytes;
    struct Mft2WritesUserLevel
    {
        ushort Write;
        ushort Create;
        ushort SetInfo;
        ushort Flush;
    }
    ushort Mft2WritesFlushForLogFileFull;
    ushort Mft2WritesLazyWriter;
    ushort Mft2WritesUserRequest;
    uint RootIndexReads;
    uint RootIndexReadBytes;
    uint RootIndexWrites;
    uint RootIndexWriteBytes;
    uint BitmapReads;
    uint BitmapReadBytes;
    uint BitmapWrites;
    uint BitmapWriteBytes;
    ushort BitmapWritesFlushForLogFileFull;
    ushort BitmapWritesLazyWriter;
    ushort BitmapWritesUserRequest;
    struct BitmapWritesUserLevel
    {
        ushort Write;
        ushort Create;
        ushort SetInfo;
    }
    uint MftBitmapReads;
    uint MftBitmapReadBytes;
    uint MftBitmapWrites;
    uint MftBitmapWriteBytes;
    ushort MftBitmapWritesFlushForLogFileFull;
    ushort MftBitmapWritesLazyWriter;
    ushort MftBitmapWritesUserRequest;
    struct MftBitmapWritesUserLevel
    {
        ushort Write;
        ushort Create;
        ushort SetInfo;
        ushort Flush;
    }
    uint UserIndexReads;
    uint UserIndexReadBytes;
    uint UserIndexWrites;
    uint UserIndexWriteBytes;
    uint LogFileReads;
    uint LogFileReadBytes;
    uint LogFileWrites;
    uint LogFileWriteBytes;
    struct Allocate
    {
        uint Calls;
        uint Clusters;
        uint Hints;
        uint RunsReturned;
        uint HintsHonored;
        uint HintsClusters;
        uint Cache;
        uint CacheClusters;
        uint CacheMiss;
        uint CacheMissClusters;
    }
    uint DiskResourcesExhausted;
}
struct FILESYSTEM_STATISTICS_EX
{
    FILESYSTEM_STATISTICS_TYPE FileSystemType;
    ushort Version;
    uint SizeOfCompleteStructure;
    ulong UserFileReads;
    ulong UserFileReadBytes;
    ulong UserDiskReads;
    ulong UserFileWrites;
    ulong UserFileWriteBytes;
    ulong UserDiskWrites;
    ulong MetaDataReads;
    ulong MetaDataReadBytes;
    ulong MetaDataDiskReads;
    ulong MetaDataWrites;
    ulong MetaDataWriteBytes;
    ulong MetaDataDiskWrites;
}
struct NTFS_STATISTICS_EX
{
    uint LogFileFullExceptions;
    uint OtherExceptions;
    ulong MftReads;
    ulong MftReadBytes;
    ulong MftWrites;
    ulong MftWriteBytes;
    struct MftWritesUserLevel
    {
        uint Write;
        uint Create;
        uint SetInfo;
        uint Flush;
    }
    uint MftWritesFlushForLogFileFull;
    uint MftWritesLazyWriter;
    uint MftWritesUserRequest;
    ulong Mft2Writes;
    ulong Mft2WriteBytes;
    struct Mft2WritesUserLevel
    {
        uint Write;
        uint Create;
        uint SetInfo;
        uint Flush;
    }
    uint Mft2WritesFlushForLogFileFull;
    uint Mft2WritesLazyWriter;
    uint Mft2WritesUserRequest;
    ulong RootIndexReads;
    ulong RootIndexReadBytes;
    ulong RootIndexWrites;
    ulong RootIndexWriteBytes;
    ulong BitmapReads;
    ulong BitmapReadBytes;
    ulong BitmapWrites;
    ulong BitmapWriteBytes;
    uint BitmapWritesFlushForLogFileFull;
    uint BitmapWritesLazyWriter;
    uint BitmapWritesUserRequest;
    struct BitmapWritesUserLevel
    {
        uint Write;
        uint Create;
        uint SetInfo;
        uint Flush;
    }
    ulong MftBitmapReads;
    ulong MftBitmapReadBytes;
    ulong MftBitmapWrites;
    ulong MftBitmapWriteBytes;
    uint MftBitmapWritesFlushForLogFileFull;
    uint MftBitmapWritesLazyWriter;
    uint MftBitmapWritesUserRequest;
    struct MftBitmapWritesUserLevel
    {
        uint Write;
        uint Create;
        uint SetInfo;
        uint Flush;
    }
    ulong UserIndexReads;
    ulong UserIndexReadBytes;
    ulong UserIndexWrites;
    ulong UserIndexWriteBytes;
    ulong LogFileReads;
    ulong LogFileReadBytes;
    ulong LogFileWrites;
    ulong LogFileWriteBytes;
    struct Allocate
    {
        uint Calls;
        uint RunsReturned;
        uint Hints;
        uint HintsHonored;
        uint Cache;
        uint CacheMiss;
        ulong Clusters;
        ulong HintsClusters;
        ulong CacheClusters;
        ulong CacheMissClusters;
    }
    uint DiskResourcesExhausted;
    ulong VolumeTrimCount;
    ulong VolumeTrimTime;
    ulong VolumeTrimByteCount;
    ulong FileLevelTrimCount;
    ulong FileLevelTrimTime;
    ulong FileLevelTrimByteCount;
    ulong VolumeTrimSkippedCount;
    ulong VolumeTrimSkippedByteCount;
    ulong NtfsFillStatInfoFromMftRecordCalledCount;
    ulong NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount;
    ulong NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount;
}
struct FILE_OBJECTID_BUFFER
{
    ubyte[16] ObjectId;
    union
    {
        struct
        {
            ubyte[16] BirthVolumeId;
            ubyte[16] BirthObjectId;
            ubyte[16] DomainId;
        }
        ubyte[48] ExtendedInfo;
    }
}
struct FILE_SET_SPARSE_BUFFER
{
    BOOLEAN SetSparse;
}
struct FILE_ZERO_DATA_INFORMATION
{
    long FileOffset;
    long BeyondFinalZero;
}
struct FILE_ZERO_DATA_INFORMATION_EX
{
    long FileOffset;
    long BeyondFinalZero;
    uint Flags;
}
struct FILE_ALLOCATED_RANGE_BUFFER
{
    long FileOffset;
    long Length;
}
struct ENCRYPTION_BUFFER
{
    uint EncryptionOperation;
    ubyte[1] Private;
}
struct DECRYPTION_STATUS_BUFFER
{
    BOOLEAN NoEncryptedStreams;
}
struct REQUEST_RAW_ENCRYPTED_DATA
{
    long FileOffset;
    uint Length;
}
struct ENCRYPTED_DATA_INFO
{
    ulong StartingFileOffset;
    uint OutputBufferOffset;
    uint BytesWithinFileSize;
    uint BytesWithinValidDataLength;
    ushort CompressionFormat;
    ubyte DataUnitShift;
    ubyte ChunkShift;
    ubyte ClusterShift;
    ubyte EncryptionFormat;
    ushort NumberOfDataBlocks;
    uint[1] DataBlockSize;
}
struct EXTENDED_ENCRYPTED_DATA_INFO
{
    uint ExtendedCode;
    uint Length;
    uint Flags;
    uint Reserved;
}
struct PLEX_READ_DATA_REQUEST
{
    long ByteOffset;
    uint ByteLength;
    uint PlexNumber;
}
struct SI_COPYFILE
{
    uint SourceFileNameLength;
    uint DestinationFileNameLength;
    uint Flags;
    wchar[1] FileNameBuffer;
}
struct FILE_MAKE_COMPATIBLE_BUFFER
{
    BOOLEAN CloseDisc;
}
struct FILE_SET_DEFECT_MGMT_BUFFER
{
    BOOLEAN Disable;
}
struct FILE_QUERY_SPARING_BUFFER
{
    uint SparingUnitBytes;
    BOOLEAN SoftwareSparing;
    uint TotalSpareBlocks;
    uint FreeSpareBlocks;
}
struct FILE_QUERY_ON_DISK_VOL_INFO_BUFFER
{
    long DirectoryCount;
    long FileCount;
    ushort FsFormatMajVersion;
    ushort FsFormatMinVersion;
    wchar[12] FsFormatName;
    long FormatTime;
    long LastUpdateTime;
    wchar[34] CopyrightInfo;
    wchar[34] AbstractInfo;
    wchar[34] FormattingImplementationInfo;
    wchar[34] LastModifyingImplementationInfo;
}
struct FILE_INITIATE_REPAIR_OUTPUT_BUFFER
{
    ulong Hint1;
    ulong Hint2;
    ulong Clsn;
    uint Status;
}
alias SHRINK_VOLUME_REQUEST_TYPES = int;
enum : int
{
    ShrinkPrepare = 0x00000001,
    ShrinkCommit  = 0x00000002,
    ShrinkAbort   = 0x00000003,
}

struct SHRINK_VOLUME_INFORMATION
{
    SHRINK_VOLUME_REQUEST_TYPES ShrinkRequestType;
    ulong Flags;
    long NewNumberOfSectors;
}
struct TXFS_MODIFY_RM
{
    TXFS_RMF_LAGS Flags;
    uint LogContainerCountMax;
    uint LogContainerCountMin;
    uint LogContainerCount;
    uint LogGrowthIncrement;
    uint LogAutoShrinkPercentage;
    ulong Reserved;
    ushort LoggingMode;
}
struct TXFS_QUERY_RM_INFORMATION
{
    uint BytesRequired;
    ulong TailLsn;
    ulong CurrentLsn;
    ulong ArchiveTailLsn;
    ulong LogContainerSize;
    long HighestVirtualClock;
    uint LogContainerCount;
    uint LogContainerCountMax;
    uint LogContainerCountMin;
    uint LogGrowthIncrement;
    uint LogAutoShrinkPercentage;
    TXFS_RMF_LAGS Flags;
    ushort LoggingMode;
    ushort Reserved;
    uint RmState;
    ulong LogCapacity;
    ulong LogFree;
    ulong TopsSize;
    ulong TopsUsed;
    ulong TransactionCount;
    ulong OnePCCount;
    ulong TwoPCCount;
    ulong NumberLogFileFull;
    ulong OldestTransactionAge;
    GUID RMName;
    uint TmLogPathOffset;
}
struct TXFS_ROLLFORWARD_REDO_INFORMATION
{
    long LastVirtualClock;
    ulong LastRedoLsn;
    ulong HighestRecoveryLsn;
    uint Flags;
}
struct TXFS_START_RM_INFORMATION
{
    uint Flags;
    ulong LogContainerSize;
    uint LogContainerCountMin;
    uint LogContainerCountMax;
    uint LogGrowthIncrement;
    uint LogAutoShrinkPercentage;
    uint TmLogPathOffset;
    ushort TmLogPathLength;
    ushort LoggingMode;
    ushort LogPathLength;
    ushort Reserved;
    wchar[1] LogPath;
}
struct TXFS_GET_METADATA_INFO_OUT
{
    struct TxfFileId
    {
        long LowPart;
        long HighPart;
    }
    GUID LockingTransaction;
    ulong LastLsn;
    uint TransactionState;
}
struct TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY
{
    ulong Offset;
    uint NameFlags;
    long FileId;
    uint Reserved1;
    uint Reserved2;
    long Reserved3;
    wchar[1] FileName;
}
struct TXFS_LIST_TRANSACTION_LOCKED_FILES
{
    GUID KtmTransaction;
    ulong NumberOfFiles;
    ulong BufferSizeRequired;
    ulong Offset;
}
struct TXFS_LIST_TRANSACTIONS_ENTRY
{
    GUID TransactionId;
    uint TransactionState;
    uint Reserved1;
    uint Reserved2;
    long Reserved3;
}
struct TXFS_LIST_TRANSACTIONS
{
    ulong NumberOfTransactions;
    ulong BufferSizeRequired;
}
struct TXFS_READ_BACKUP_INFORMATION_OUT
{
    union
    {
        uint BufferLength;
        ubyte[1] Buffer;
    }
}
struct TXFS_WRITE_BACKUP_INFORMATION
{
    ubyte[1] Buffer;
}
struct TXFS_GET_TRANSACTED_VERSION
{
    uint ThisBaseVersion;
    uint LatestVersion;
    ushort ThisMiniVersion;
    ushort FirstMiniVersion;
    ushort LatestMiniVersion;
}
struct TXFS_SAVEPOINT_INFORMATION
{
    HANDLE KtmTransaction;
    uint ActionCode;
    uint SavepointId;
}
struct TXFS_CREATE_MINIVERSION_INFO
{
    ushort StructureVersion;
    ushort StructureLength;
    uint BaseVersion;
    ushort MiniVersion;
}
struct TXFS_TRANSACTION_ACTIVE_INFO
{
    BOOLEAN TransactionsActiveAtSnapshot;
}
struct BOOT_AREA_INFO
{
    uint BootSectorCount;
    struct
    {
        long Offset;
    }
}
struct RETRIEVAL_POINTER_BASE
{
    long FileAreaOffset;
}
struct FILE_FS_PERSISTENT_VOLUME_INFORMATION
{
    uint VolumeFlags;
    uint FlagMask;
    uint Version;
    uint Reserved;
}
struct FILE_SYSTEM_RECOGNITION_INFORMATION
{
    CHAR[9] FileSystem;
}
struct REQUEST_OPLOCK_INPUT_BUFFER
{
    ushort StructureVersion;
    ushort StructureLength;
    uint RequestedOplockLevel;
    uint Flags;
}
struct REQUEST_OPLOCK_OUTPUT_BUFFER
{
    ushort StructureVersion;
    ushort StructureLength;
    uint OriginalOplockLevel;
    uint NewOplockLevel;
    uint Flags;
    uint AccessMode;
    ushort ShareMode;
}
struct STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST
{
    uint RequestLevel;
    uint RequestFlags;
}
struct STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY
{
    uint EntryLength;
    uint DependencyTypeFlags;
    uint ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
}
struct STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY
{
    uint EntryLength;
    uint DependencyTypeFlags;
    uint ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
    uint AncestorLevel;
    uint HostVolumeNameOffset;
    uint HostVolumeNameSize;
    uint DependentVolumeNameOffset;
    uint DependentVolumeNameSize;
    uint RelativePathOffset;
    uint RelativePathSize;
    uint DependentDeviceNameOffset;
    uint DependentDeviceNameSize;
}
struct STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE
{
    uint ResponseLevel;
    uint NumberEntries;
    union
    {
        STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY[1] Lev1Depends;
        STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY[1] Lev2Depends;
    }
}
struct SD_CHANGE_MACHINE_SID_INPUT
{
    ushort CurrentMachineSIDOffset;
    ushort CurrentMachineSIDLength;
    ushort NewMachineSIDOffset;
    ushort NewMachineSIDLength;
}
struct SD_CHANGE_MACHINE_SID_OUTPUT
{
    ulong NumSDChangedSuccess;
    ulong NumSDChangedFail;
    ulong NumSDUnused;
    ulong NumSDTotal;
    ulong NumMftSDChangedSuccess;
    ulong NumMftSDChangedFail;
    ulong NumMftSDTotal;
}
struct SD_QUERY_STATS_INPUT
{
    uint Reserved;
}
struct SD_QUERY_STATS_OUTPUT
{
    ulong SdsStreamSize;
    ulong SdsAllocationSize;
    ulong SiiStreamSize;
    ulong SiiAllocationSize;
    ulong SdhStreamSize;
    ulong SdhAllocationSize;
    ulong NumSDTotal;
    ulong NumSDUnused;
}
struct SD_ENUM_SDS_INPUT
{
    ulong StartingOffset;
    ulong MaxSDEntriesToReturn;
}
struct SD_ENUM_SDS_ENTRY
{
    uint Hash;
    uint SecurityId;
    ulong Offset;
    uint Length;
    ubyte[1] Descriptor;
}
struct SD_ENUM_SDS_OUTPUT
{
    ulong NextOffset;
    ulong NumSDEntriesReturned;
    ulong NumSDBytesReturned;
    SD_ENUM_SDS_ENTRY[1] SDEntry;
}
struct SD_GLOBAL_CHANGE_INPUT
{
    uint Flags;
    uint ChangeType;
    union
    {
        SD_CHANGE_MACHINE_SID_INPUT SdChange;
        SD_QUERY_STATS_INPUT SdQueryStats;
        SD_ENUM_SDS_INPUT SdEnumSds;
    }
}
struct SD_GLOBAL_CHANGE_OUTPUT
{
    uint Flags;
    uint ChangeType;
    union
    {
        SD_CHANGE_MACHINE_SID_OUTPUT SdChange;
        SD_QUERY_STATS_OUTPUT SdQueryStats;
        SD_ENUM_SDS_OUTPUT SdEnumSds;
    }
}
struct LOOKUP_STREAM_FROM_CLUSTER_INPUT
{
    uint Flags;
    uint NumberOfClusters;
    long[1] Cluster;
}
struct LOOKUP_STREAM_FROM_CLUSTER_OUTPUT
{
    uint Offset;
    uint NumberOfMatches;
    uint BufferSizeRequired;
}
struct LOOKUP_STREAM_FROM_CLUSTER_ENTRY
{
    uint OffsetToNext;
    uint Flags;
    long Reserved;
    long Cluster;
    wchar[1] FileName;
}
struct FILE_TYPE_NOTIFICATION_INPUT
{
    uint Flags;
    uint NumFileTypeIDs;
    GUID[1] FileTypeID;
}
struct CSV_MGMT_LOCK
{
    uint Flags;
}
struct CSV_NAMESPACE_INFO
{
    uint Version;
    uint DeviceNumber;
    long StartingOffset;
    uint SectorSize;
}
alias CSV_CONTROL_OP = int;
enum : int
{
    CsvControlStartRedirectFile                  = 0x00000002,
    CsvControlStopRedirectFile                   = 0x00000003,
    CsvControlQueryRedirectState                 = 0x00000004,
    CsvControlQueryFileRevision                  = 0x00000006,
    CsvControlQueryMdsPath                       = 0x00000008,
    CsvControlQueryFileRevisionFileId128         = 0x00000009,
    CsvControlQueryVolumeRedirectState           = 0x0000000a,
    CsvControlEnableUSNRangeModificationTracking = 0x0000000d,
    CsvControlMarkHandleLocalVolumeMount         = 0x0000000e,
    CsvControlUnmarkHandleLocalVolumeMount       = 0x0000000f,
    CsvControlGetCsvFsMdsPathV2                  = 0x00000012,
    CsvControlDisableCaching                     = 0x00000013,
    CsvControlEnableCaching                      = 0x00000014,
    CsvControlStartForceDFO                      = 0x00000015,
    CsvControlStopForceDFO                       = 0x00000016,
    CsvControlQueryMdsPathNoPause                = 0x00000017,
    CsvControlSetVolumeId                        = 0x00000018,
    CsvControlQueryVolumeId                      = 0x00000019,
}

struct CSV_CONTROL_PARAM
{
    CSV_CONTROL_OP Operation;
    long Unused;
}
struct CSV_QUERY_REDIRECT_STATE
{
    uint MdsNodeId;
    uint DsNodeId;
    BOOLEAN FileRedirected;
}
struct CSV_QUERY_FILE_REVISION
{
    long FileId;
    long[3] FileRevision;
}
struct CSV_QUERY_FILE_REVISION_FILE_ID_128
{
    FILE_ID_128 FileId;
    long[3] FileRevision;
}
struct CSV_QUERY_MDS_PATH
{
    uint MdsNodeId;
    uint DsNodeId;
    uint PathLength;
    wchar[1] Path;
}
alias CSVFS_DISK_CONNECTIVITY = int;
enum : int
{
    CsvFsDiskConnectivityNone          = 0x00000000,
    CsvFsDiskConnectivityMdsNodeOnly   = 0x00000001,
    CsvFsDiskConnectivitySubsetOfNodes = 0x00000002,
    CsvFsDiskConnectivityAllNodes      = 0x00000003,
}

struct CSV_QUERY_VOLUME_REDIRECT_STATE
{
    uint MdsNodeId;
    uint DsNodeId;
    BOOLEAN IsDiskConnected;
    BOOLEAN ClusterEnableDirectIo;
    CSVFS_DISK_CONNECTIVITY DiskConnectivity;
}
struct CSV_QUERY_MDS_PATH_V2
{
    long Version;
    uint RequiredSize;
    uint MdsNodeId;
    uint DsNodeId;
    uint Flags;
    CSVFS_DISK_CONNECTIVITY DiskConnectivity;
    GUID VolumeId;
    uint IpAddressOffset;
    uint IpAddressLength;
    uint PathOffset;
    uint PathLength;
}
struct CSV_SET_VOLUME_ID
{
    GUID VolumeId;
}
struct CSV_QUERY_VOLUME_ID
{
    GUID VolumeId;
}
alias LMR_QUERY_INFO_CLASS = int;
enum : int
{
    LMRQuerySessionInfo = 0x00000001,
}

struct LMR_QUERY_INFO_PARAM
{
    LMR_QUERY_INFO_CLASS Operation;
}
struct LMR_QUERY_SESSION_INFO
{
    ulong SessionId;
}
struct CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT
{
    ulong VetoedFromAltitudeIntegral;
    ulong VetoedFromAltitudeDecimal;
    wchar[256] Reason;
}
alias STORAGE_RESERVE_ID = int;
enum : int
{
    StorageReserveIdNone          = 0x00000000,
    StorageReserveIdHard          = 0x00000001,
    StorageReserveIdSoft          = 0x00000002,
    StorageReserveIdUpdateScratch = 0x00000003,
    StorageReserveIdMax           = 0x00000004,
}

struct CSV_IS_OWNED_BY_CSVFS
{
    BOOLEAN OwnedByCSVFS;
}
struct FILE_LEVEL_TRIM_RANGE
{
    ulong Offset;
    ulong Length;
}
struct FILE_LEVEL_TRIM
{
    uint Key;
    uint NumRanges;
    FILE_LEVEL_TRIM_RANGE[1] Ranges;
}
struct FILE_LEVEL_TRIM_OUTPUT
{
    uint NumRangesProcessed;
}
alias QUERY_FILE_LAYOUT_FILTER_TYPE = int;
enum : int
{
    QUERY_FILE_LAYOUT_FILTER_TYPE_NONE               = 0x00000000,
    QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS           = 0x00000001,
    QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID             = 0x00000002,
    QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID = 0x00000003,
    QUERY_FILE_LAYOUT_NUM_FILTER_TYPES               = 0x00000004,
}

struct CLUSTER_RANGE
{
    long StartingCluster;
    long ClusterCount;
}
struct FILE_REFERENCE_RANGE
{
    ulong StartingFileReferenceNumber;
    ulong EndingFileReferenceNumber;
}
struct QUERY_FILE_LAYOUT_INPUT
{
    union
    {
        uint FilterEntryCount;
        uint NumberOfPairs;
    }
    uint Flags;
    QUERY_FILE_LAYOUT_FILTER_TYPE FilterType;
    uint Reserved;
    union Filter
    {
        CLUSTER_RANGE[1] ClusterRanges;
        FILE_REFERENCE_RANGE[1] FileReferenceRanges;
        STORAGE_RESERVE_ID[1] StorageReserveIds;
    }
}
struct QUERY_FILE_LAYOUT_OUTPUT
{
    uint FileEntryCount;
    uint FirstFileOffset;
    uint Flags;
    uint Reserved;
}
struct FILE_LAYOUT_ENTRY
{
    uint Version;
    uint NextFileOffset;
    uint Flags;
    uint FileAttributes;
    ulong FileReferenceNumber;
    uint FirstNameOffset;
    uint FirstStreamOffset;
    uint ExtraInfoOffset;
    uint ExtraInfoLength;
}
struct FILE_LAYOUT_NAME_ENTRY
{
    uint NextNameOffset;
    uint Flags;
    ulong ParentFileReferenceNumber;
    uint FileNameLength;
    uint Reserved;
    wchar[1] FileName;
}
struct FILE_LAYOUT_INFO_ENTRY
{
    struct BasicInformation
    {
        long CreationTime;
        long LastAccessTime;
        long LastWriteTime;
        long ChangeTime;
        uint FileAttributes;
    }
    uint OwnerId;
    uint SecurityId;
    long Usn;
    STORAGE_RESERVE_ID StorageReserveId;
}
struct STREAM_LAYOUT_ENTRY
{
    uint Version;
    uint NextStreamOffset;
    uint Flags;
    uint ExtentInformationOffset;
    long AllocationSize;
    long EndOfFile;
    uint StreamInformationOffset;
    uint AttributeTypeCode;
    uint AttributeFlags;
    uint StreamIdentifierLength;
    wchar[1] StreamIdentifier;
}
struct STREAM_EXTENT_ENTRY
{
    uint Flags;
    union ExtentInformation
    {
        RETRIEVAL_POINTERS_BUFFER RetrievalPointers;
    }
}
struct FSCTL_GET_INTEGRITY_INFORMATION_BUFFER
{
    ushort ChecksumAlgorithm;
    ushort Reserved;
    uint Flags;
    uint ChecksumChunkSizeInBytes;
    uint ClusterSizeInBytes;
}
struct FSCTL_SET_INTEGRITY_INFORMATION_BUFFER
{
    ushort ChecksumAlgorithm;
    ushort Reserved;
    uint Flags;
}
struct FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX
{
    ubyte EnableIntegrity;
    ubyte KeepIntegrityStateUnchanged;
    ushort Reserved;
    uint Flags;
    ubyte Version;
    ubyte[7] Reserved2;
}
struct FSCTL_OFFLOAD_READ_INPUT
{
    uint Size;
    uint Flags;
    uint TokenTimeToLive;
    uint Reserved;
    ulong FileOffset;
    ulong CopyLength;
}
struct FSCTL_OFFLOAD_READ_OUTPUT
{
    uint Size;
    uint Flags;
    ulong TransferLength;
    ubyte[512] Token;
}
struct FSCTL_OFFLOAD_WRITE_INPUT
{
    uint Size;
    uint Flags;
    ulong FileOffset;
    ulong CopyLength;
    ulong TransferOffset;
    ubyte[512] Token;
}
struct FSCTL_OFFLOAD_WRITE_OUTPUT
{
    uint Size;
    uint Flags;
    ulong LengthWritten;
}
struct SET_PURGE_FAILURE_MODE_INPUT
{
    uint Flags;
}
struct REPAIR_COPIES_INPUT
{
    uint Size;
    uint Flags;
    long FileOffset;
    uint Length;
    uint SourceCopy;
    uint NumberOfRepairCopies;
    uint[1] RepairCopies;
}
struct REPAIR_COPIES_OUTPUT
{
    uint Size;
    uint Status;
    long ResumeFileOffset;
}
struct FILE_REGION_INFO
{
    long FileOffset;
    long Length;
    uint Usage;
    uint Reserved;
}
struct FILE_REGION_OUTPUT
{
    uint Flags;
    uint TotalRegionEntryCount;
    uint RegionEntryCount;
    uint Reserved;
    FILE_REGION_INFO[1] Region;
}
struct FILE_REGION_INPUT
{
    long FileOffset;
    long Length;
    uint DesiredUsage;
}
struct WRITE_USN_REASON_INPUT
{
    uint Flags;
    uint UsnReasonToWrite;
}
alias FILE_STORAGE_TIER_MEDIA_TYPE = int;
enum : int
{
    FileStorageTierMediaTypeUnspecified = 0x00000000,
    FileStorageTierMediaTypeDisk        = 0x00000001,
    FileStorageTierMediaTypeSsd         = 0x00000002,
    FileStorageTierMediaTypeScm         = 0x00000004,
    FileStorageTierMediaTypeMax         = 0x00000005,
}

alias FILE_STORAGE_TIER_CLASS = int;
enum : int
{
    FileStorageTierClassUnspecified = 0x00000000,
    FileStorageTierClassCapacity    = 0x00000001,
    FileStorageTierClassPerformance = 0x00000002,
    FileStorageTierClassMax         = 0x00000003,
}

struct FILE_STORAGE_TIER
{
    GUID Id;
    wchar[256] Name;
    wchar[256] Description;
    ulong Flags;
    ulong ProvisionedCapacity;
    FILE_STORAGE_TIER_MEDIA_TYPE MediaType;
    FILE_STORAGE_TIER_CLASS Class;
}
struct FSCTL_QUERY_STORAGE_CLASSES_OUTPUT
{
    uint Version;
    uint Size;
    FILE_STORAGE_TIER_FLAGS Flags;
    uint TotalNumberOfTiers;
    uint NumberOfTiersReturned;
    FILE_STORAGE_TIER[1] Tiers;
}
struct STREAM_INFORMATION_ENTRY
{
    uint Version;
    uint Flags;
    union _StreamInformation
    {
        struct _DesiredStorageClass
        {
            FILE_STORAGE_TIER_CLASS Class;
            uint Flags;
        }
        struct _DataStream
        {
            ushort Length;
            ushort Flags;
            uint Reserved;
            ulong Vdl;
        }
        struct _Reparse
        {
            ushort Length;
            ushort Flags;
            uint ReparseDataSize;
            uint ReparseDataOffset;
        }
        struct _Ea
        {
            ushort Length;
            ushort Flags;
            uint EaSize;
            uint EaInformationOffset;
        }
    }
}
struct FSCTL_QUERY_REGION_INFO_INPUT
{
    uint Version;
    uint Size;
    uint Flags;
    uint NumberOfTierIds;
    GUID[1] TierIds;
}
struct FILE_STORAGE_TIER_REGION
{
    GUID TierId;
    ulong Offset;
    ulong Length;
}
struct FSCTL_QUERY_REGION_INFO_OUTPUT
{
    uint Version;
    uint Size;
    uint Flags;
    uint Reserved;
    ulong Alignment;
    uint TotalNumberOfRegions;
    uint NumberOfRegionsReturned;
    FILE_STORAGE_TIER_REGION[1] Regions;
}
struct FILE_DESIRED_STORAGE_CLASS_INFORMATION
{
    FILE_STORAGE_TIER_CLASS Class;
    uint Flags;
}
struct DUPLICATE_EXTENTS_DATA
{
    HANDLE FileHandle;
    long SourceFileOffset;
    long TargetFileOffset;
    long ByteCount;
}
struct DUPLICATE_EXTENTS_DATA_EX
{
    ulong Size;
    HANDLE FileHandle;
    long SourceFileOffset;
    long TargetFileOffset;
    long ByteCount;
    uint Flags;
}
alias DUPLICATE_EXTENTS_STATE = int;
enum : int
{
    FileSnapStateInactive = 0x00000000,
    FileSnapStateSource   = 0x00000001,
    FileSnapStateTarget   = 0x00000002,
}

struct ASYNC_DUPLICATE_EXTENTS_STATUS
{
    uint Version;
    DUPLICATE_EXTENTS_STATE State;
    ulong SourceFileOffset;
    ulong TargetFileOffset;
    ulong ByteCount;
    ulong BytesDuplicated;
}
alias REFS_SMR_VOLUME_GC_STATE = int;
enum : int
{
    SmrGcStateInactive        = 0x00000000,
    SmrGcStatePaused          = 0x00000001,
    SmrGcStateActive          = 0x00000002,
    SmrGcStateActiveFullSpeed = 0x00000003,
}

struct REFS_SMR_VOLUME_INFO_OUTPUT
{
    uint Version;
    uint Flags;
    long SizeOfRandomlyWritableTier;
    long FreeSpaceInRandomlyWritableTier;
    long SizeofSMRTier;
    long FreeSpaceInSMRTier;
    long UsableFreeSpaceInSMRTier;
    REFS_SMR_VOLUME_GC_STATE VolumeGcState;
    uint VolumeGcLastStatus;
    uint CurrentGcBandFillPercentage;
    ulong[6] Unused;
}
alias REFS_SMR_VOLUME_GC_ACTION = int;
enum : int
{
    SmrGcActionStart          = 0x00000001,
    SmrGcActionStartFullSpeed = 0x00000002,
    SmrGcActionPause          = 0x00000003,
    SmrGcActionStop           = 0x00000004,
}

alias REFS_SMR_VOLUME_GC_METHOD = int;
enum : int
{
    SmrGcMethodCompaction  = 0x00000001,
    SmrGcMethodCompression = 0x00000002,
    SmrGcMethodRotation    = 0x00000003,
}

struct REFS_SMR_VOLUME_GC_PARAMETERS
{
    uint Version;
    uint Flags;
    REFS_SMR_VOLUME_GC_ACTION Action;
    REFS_SMR_VOLUME_GC_METHOD Method;
    uint IoGranularity;
    uint CompressionFormat;
    ulong[8] Unused;
}
struct STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER
{
    uint OptimalWriteSize;
    uint StreamGranularitySize;
    uint StreamIdMin;
    uint StreamIdMax;
}
struct STREAMS_ASSOCIATE_ID_INPUT_BUFFER
{
    uint Flags;
    uint StreamId;
}
struct STREAMS_QUERY_ID_OUTPUT_BUFFER
{
    uint StreamId;
}
struct QUERY_BAD_RANGES_INPUT_RANGE
{
    ulong StartOffset;
    ulong LengthInBytes;
}
struct QUERY_BAD_RANGES_INPUT
{
    uint Flags;
    uint NumRanges;
    QUERY_BAD_RANGES_INPUT_RANGE[1] Ranges;
}
struct QUERY_BAD_RANGES_OUTPUT_RANGE
{
    uint Flags;
    uint Reserved;
    ulong StartOffset;
    ulong LengthInBytes;
}
struct QUERY_BAD_RANGES_OUTPUT
{
    uint Flags;
    uint NumBadRanges;
    ulong NextOffsetToLookUp;
    QUERY_BAD_RANGES_OUTPUT_RANGE[1] BadRanges;
}
struct SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT
{
    uint Flags;
    uint AlignmentShift;
    ulong FileOffsetToAlign;
    uint FallbackAlignmentShift;
}
alias VIRTUAL_STORAGE_BEHAVIOR_CODE = int;
enum : int
{
    VirtualStorageBehaviorUndefined           = 0x00000000,
    VirtualStorageBehaviorCacheWriteThrough   = 0x00000001,
    VirtualStorageBehaviorCacheWriteBack      = 0x00000002,
    VirtualStorageBehaviorStopIoProcessing    = 0x00000003,
    VirtualStorageBehaviorRestartIoProcessing = 0x00000004,
}

struct VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT
{
    uint Size;
    VIRTUAL_STORAGE_BEHAVIOR_CODE BehaviorCode;
}
struct ENCRYPTION_KEY_CTRL_INPUT
{
    uint HeaderSize;
    uint StructureSize;
    ushort KeyOffset;
    ushort KeySize;
    uint DplLock;
    ulong DplUserId;
    ulong DplCredentialId;
}
struct WOF_EXTERNAL_INFO
{
    uint Version;
    uint Provider;
}
struct WOF_EXTERNAL_FILE_ID
{
    FILE_ID_128 FileId;
}
struct WOF_VERSION_INFO
{
    uint WofVersion;
}
struct WIM_PROVIDER_EXTERNAL_INFO
{
    uint Version;
    uint Flags;
    long DataSourceId;
    ubyte[20] ResourceHash;
}
struct WIM_PROVIDER_ADD_OVERLAY_INPUT
{
    uint WimType;
    uint WimIndex;
    uint WimFileNameOffset;
    uint WimFileNameLength;
}
struct WIM_PROVIDER_UPDATE_OVERLAY_INPUT
{
    long DataSourceId;
    uint WimFileNameOffset;
    uint WimFileNameLength;
}
struct WIM_PROVIDER_REMOVE_OVERLAY_INPUT
{
    long DataSourceId;
}
struct WIM_PROVIDER_SUSPEND_OVERLAY_INPUT
{
    long DataSourceId;
}
struct WIM_PROVIDER_OVERLAY_ENTRY
{
    uint NextEntryOffset;
    long DataSourceId;
    GUID WimGuid;
    uint WimFileNameOffset;
    uint WimType;
    uint WimIndex;
    uint Flags;
}
struct FILE_PROVIDER_EXTERNAL_INFO_V0
{
    uint Version;
    uint Algorithm;
}
struct FILE_PROVIDER_EXTERNAL_INFO_V1
{
    uint Version;
    uint Algorithm;
    uint Flags;
}
struct CONTAINER_VOLUME_STATE
{
    uint Flags;
}
struct CONTAINER_ROOT_INFO_INPUT
{
    uint Flags;
}
struct CONTAINER_ROOT_INFO_OUTPUT
{
    ushort ContainerRootIdLength;
    ubyte[1] ContainerRootId;
}
struct VIRTUALIZATION_INSTANCE_INFO_INPUT
{
    uint NumberOfWorkerThreads;
    uint Flags;
}
struct VIRTUALIZATION_INSTANCE_INFO_INPUT_EX
{
    ushort HeaderSize;
    uint Flags;
    uint NotificationInfoSize;
    ushort NotificationInfoOffset;
    ushort ProviderMajorVersion;
}
struct VIRTUALIZATION_INSTANCE_INFO_OUTPUT
{
    GUID VirtualizationInstanceID;
}
struct GET_FILTER_FILE_IDENTIFIER_INPUT
{
    ushort AltitudeLength;
    wchar[1] Altitude;
}
struct GET_FILTER_FILE_IDENTIFIER_OUTPUT
{
    ushort FilterFileIdentifierLength;
    ubyte[1] FilterFileIdentifier;
}
alias FS_BPIO_OPERATIONS = int;
enum : int
{
    FS_BPIO_OP_ENABLE              = 0x00000001,
    FS_BPIO_OP_DISABLE             = 0x00000002,
    FS_BPIO_OP_QUERY               = 0x00000003,
    FS_BPIO_OP_VOLUME_STACK_PAUSE  = 0x00000004,
    FS_BPIO_OP_VOLUME_STACK_RESUME = 0x00000005,
    FS_BPIO_OP_STREAM_PAUSE        = 0x00000006,
    FS_BPIO_OP_STREAM_RESUME       = 0x00000007,
    FS_BPIO_OP_GET_INFO            = 0x00000008,
    FS_BPIO_OP_MAX_OPERATION       = 0x00000009,
}

alias FS_BPIO_INFLAGS = int;
enum : int
{
    FSBPIO_INFL_None                     = 0x00000000,
    FSBPIO_INFL_SKIP_STORAGE_STACK_QUERY = 0x00000001,
}

struct FS_BPIO_INPUT
{
    FS_BPIO_OPERATIONS Operation;
    FS_BPIO_INFLAGS InFlags;
    ulong Reserved1;
    ulong Reserved2;
}
alias FS_BPIO_OUTFLAGS = int;
enum : int
{
    FSBPIO_OUTFL_None                       = 0x00000000,
    FSBPIO_OUTFL_VOLUME_STACK_BYPASS_PAUSED = 0x00000001,
    FSBPIO_OUTFL_STREAM_BYPASS_PAUSED       = 0x00000002,
    FSBPIO_OUTFL_FILTER_ATTACH_BLOCKED      = 0x00000004,
    FSBPIO_OUTFL_COMPATIBLE_STORAGE_DRIVER  = 0x00000008,
}

struct FS_BPIO_RESULTS
{
    uint OpStatus;
    ushort FailingDriverNameLen;
    wchar[32] FailingDriverName;
    ushort FailureReasonLen;
    wchar[128] FailureReason;
}
struct FS_BPIO_INFO
{
    uint ActiveBypassIoCount;
    ushort StorageDriverNameLen;
    wchar[32] StorageDriverName;
}
struct FS_BPIO_OUTPUT
{
    FS_BPIO_OPERATIONS Operation;
    FS_BPIO_OUTFLAGS OutFlags;
    ulong Reserved1;
    ulong Reserved2;
    union
    {
        FS_BPIO_RESULTS Enable;
        FS_BPIO_RESULTS Query;
        FS_BPIO_RESULTS VolumeStackResume;
        FS_BPIO_RESULTS StreamResume;
        FS_BPIO_INFO GetInfo;
    }
}
struct SMB_SHARE_FLUSH_AND_PURGE_INPUT
{
    ushort Version;
}
struct SMB_SHARE_FLUSH_AND_PURGE_OUTPUT
{
    uint cEntriesPurged;
}
struct DISK_EXTENT
{
    uint DiskNumber;
    long StartingOffset;
    long ExtentLength;
}
struct VOLUME_DISK_EXTENTS
{
    uint NumberOfDiskExtents;
    DISK_EXTENT[1] Extents;
}
struct VOLUME_GET_GPT_ATTRIBUTES_INFORMATION
{
    ulong GptAttributes;
}
alias PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = void function(IO_IRP_EXT_TRACK_OFFSET_HEADER*, IO_IRP_EXT_TRACK_OFFSET_HEADER*, long);
struct IO_IRP_EXT_TRACK_OFFSET_HEADER
{
    ushort Validation;
    ushort Flags;
    PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK TrackedOffsetCallback;
}
