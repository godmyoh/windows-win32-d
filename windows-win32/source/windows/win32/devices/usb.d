module windows.win32.devices.usb;

import windows.win32.guid : GUID;
import windows.win32.foundation : BOOL, BOOLEAN, HANDLE, LARGE_INTEGER;
import windows.win32.system.io : OVERLAPPED;

version (Windows):
extern (Windows):

BOOL WinUsb_Initialize(HANDLE, void**);
BOOL WinUsb_Free(void*);
BOOL WinUsb_GetAssociatedInterface(void*, ubyte, void**);
BOOL WinUsb_GetDescriptor(void*, ubyte, ubyte, ushort, ubyte*, uint, uint*);
BOOL WinUsb_QueryInterfaceSettings(void*, ubyte, USB_INTERFACE_DESCRIPTOR*);
BOOL WinUsb_QueryDeviceInformation(void*, uint, uint*, void*);
BOOL WinUsb_SetCurrentAlternateSetting(void*, ubyte);
BOOL WinUsb_GetCurrentAlternateSetting(void*, ubyte*);
BOOL WinUsb_QueryPipe(void*, ubyte, ubyte, WINUSB_PIPE_INFORMATION*);
BOOL WinUsb_QueryPipeEx(void*, ubyte, ubyte, WINUSB_PIPE_INFORMATION_EX*);
BOOL WinUsb_SetPipePolicy(void*, ubyte, uint, uint, void*);
BOOL WinUsb_GetPipePolicy(void*, ubyte, uint, uint*, void*);
BOOL WinUsb_ReadPipe(void*, ubyte, ubyte*, uint, uint*, OVERLAPPED*);
BOOL WinUsb_WritePipe(void*, ubyte, ubyte*, uint, uint*, OVERLAPPED*);
BOOL WinUsb_ControlTransfer(void*, WINUSB_SETUP_PACKET, ubyte*, uint, uint*, OVERLAPPED*);
BOOL WinUsb_ResetPipe(void*, ubyte);
BOOL WinUsb_AbortPipe(void*, ubyte);
BOOL WinUsb_FlushPipe(void*, ubyte);
BOOL WinUsb_SetPowerPolicy(void*, uint, uint, void*);
BOOL WinUsb_GetPowerPolicy(void*, uint, uint*, void*);
BOOL WinUsb_GetOverlappedResult(void*, OVERLAPPED*, uint*, BOOL);
USB_INTERFACE_DESCRIPTOR* WinUsb_ParseConfigurationDescriptor(USB_CONFIGURATION_DESCRIPTOR*, void*, int, int, int, int, int);
USB_COMMON_DESCRIPTOR* WinUsb_ParseDescriptors(void*, uint, void*, int);
BOOL WinUsb_GetCurrentFrameNumber(void*, uint*, LARGE_INTEGER*);
BOOL WinUsb_GetAdjustedFrameNumber(uint*, LARGE_INTEGER);
BOOL WinUsb_RegisterIsochBuffer(void*, ubyte, ubyte*, uint, void**);
BOOL WinUsb_UnregisterIsochBuffer(void*);
BOOL WinUsb_WriteIsochPipe(void*, uint, uint, uint*, OVERLAPPED*);
BOOL WinUsb_ReadIsochPipe(void*, uint, uint, uint*, uint, USBD_ISO_PACKET_DESCRIPTOR*, OVERLAPPED*);
BOOL WinUsb_WriteIsochPipeAsap(void*, uint, uint, BOOL, OVERLAPPED*);
BOOL WinUsb_ReadIsochPipeAsap(void*, uint, uint, BOOL, uint, USBD_ISO_PACKET_DESCRIPTOR*, OVERLAPPED*);
BOOL WinUsb_StartTrackingForTimeSync(void*, USB_START_TRACKING_FOR_TIME_SYNC_INFORMATION*);
BOOL WinUsb_GetCurrentFrameNumberAndQpc(void*, USB_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC_INFORMATION*);
BOOL WinUsb_StopTrackingForTimeSync(void*, USB_STOP_TRACKING_FOR_TIME_SYNC_INFORMATION*);
enum SHORT_PACKET_TERMINATE = 0x00000001;
enum AUTO_CLEAR_STALL = 0x00000002;
enum PIPE_TRANSFER_TIMEOUT = 0x00000003;
enum IGNORE_SHORT_PACKETS = 0x00000004;
enum ALLOW_PARTIAL_READS = 0x00000005;
enum AUTO_FLUSH = 0x00000006;
enum RAW_IO = 0x00000007;
enum MAXIMUM_TRANSFER_SIZE = 0x00000008;
enum RESET_PIPE_ON_RESUME = 0x00000009;
enum AUTO_SUSPEND = 0x00000081;
enum SUSPEND_DELAY = 0x00000083;
enum DEVICE_SPEED = 0x00000001;
enum LowSpeed = 0x00000001;
enum FullSpeed = 0x00000002;
enum HighSpeed = 0x00000003;
enum IOCTL_GENERICUSBFN_TRANSFER_IN = 0x0022c00d;
enum IOCTL_GENERICUSBFN_TRANSFER_IN_APPEND_ZERO_PKT = 0x0022c011;
enum IOCTL_GENERICUSBFN_TRANSFER_OUT = 0x0022c016;
enum IOCTL_GENERICUSBFN_CONTROL_STATUS_HANDSHAKE_IN = 0x0022c018;
enum IOCTL_GENERICUSBFN_CONTROL_STATUS_HANDSHAKE_OUT = 0x0022c01c;
enum IOCTL_GENERICUSBFN_GET_CLASS_INFO = 0x0022c022;
enum IOCTL_GENERICUSBFN_GET_PIPE_STATE = 0x0022c026;
enum IOCTL_GENERICUSBFN_SET_PIPE_STATE = 0x0022c029;
enum IOCTL_GENERICUSBFN_ACTIVATE_USB_BUS = 0x0022c02c;
enum IOCTL_GENERICUSBFN_DEACTIVATE_USB_BUS = 0x0022c030;
enum IOCTL_GENERICUSBFN_BUS_EVENT_NOTIFICATION = 0x0022c036;
enum IOCTL_GENERICUSBFN_GET_CLASS_INFO_EX = 0x0022c03a;
enum IOCTL_GENERICUSBFN_GET_INTERFACE_DESCRIPTOR_SET = 0x0022c03e;
enum IOCTL_GENERICUSBFN_REGISTER_USB_STRING = 0x0022c041;
enum USBUSER_VERSION = 0x00000004;
enum USBUSER_GET_CONTROLLER_INFO_0 = 0x00000001;
enum USBUSER_GET_CONTROLLER_DRIVER_KEY = 0x00000002;
enum USBUSER_PASS_THRU = 0x00000003;
enum USBUSER_GET_POWER_STATE_MAP = 0x00000004;
enum USBUSER_GET_BANDWIDTH_INFORMATION = 0x00000005;
enum USBUSER_GET_BUS_STATISTICS_0 = 0x00000006;
enum USBUSER_GET_ROOTHUB_SYMBOLIC_NAME = 0x00000007;
enum USBUSER_GET_USB_DRIVER_VERSION = 0x00000008;
enum USBUSER_GET_USB2_HW_VERSION = 0x00000009;
enum USBUSER_USB_REFRESH_HCT_REG = 0x0000000a;
enum USBUSER_OP_SEND_ONE_PACKET = 0x10000001;
enum USBUSER_OP_RAW_RESET_PORT = 0x20000001;
enum USBUSER_OP_OPEN_RAW_DEVICE = 0x20000002;
enum USBUSER_OP_CLOSE_RAW_DEVICE = 0x20000003;
enum USBUSER_OP_SEND_RAW_COMMAND = 0x20000004;
enum USBUSER_SET_ROOTPORT_FEATURE = 0x20000005;
enum USBUSER_CLEAR_ROOTPORT_FEATURE = 0x20000006;
enum USBUSER_GET_ROOTPORT_STATUS = 0x20000007;
enum USBUSER_INVALID_REQUEST = 0xfffffff0;
enum USBUSER_OP_MASK_DEVONLY_API = 0x10000000;
enum USBUSER_OP_MASK_HCTEST_API = 0x20000000;
enum USB_PACKETFLAG_LOW_SPEED = 0x00000001;
enum USB_PACKETFLAG_FULL_SPEED = 0x00000002;
enum USB_PACKETFLAG_HIGH_SPEED = 0x00000004;
enum USB_PACKETFLAG_ASYNC_IN = 0x00000008;
enum USB_PACKETFLAG_ASYNC_OUT = 0x00000010;
enum USB_PACKETFLAG_ISO_IN = 0x00000020;
enum USB_PACKETFLAG_ISO_OUT = 0x00000040;
enum USB_PACKETFLAG_SETUP = 0x00000080;
enum USB_PACKETFLAG_TOGGLE0 = 0x00000100;
enum USB_PACKETFLAG_TOGGLE1 = 0x00000200;
enum USB_HC_FEATURE_FLAG_PORT_POWER_SWITCHING = 0x00000001;
enum USB_HC_FEATURE_FLAG_SEL_SUSPEND = 0x00000002;
enum USB_HC_FEATURE_LEGACY_BIOS = 0x00000004;
enum USB_HC_FEATURE_TIME_SYNC_API = 0x00000008;
enum USB_SUBMIT_URB = 0x00000000;
enum USB_RESET_PORT = 0x00000001;
enum USB_GET_ROOTHUB_PDO = 0x00000003;
enum USB_GET_PORT_STATUS = 0x00000004;
enum USB_ENABLE_PORT = 0x00000005;
enum USB_GET_HUB_COUNT = 0x00000006;
enum USB_CYCLE_PORT = 0x00000007;
enum USB_GET_HUB_NAME = 0x00000008;
enum USB_IDLE_NOTIFICATION = 0x00000009;
enum USB_RECORD_FAILURE = 0x0000000a;
enum USB_GET_BUS_INFO = 0x00000108;
enum USB_GET_CONTROLLER_NAME = 0x00000109;
enum USB_GET_BUSGUID_INFO = 0x0000010a;
enum USB_GET_PARENT_HUB_INFO = 0x0000010b;
enum USB_GET_DEVICE_HANDLE = 0x0000010c;
enum USB_GET_DEVICE_HANDLE_EX = 0x0000010d;
enum USB_GET_TT_DEVICE_HANDLE = 0x0000010e;
enum USB_GET_TOPOLOGY_ADDRESS = 0x0000010f;
enum USB_IDLE_NOTIFICATION_EX = 0x00000110;
enum USB_REQ_GLOBAL_SUSPEND = 0x00000111;
enum USB_REQ_GLOBAL_RESUME = 0x00000112;
enum USB_GET_HUB_CONFIG_INFO = 0x00000113;
enum USB_FAIL_GET_STATUS = 0x00000118;
enum USB_REGISTER_COMPOSITE_DEVICE = 0x00000000;
enum USB_UNREGISTER_COMPOSITE_DEVICE = 0x00000001;
enum USB_REQUEST_REMOTE_WAKE_NOTIFICATION = 0x00000002;
enum HCD_GET_STATS_1 = 0x000000ff;
enum HCD_DIAGNOSTIC_MODE_ON = 0x00000100;
enum HCD_DIAGNOSTIC_MODE_OFF = 0x00000101;
enum HCD_GET_ROOT_HUB_NAME = 0x00000102;
enum HCD_GET_DRIVERKEY_NAME = 0x00000109;
enum HCD_GET_STATS_2 = 0x0000010a;
enum HCD_DISABLE_PORT = 0x0000010c;
enum HCD_ENABLE_PORT = 0x0000010d;
enum HCD_USER_REQUEST = 0x0000010e;
enum HCD_TRACE_READ_REQUEST = 0x00000113;
enum USB_GET_NODE_INFORMATION = 0x00000102;
enum USB_GET_NODE_CONNECTION_INFORMATION = 0x00000103;
enum USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION = 0x00000104;
enum USB_GET_NODE_CONNECTION_NAME = 0x00000105;
enum USB_DIAG_IGNORE_HUBS_ON = 0x00000106;
enum USB_DIAG_IGNORE_HUBS_OFF = 0x00000107;
enum USB_GET_NODE_CONNECTION_DRIVERKEY_NAME = 0x00000108;
enum USB_GET_HUB_CAPABILITIES = 0x0000010f;
enum USB_GET_NODE_CONNECTION_ATTRIBUTES = 0x00000110;
enum USB_HUB_CYCLE_PORT = 0x00000111;
enum USB_GET_NODE_CONNECTION_INFORMATION_EX = 0x00000112;
enum USB_RESET_HUB = 0x00000113;
enum USB_GET_HUB_CAPABILITIES_EX = 0x00000114;
enum USB_GET_HUB_INFORMATION_EX = 0x00000115;
enum USB_GET_PORT_CONNECTOR_PROPERTIES = 0x00000116;
enum USB_GET_NODE_CONNECTION_INFORMATION_EX_V2 = 0x00000117;
enum USB_GET_TRANSPORT_CHARACTERISTICS = 0x00000119;
enum USB_REGISTER_FOR_TRANSPORT_CHARACTERISTICS_CHANGE = 0x0000011a;
enum USB_NOTIFY_ON_TRANSPORT_CHARACTERISTICS_CHANGE = 0x0000011b;
enum USB_UNREGISTER_FOR_TRANSPORT_CHARACTERISTICS_CHANGE = 0x0000011c;
enum USB_START_TRACKING_FOR_TIME_SYNC = 0x0000011d;
enum USB_GET_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC = 0x0000011e;
enum USB_STOP_TRACKING_FOR_TIME_SYNC = 0x0000011f;
enum USB_GET_DEVICE_CHARACTERISTICS = 0x00000120;
enum GUID_DEVINTERFACE_USB_HUB = GUID(0xf18a0e88, 0xc30c, 0x11d0, [0x88, 0x15, 0x0, 0xa0, 0xc9, 0x6, 0xbe, 0xd8]);
enum GUID_DEVINTERFACE_USB_BILLBOARD = GUID(0x5e9adaef, 0xf879, 0x473f, [0xb8, 0x7, 0x4e, 0x5e, 0xa7, 0x7d, 0x1b, 0x1c]);
enum GUID_DEVINTERFACE_USB_DEVICE = GUID(0xa5dcbf10, 0x6530, 0x11d2, [0x90, 0x1f, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xed]);
enum GUID_DEVINTERFACE_USB_HOST_CONTROLLER = GUID(0x3abf6f2d, 0x71c4, 0x462a, [0x8a, 0x92, 0x1e, 0x68, 0x61, 0xe6, 0xaf, 0x27]);
enum GUID_USB_WMI_STD_DATA = GUID(0x4e623b20, 0xcb14, 0x11d1, [0xb3, 0x31, 0x0, 0xa0, 0xc9, 0x59, 0xbb, 0xd2]);
enum GUID_USB_WMI_STD_NOTIFICATION = GUID(0x4e623b20, 0xcb14, 0x11d1, [0xb3, 0x31, 0x0, 0xa0, 0xc9, 0x59, 0xbb, 0xd2]);
enum GUID_USB_WMI_DEVICE_PERF_INFO = GUID(0x66c1aa3c, 0x499f, 0x49a0, [0xa9, 0xa5, 0x61, 0xe2, 0x35, 0x9f, 0x64, 0x7]);
enum GUID_USB_WMI_NODE_INFO = GUID(0x9c179357, 0xdc7a, 0x4f41, [0xb6, 0x6b, 0x32, 0x3b, 0x9d, 0xdc, 0xb5, 0xb1]);
enum GUID_USB_WMI_TRACING = GUID(0x3a61881b, 0xb4e6, 0x4bf9, [0xae, 0xf, 0x3c, 0xd8, 0xf3, 0x94, 0xe5, 0x2f]);
enum GUID_USB_TRANSFER_TRACING = GUID(0x681eb8aa, 0x403d, 0x452c, [0x9f, 0x8a, 0xf0, 0x61, 0x6f, 0xac, 0x95, 0x40]);
enum GUID_USB_PERFORMANCE_TRACING = GUID(0xd5de77a6, 0x6ae9, 0x425c, [0xb1, 0xe2, 0xf5, 0x61, 0x5f, 0xd3, 0x48, 0xa9]);
enum GUID_USB_WMI_SURPRISE_REMOVAL_NOTIFICATION = GUID(0x9bbbf831, 0xa2f2, 0x43b4, [0x96, 0xd1, 0x86, 0x94, 0x4b, 0x59, 0x14, 0xb3]);
enum FILE_DEVICE_USB = 0x00000022;
enum BMREQUEST_HOST_TO_DEVICE = 0x00000000;
enum BMREQUEST_DEVICE_TO_HOST = 0x00000001;
enum BMREQUEST_STANDARD = 0x00000000;
enum BMREQUEST_CLASS = 0x00000001;
enum BMREQUEST_VENDOR = 0x00000002;
enum BMREQUEST_TO_DEVICE = 0x00000000;
enum BMREQUEST_TO_INTERFACE = 0x00000001;
enum BMREQUEST_TO_ENDPOINT = 0x00000002;
enum BMREQUEST_TO_OTHER = 0x00000003;
enum USB_REQUEST_GET_STATUS = 0x00000000;
enum USB_REQUEST_CLEAR_FEATURE = 0x00000001;
enum USB_REQUEST_SET_FEATURE = 0x00000003;
enum USB_REQUEST_SET_ADDRESS = 0x00000005;
enum USB_REQUEST_GET_DESCRIPTOR = 0x00000006;
enum USB_REQUEST_SET_DESCRIPTOR = 0x00000007;
enum USB_REQUEST_GET_CONFIGURATION = 0x00000008;
enum USB_REQUEST_SET_CONFIGURATION = 0x00000009;
enum USB_REQUEST_GET_INTERFACE = 0x0000000a;
enum USB_REQUEST_SET_INTERFACE = 0x0000000b;
enum USB_REQUEST_SYNC_FRAME = 0x0000000c;
enum USB_REQUEST_GET_FIRMWARE_STATUS = 0x0000001a;
enum USB_REQUEST_SET_FIRMWARE_STATUS = 0x0000001b;
enum USB_GET_FIRMWARE_ALLOWED_OR_DISALLOWED_STATE = 0x00000000;
enum USB_GET_FIRMWARE_HASH = 0x00000001;
enum USB_DEVICE_FIRMWARE_HASH_LENGTH = 0x00000020;
enum USB_DISALLOW_FIRMWARE_UPDATE = 0x00000000;
enum USB_ALLOW_FIRMWARE_UPDATE = 0x00000001;
enum USB_REQUEST_SET_SEL = 0x00000030;
enum USB_REQUEST_ISOCH_DELAY = 0x00000031;
enum USB_DEVICE_DESCRIPTOR_TYPE = 0x00000001;
enum USB_CONFIGURATION_DESCRIPTOR_TYPE = 0x00000002;
enum USB_STRING_DESCRIPTOR_TYPE = 0x00000003;
enum USB_INTERFACE_DESCRIPTOR_TYPE = 0x00000004;
enum USB_ENDPOINT_DESCRIPTOR_TYPE = 0x00000005;
enum USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE = 0x00000006;
enum USB_OTHER_SPEED_CONFIGURATION_DESCRIPTOR_TYPE = 0x00000007;
enum USB_INTERFACE_POWER_DESCRIPTOR_TYPE = 0x00000008;
enum USB_OTG_DESCRIPTOR_TYPE = 0x00000009;
enum USB_DEBUG_DESCRIPTOR_TYPE = 0x0000000a;
enum USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE = 0x0000000b;
enum USB_BOS_DESCRIPTOR_TYPE = 0x0000000f;
enum USB_DEVICE_CAPABILITY_DESCRIPTOR_TYPE = 0x00000010;
enum USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR_TYPE = 0x00000030;
enum USB_SUPERSPEEDPLUS_ISOCH_ENDPOINT_COMPANION_DESCRIPTOR_TYPE = 0x00000031;
enum USB_RESERVED_DESCRIPTOR_TYPE = 0x00000006;
enum USB_CONFIG_POWER_DESCRIPTOR_TYPE = 0x00000007;
enum USB_FEATURE_ENDPOINT_STALL = 0x00000000;
enum USB_FEATURE_REMOTE_WAKEUP = 0x00000001;
enum USB_FEATURE_TEST_MODE = 0x00000002;
enum USB_FEATURE_FUNCTION_SUSPEND = 0x00000000;
enum USB_FEATURE_U1_ENABLE = 0x00000030;
enum USB_FEATURE_U2_ENABLE = 0x00000031;
enum USB_FEATURE_LTM_ENABLE = 0x00000032;
enum USB_FEATURE_LDM_ENABLE = 0x00000035;
enum USB_FEATURE_BATTERY_WAKE_MASK = 0x00000028;
enum USB_FEATURE_OS_IS_PD_AWARE = 0x00000029;
enum USB_FEATURE_POLICY_MODE = 0x0000002a;
enum USB_FEATURE_CHARGING_POLICY = 0x00000036;
enum USB_CHARGING_POLICY_DEFAULT = 0x00000000;
enum USB_CHARGING_POLICY_ICCHPF = 0x00000001;
enum USB_CHARGING_POLICY_ICCLPF = 0x00000002;
enum USB_CHARGING_POLICY_NO_POWER = 0x00000003;
enum USB_STATUS_PORT_STATUS = 0x00000000;
enum USB_STATUS_PD_STATUS = 0x00000001;
enum USB_STATUS_EXT_PORT_STATUS = 0x00000002;
enum USB_GETSTATUS_SELF_POWERED = 0x00000001;
enum USB_GETSTATUS_REMOTE_WAKEUP_ENABLED = 0x00000002;
enum USB_GETSTATUS_U1_ENABLE = 0x00000004;
enum USB_GETSTATUS_U2_ENABLE = 0x00000008;
enum USB_GETSTATUS_LTM_ENABLE = 0x00000010;
enum USB_DEVICE_CLASS_RESERVED = 0x00000000;
enum USB_DEVICE_CLASS_AUDIO = 0x00000001;
enum USB_DEVICE_CLASS_COMMUNICATIONS = 0x00000002;
enum USB_DEVICE_CLASS_HUMAN_INTERFACE = 0x00000003;
enum USB_DEVICE_CLASS_MONITOR = 0x00000004;
enum USB_DEVICE_CLASS_PHYSICAL_INTERFACE = 0x00000005;
enum USB_DEVICE_CLASS_POWER = 0x00000006;
enum USB_DEVICE_CLASS_IMAGE = 0x00000006;
enum USB_DEVICE_CLASS_PRINTER = 0x00000007;
enum USB_DEVICE_CLASS_STORAGE = 0x00000008;
enum USB_DEVICE_CLASS_HUB = 0x00000009;
enum USB_DEVICE_CLASS_CDC_DATA = 0x0000000a;
enum USB_DEVICE_CLASS_SMART_CARD = 0x0000000b;
enum USB_DEVICE_CLASS_CONTENT_SECURITY = 0x0000000d;
enum USB_DEVICE_CLASS_VIDEO = 0x0000000e;
enum USB_DEVICE_CLASS_PERSONAL_HEALTHCARE = 0x0000000f;
enum USB_DEVICE_CLASS_AUDIO_VIDEO = 0x00000010;
enum USB_DEVICE_CLASS_BILLBOARD = 0x00000011;
enum USB_DEVICE_CLASS_DIAGNOSTIC_DEVICE = 0x000000dc;
enum USB_DEVICE_CLASS_WIRELESS_CONTROLLER = 0x000000e0;
enum USB_DEVICE_CLASS_MISCELLANEOUS = 0x000000ef;
enum USB_DEVICE_CLASS_APPLICATION_SPECIFIC = 0x000000fe;
enum USB_DEVICE_CLASS_VENDOR_SPECIFIC = 0x000000ff;
enum USB_DEVICE_CAPABILITY_WIRELESS_USB = 0x00000001;
enum USB_DEVICE_CAPABILITY_USB20_EXTENSION = 0x00000002;
enum USB_DEVICE_CAPABILITY_SUPERSPEED_USB = 0x00000003;
enum USB_DEVICE_CAPABILITY_CONTAINER_ID = 0x00000004;
enum USB_DEVICE_CAPABILITY_PLATFORM = 0x00000005;
enum USB_DEVICE_CAPABILITY_POWER_DELIVERY = 0x00000006;
enum USB_DEVICE_CAPABILITY_BATTERY_INFO = 0x00000007;
enum USB_DEVICE_CAPABILITY_PD_CONSUMER_PORT = 0x00000008;
enum USB_DEVICE_CAPABILITY_PD_PROVIDER_PORT = 0x00000009;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_USB = 0x0000000a;
enum USB_DEVICE_CAPABILITY_PRECISION_TIME_MEASUREMENT = 0x0000000b;
enum USB_DEVICE_CAPABILITY_BILLBOARD = 0x0000000d;
enum USB_DEVICE_CAPABILITY_FIRMWARE_STATUS = 0x00000011;
enum USB_DEVICE_CAPABILITY_USB20_EXTENSION_BMATTRIBUTES_RESERVED_MASK = 0xffff00e1;
enum USB_DEVICE_CAPABILITY_SUPERSPEED_BMATTRIBUTES_RESERVED_MASK = 0x000000fd;
enum USB_DEVICE_CAPABILITY_SUPERSPEED_BMATTRIBUTES_LTM_CAPABLE = 0x00000002;
enum USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_RESERVED_MASK = 0x0000fff0;
enum USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_LOW = 0x00000001;
enum USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_FULL = 0x00000002;
enum USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_HIGH = 0x00000004;
enum USB_DEVICE_CAPABILITY_SUPERSPEED_SPEEDS_SUPPORTED_SUPER = 0x00000008;
enum USB_DEVICE_CAPABILITY_SUPERSPEED_U1_DEVICE_EXIT_MAX_VALUE = 0x0000000a;
enum USB_DEVICE_CAPABILITY_SUPERSPEED_U2_DEVICE_EXIT_MAX_VALUE = 0x000007ff;
enum USB_DEVICE_CAPABILITY_MAX_U1_LATENCY = 0x0000000a;
enum USB_DEVICE_CAPABILITY_MAX_U2_LATENCY = 0x000007ff;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_BPS = 0x00000000;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_KBPS = 0x00000001;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_MBPS = 0x00000002;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_LSE_GBPS = 0x00000003;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_MODE_SYMMETRIC = 0x00000000;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_MODE_ASYMMETRIC = 0x00000001;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_DIR_RX = 0x00000000;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_DIR_TX = 0x00000001;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_PROTOCOL_SS = 0x00000000;
enum USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED_PROTOCOL_SSP = 0x00000001;
enum GUID_USB_MSOS20_PLATFORM_CAPABILITY_ID = GUID(0xd8dd60df, 0x4589, 0x4cc7, [0x9c, 0xd2, 0x65, 0x9d, 0x9e, 0x64, 0x8a, 0x9f]);
enum USB_CONFIG_POWERED_MASK = 0x000000c0;
enum USB_CONFIG_BUS_POWERED = 0x00000080;
enum USB_CONFIG_SELF_POWERED = 0x00000040;
enum USB_CONFIG_REMOTE_WAKEUP = 0x00000020;
enum USB_CONFIG_RESERVED = 0x0000001f;
enum USB_ENDPOINT_DIRECTION_MASK = 0x00000080;
enum USB_ENDPOINT_ADDRESS_MASK = 0x0000000f;
enum USB_ENDPOINT_TYPE_MASK = 0x00000003;
enum USB_ENDPOINT_TYPE_CONTROL = 0x00000000;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS = 0x00000001;
enum USB_ENDPOINT_TYPE_BULK = 0x00000002;
enum USB_ENDPOINT_TYPE_INTERRUPT = 0x00000003;
enum USB_ENDPOINT_TYPE_BULK_RESERVED_MASK = 0x000000fc;
enum USB_ENDPOINT_TYPE_CONTROL_RESERVED_MASK = 0x000000fc;
enum USB_20_ENDPOINT_TYPE_INTERRUPT_RESERVED_MASK = 0x000000fc;
enum USB_30_ENDPOINT_TYPE_INTERRUPT_RESERVED_MASK = 0x000000cc;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_RESERVED_MASK = 0x000000c0;
enum USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_MASK = 0x00000030;
enum USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_PERIODIC = 0x00000000;
enum USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_NOTIFICATION = 0x00000010;
enum USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_RESERVED10 = 0x00000020;
enum USB_30_ENDPOINT_TYPE_INTERRUPT_USAGE_RESERVED11 = 0x00000030;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_MASK = 0x0000000c;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_NO_SYNCHRONIZATION = 0x00000000;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_ASYNCHRONOUS = 0x00000004;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_ADAPTIVE = 0x00000008;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_SYNCHRONIZATION_SYNCHRONOUS = 0x0000000c;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_MASK = 0x00000030;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_DATA_ENDOINT = 0x00000000;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_FEEDBACK_ENDPOINT = 0x00000010;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_IMPLICIT_FEEDBACK_DATA_ENDPOINT = 0x00000020;
enum USB_ENDPOINT_TYPE_ISOCHRONOUS_USAGE_RESERVED = 0x00000030;
enum USB_ENDPOINT_SUPERSPEED_BULK_MAX_PACKET_SIZE = 0x00000400;
enum USB_ENDPOINT_SUPERSPEED_CONTROL_MAX_PACKET_SIZE = 0x00000200;
enum USB_ENDPOINT_SUPERSPEED_ISO_MAX_PACKET_SIZE = 0x00000400;
enum USB_ENDPOINT_SUPERSPEED_INTERRUPT_MAX_PACKET_SIZE = 0x00000400;
enum MAXIMUM_USB_STRING_LENGTH = 0x000000ff;
enum USB_SUPERSPEED_ISOCHRONOUS_MAX_MULTIPLIER = 0x00000002;
enum USB_SUPERSPEEDPLUS_ISOCHRONOUS_MIN_BYTESPERINTERVAL = 0x0000c001;
enum USB_SUPERSPEEDPLUS_ISOCHRONOUS_MAX_BYTESPERINTERVAL = 0x00ffffff;
enum USB_20_HUB_DESCRIPTOR_TYPE = 0x00000029;
enum USB_30_HUB_DESCRIPTOR_TYPE = 0x0000002a;
enum USB_REQUEST_GET_STATE = 0x00000002;
enum USB_REQUEST_CLEAR_TT_BUFFER = 0x00000008;
enum USB_REQUEST_RESET_TT = 0x00000009;
enum USB_REQUEST_GET_TT_STATE = 0x0000000a;
enum USB_REQUEST_STOP_TT = 0x0000000b;
enum USB_REQUEST_SET_HUB_DEPTH = 0x0000000c;
enum USB_REQUEST_GET_PORT_ERR_COUNT = 0x0000000d;
enum USB_PORT_STATUS_CONNECT = 0x00000001;
enum USB_PORT_STATUS_ENABLE = 0x00000002;
enum USB_PORT_STATUS_SUSPEND = 0x00000004;
enum USB_PORT_STATUS_OVER_CURRENT = 0x00000008;
enum USB_PORT_STATUS_RESET = 0x00000010;
enum USB_PORT_STATUS_POWER = 0x00000100;
enum USB_PORT_STATUS_LOW_SPEED = 0x00000200;
enum USB_PORT_STATUS_HIGH_SPEED = 0x00000400;
enum PORT_LINK_STATE_U0 = 0x00000000;
enum PORT_LINK_STATE_U1 = 0x00000001;
enum PORT_LINK_STATE_U2 = 0x00000002;
enum PORT_LINK_STATE_U3 = 0x00000003;
enum PORT_LINK_STATE_DISABLED = 0x00000004;
enum PORT_LINK_STATE_RX_DETECT = 0x00000005;
enum PORT_LINK_STATE_INACTIVE = 0x00000006;
enum PORT_LINK_STATE_POLLING = 0x00000007;
enum PORT_LINK_STATE_RECOVERY = 0x00000008;
enum PORT_LINK_STATE_HOT_RESET = 0x00000009;
enum PORT_LINK_STATE_COMPLIANCE_MODE = 0x0000000a;
enum PORT_LINK_STATE_LOOPBACK = 0x0000000b;
enum PORT_LINK_STATE_TEST_MODE = 0x0000000b;
enum USB_FEATURE_INTERFACE_POWER_D0 = 0x00000002;
enum USB_FEATURE_INTERFACE_POWER_D1 = 0x00000003;
enum USB_FEATURE_INTERFACE_POWER_D2 = 0x00000004;
enum USB_FEATURE_INTERFACE_POWER_D3 = 0x00000005;
enum USB_SUPPORT_D0_COMMAND = 0x00000001;
enum USB_SUPPORT_D1_COMMAND = 0x00000002;
enum USB_SUPPORT_D2_COMMAND = 0x00000004;
enum USB_SUPPORT_D3_COMMAND = 0x00000008;
enum USB_SUPPORT_D1_WAKEUP = 0x00000010;
enum USB_SUPPORT_D2_WAKEUP = 0x00000020;
enum USBDI_VERSION = 0x00000600;
enum USB_PORTATTR_NO_CONNECTOR = 0x00000001;
enum USB_PORTATTR_SHARED_USB2 = 0x00000002;
enum USB_PORTATTR_MINI_CONNECTOR = 0x00000004;
enum USB_PORTATTR_OEM_CONNECTOR = 0x00000008;
enum USB_PORTATTR_OWNED_BY_CC = 0x01000000;
enum USB_PORTATTR_NO_OVERCURRENT_UI = 0x02000000;
enum USB_DEFAULT_DEVICE_ADDRESS = 0x00000000;
enum USB_DEFAULT_ENDPOINT_ADDRESS = 0x00000000;
enum USB_DEFAULT_MAX_PACKET = 0x00000040;
enum URB_FUNCTION_SELECT_CONFIGURATION = 0x00000000;
enum URB_FUNCTION_SELECT_INTERFACE = 0x00000001;
enum URB_FUNCTION_ABORT_PIPE = 0x00000002;
enum URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL = 0x00000003;
enum URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL = 0x00000004;
enum URB_FUNCTION_GET_FRAME_LENGTH = 0x00000005;
enum URB_FUNCTION_SET_FRAME_LENGTH = 0x00000006;
enum URB_FUNCTION_GET_CURRENT_FRAME_NUMBER = 0x00000007;
enum URB_FUNCTION_CONTROL_TRANSFER = 0x00000008;
enum URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER = 0x00000009;
enum URB_FUNCTION_ISOCH_TRANSFER = 0x0000000a;
enum URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE = 0x0000000b;
enum URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE = 0x0000000c;
enum URB_FUNCTION_SET_FEATURE_TO_DEVICE = 0x0000000d;
enum URB_FUNCTION_SET_FEATURE_TO_INTERFACE = 0x0000000e;
enum URB_FUNCTION_SET_FEATURE_TO_ENDPOINT = 0x0000000f;
enum URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE = 0x00000010;
enum URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE = 0x00000011;
enum URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT = 0x00000012;
enum URB_FUNCTION_GET_STATUS_FROM_DEVICE = 0x00000013;
enum URB_FUNCTION_GET_STATUS_FROM_INTERFACE = 0x00000014;
enum URB_FUNCTION_GET_STATUS_FROM_ENDPOINT = 0x00000015;
enum URB_FUNCTION_RESERVED_0X0016 = 0x00000016;
enum URB_FUNCTION_VENDOR_DEVICE = 0x00000017;
enum URB_FUNCTION_VENDOR_INTERFACE = 0x00000018;
enum URB_FUNCTION_VENDOR_ENDPOINT = 0x00000019;
enum URB_FUNCTION_CLASS_DEVICE = 0x0000001a;
enum URB_FUNCTION_CLASS_INTERFACE = 0x0000001b;
enum URB_FUNCTION_CLASS_ENDPOINT = 0x0000001c;
enum URB_FUNCTION_RESERVE_0X001D = 0x0000001d;
enum URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL = 0x0000001e;
enum URB_FUNCTION_CLASS_OTHER = 0x0000001f;
enum URB_FUNCTION_VENDOR_OTHER = 0x00000020;
enum URB_FUNCTION_GET_STATUS_FROM_OTHER = 0x00000021;
enum URB_FUNCTION_CLEAR_FEATURE_TO_OTHER = 0x00000022;
enum URB_FUNCTION_SET_FEATURE_TO_OTHER = 0x00000023;
enum URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT = 0x00000024;
enum URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT = 0x00000025;
enum URB_FUNCTION_GET_CONFIGURATION = 0x00000026;
enum URB_FUNCTION_GET_INTERFACE = 0x00000027;
enum URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE = 0x00000028;
enum URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE = 0x00000029;
enum URB_FUNCTION_RESERVE_0X002B = 0x0000002b;
enum URB_FUNCTION_RESERVE_0X002C = 0x0000002c;
enum URB_FUNCTION_RESERVE_0X002D = 0x0000002d;
enum URB_FUNCTION_RESERVE_0X002E = 0x0000002e;
enum URB_FUNCTION_RESERVE_0X002F = 0x0000002f;
enum URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR = 0x0000002a;
enum URB_FUNCTION_SYNC_RESET_PIPE = 0x00000030;
enum URB_FUNCTION_SYNC_CLEAR_STALL = 0x00000031;
enum URB_FUNCTION_CONTROL_TRANSFER_EX = 0x00000032;
enum URB_FUNCTION_RESERVE_0X0033 = 0x00000033;
enum URB_FUNCTION_RESERVE_0X0034 = 0x00000034;
enum URB_FUNCTION_OPEN_STATIC_STREAMS = 0x00000035;
enum URB_FUNCTION_CLOSE_STATIC_STREAMS = 0x00000036;
enum URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL = 0x00000037;
enum URB_FUNCTION_ISOCH_TRANSFER_USING_CHAINED_MDL = 0x00000038;
enum URB_FUNCTION_GET_ISOCH_PIPE_TRANSFER_PATH_DELAYS = 0x0000003d;
enum URB_FUNCTION_RESET_PIPE = 0x0000001e;
enum USBD_SHORT_TRANSFER_OK = 0x00000002;
enum USBD_START_ISO_TRANSFER_ASAP = 0x00000004;
enum USBD_DEFAULT_PIPE_TRANSFER = 0x00000008;
enum USBD_TRANSFER_DIRECTION_OUT = 0x00000000;
enum USBD_TRANSFER_DIRECTION_IN = 0x00000001;
enum USBD_TRANSFER_DIRECTION = 0x00000001;
enum USBD_ISO_START_FRAME_RANGE = 0x00000400;
enum USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE = 0xffffffff;
enum USBD_PF_CHANGE_MAX_PACKET = 0x00000001;
enum USBD_PF_SHORT_PACKET_OPT = 0x00000002;
enum USBD_PF_ENABLE_RT_THREAD_ACCESS = 0x00000004;
enum USBD_PF_MAP_ADD_TRANSFERS = 0x00000008;
enum USBD_PF_VIDEO_PRIORITY = 0x00000010;
enum USBD_PF_VOICE_PRIORITY = 0x00000020;
enum USBD_PF_INTERACTIVE_PRIORITY = 0x00000030;
enum USBD_PF_PRIORITY_MASK = 0x000000f0;
enum USBD_PF_HANDLES_SSP_HIGH_BANDWIDTH_ISOCH = 0x00000100;
enum USBD_PF_SSP_HIGH_BANDWIDTH_ISOCH = 0x00010000;
enum OS_STRING_DESCRIPTOR_INDEX = 0x000000ee;
enum MS_GENRE_DESCRIPTOR_INDEX = 0x00000001;
enum MS_POWER_DESCRIPTOR_INDEX = 0x00000002;
enum MS_OS_STRING_SIGNATURE = "MSFT100";
enum MS_OS_FLAGS_CONTAINERID = 0x00000002;
enum URB_OPEN_STATIC_STREAMS_VERSION_100 = 0x00000100;
enum KREGUSBFNENUMPATH = "\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\USBFN\\";
enum UREGUSBFNENUMPATH = "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\USBFN\\";
enum KREGMANUSBFNENUMPATH = "\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\ManufacturingMode\\Current\\USBFN\\";
enum UREGMANUSBFNENUMPATH = "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\ManufacturingMode\\Current\\USBFN\\";
enum MAX_NUM_USBFN_ENDPOINTS = 0x0000000f;
enum MAX_CONFIGURATION_NAME_LENGTH = 0x00000028;
enum MAX_USB_STRING_LENGTH = 0x000000ff;
enum MAX_SUPPORTED_CONFIGURATIONS = 0x0000000c;
enum USBFN_INTERRUPT_ENDPOINT_SIZE_NOT_UPDATEABLE_MASK = 0x00000080;
enum USB_TEST_MODE_TEST_J = 0x00000001;
enum USB_TEST_MODE_TEST_K = 0x00000002;
enum USB_TEST_MODE_TEST_SE0_NAK = 0x00000003;
enum USB_TEST_MODE_TEST_PACKET = 0x00000004;
enum USB_TEST_MODE_TEST_FORCE_ENABLE = 0x00000005;
enum MAX_INTERFACE_NAME_LENGTH = 0x00000028;
enum MAX_ALTERNATE_NAME_LENGTH = 0x00000028;
enum MAX_ASSOCIATION_NAME_LENGTH = 0x00000028;
enum IOCTL_INTERNAL_USB_SUBMIT_URB = 0x00220003;
enum IOCTL_INTERNAL_USB_RESET_PORT = 0x00220007;
enum IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO = 0x0022000f;
enum USBD_PORT_ENABLED = 0x00000001;
enum USBD_PORT_CONNECTED = 0x00000002;
enum IOCTL_INTERNAL_USB_GET_PORT_STATUS = 0x00220013;
enum IOCTL_INTERNAL_USB_ENABLE_PORT = 0x00220017;
enum IOCTL_INTERNAL_USB_GET_HUB_COUNT = 0x0022001b;
enum IOCTL_INTERNAL_USB_CYCLE_PORT = 0x0022001f;
enum IOCTL_INTERNAL_USB_GET_HUB_NAME = 0x00220020;
enum IOCTL_INTERNAL_USB_GET_BUS_INFO = 0x00220420;
enum IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME = 0x00220424;
enum IOCTL_INTERNAL_USB_GET_BUSGUID_INFO = 0x00220428;
enum IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO = 0x0022042c;
enum IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION = 0x00220027;
enum IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE = 0x00220433;
enum IOCTL_INTERNAL_USB_NOTIFY_IDLE_READY = 0x00220443;
enum IOCTL_INTERNAL_USB_REQ_GLOBAL_SUSPEND = 0x00220447;
enum IOCTL_INTERNAL_USB_REQ_GLOBAL_RESUME = 0x0022044b;
enum IOCTL_INTERNAL_USB_RECORD_FAILURE = 0x0022002b;
enum IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE_EX = 0x00220437;
enum IOCTL_INTERNAL_USB_GET_TT_DEVICE_HANDLE = 0x0022043b;
enum IOCTL_INTERNAL_USB_GET_TOPOLOGY_ADDRESS = 0x0022043f;
enum IOCTL_INTERNAL_USB_GET_DEVICE_CONFIG_INFO = 0x0022044f;
enum IOCTL_INTERNAL_USB_REGISTER_COMPOSITE_DEVICE = 0x00490003;
enum IOCTL_INTERNAL_USB_UNREGISTER_COMPOSITE_DEVICE = 0x00490007;
enum IOCTL_INTERNAL_USB_REQUEST_REMOTE_WAKE_NOTIFICATION = 0x0049000b;
enum IOCTL_INTERNAL_USB_FAIL_GET_STATUS_FROM_DEVICE = 0x00220463;
enum IOCTL_USB_HCD_GET_STATS_1 = 0x002203fc;
enum IOCTL_USB_HCD_GET_STATS_2 = 0x00220428;
enum IOCTL_USB_HCD_DISABLE_PORT = 0x00220430;
enum IOCTL_USB_HCD_ENABLE_PORT = 0x00220434;
enum IOCTL_USB_DIAGNOSTIC_MODE_ON = 0x00220400;
enum IOCTL_USB_DIAGNOSTIC_MODE_OFF = 0x00220404;
enum IOCTL_USB_GET_ROOT_HUB_NAME = 0x00220408;
enum IOCTL_GET_HCD_DRIVERKEY_NAME = 0x00220424;
enum IOCTL_USB_GET_NODE_INFORMATION = 0x00220408;
enum IOCTL_USB_GET_NODE_CONNECTION_INFORMATION = 0x0022040c;
enum IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION = 0x00220410;
enum IOCTL_USB_GET_NODE_CONNECTION_NAME = 0x00220414;
enum IOCTL_USB_DIAG_IGNORE_HUBS_ON = 0x00220418;
enum IOCTL_USB_DIAG_IGNORE_HUBS_OFF = 0x0022041c;
enum IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME = 0x00220420;
enum IOCTL_USB_GET_HUB_CAPABILITIES = 0x0022043c;
enum IOCTL_USB_HUB_CYCLE_PORT = 0x00220444;
enum IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES = 0x00220440;
enum IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX = 0x00220448;
enum IOCTL_USB_RESET_HUB = 0x0022044c;
enum IOCTL_USB_GET_HUB_CAPABILITIES_EX = 0x00220450;
enum IOCTL_USB_GET_HUB_INFORMATION_EX = 0x00220454;
enum IOCTL_USB_GET_PORT_CONNECTOR_PROPERTIES = 0x00220458;
enum IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX_V2 = 0x0022045c;
enum IOCTL_USB_GET_TRANSPORT_CHARACTERISTICS = 0x00220464;
enum IOCTL_USB_REGISTER_FOR_TRANSPORT_CHARACTERISTICS_CHANGE = 0x00220468;
enum IOCTL_USB_NOTIFY_ON_TRANSPORT_CHARACTERISTICS_CHANGE = 0x0022046c;
enum IOCTL_USB_UNREGISTER_FOR_TRANSPORT_CHARACTERISTICS_CHANGE = 0x00220470;
enum IOCTL_USB_START_TRACKING_FOR_TIME_SYNC = 0x00220474;
enum IOCTL_USB_GET_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC = 0x00220478;
enum IOCTL_USB_STOP_TRACKING_FOR_TIME_SYNC = 0x0022047c;
enum IOCTL_USB_GET_DEVICE_CHARACTERISTICS = 0x00220480;
enum WMI_USB_DRIVER_INFORMATION = 0x00000000;
enum WMI_USB_DRIVER_NOTIFICATION = 0x00000001;
enum WMI_USB_POWER_DEVICE_ENABLE = 0x00000002;
enum WMI_USB_HUB_NODE_INFORMATION = 0x00000004;
enum WMI_USB_PERFORMANCE_INFORMATION = 0x00000001;
enum WMI_USB_DEVICE_NODE_INFORMATION = 0x00000002;
enum USB_TRANSPORT_CHARACTERISTICS_VERSION_1 = 0x00000001;
enum USB_TRANSPORT_CHARACTERISTICS_LATENCY_AVAILABLE = 0x00000001;
enum USB_TRANSPORT_CHARACTERISTICS_BANDWIDTH_AVAILABLE = 0x00000002;
enum USB_REGISTER_FOR_TRANSPORT_LATENCY_CHANGE = 0x00000001;
enum USB_REGISTER_FOR_TRANSPORT_BANDWIDTH_CHANGE = 0x00000002;
enum USB_DEVICE_CHARACTERISTICS_VERSION_1 = 0x00000001;
enum USB_DEVICE_CHARACTERISTICS_MAXIMUM_PATH_DELAYS_AVAILABLE = 0x00000001;
enum MAX_NUM_PIPES = 0x00000008;
enum BULKIN_FLAG = 0x00000080;
enum FILE_DEVICE_USB_SCAN = 0x00008000;
enum IOCTL_INDEX = 0x00000800;
enum IOCTL_GET_VERSION = 0x80002000;
enum IOCTL_CANCEL_IO = 0x80002004;
enum IOCTL_WAIT_ON_DEVICE_EVENT = 0x80002008;
enum IOCTL_READ_REGISTERS = 0x8000200c;
enum IOCTL_WRITE_REGISTERS = 0x80002010;
enum IOCTL_GET_CHANNEL_ALIGN_RQST = 0x80002014;
enum IOCTL_GET_DEVICE_DESCRIPTOR = 0x80002018;
enum IOCTL_RESET_PIPE = 0x8000201c;
enum IOCTL_GET_USB_DESCRIPTOR = 0x80002020;
enum IOCTL_SEND_USB_REQUEST = 0x80002024;
enum IOCTL_GET_PIPE_CONFIGURATION = 0x80002028;
enum IOCTL_SET_TIMEOUT = 0x8000202c;
enum IOCTL_ABORT_PIPE = 0x80002004;
enum WinUSB_TestGuid = GUID(0xda812bff, 0x12c3, 0x46a2, [0x8e, 0x2b, 0xdb, 0xd3, 0xb7, 0x83, 0x4c, 0x43]);
alias USB_DEVICE_SPEED = int;
enum : int
{
    UsbLowSpeed   = 0x00000000,
    UsbFullSpeed  = 0x00000001,
    UsbHighSpeed  = 0x00000002,
    UsbSuperSpeed = 0x00000003,
}

alias USB_DEVICE_TYPE = int;
enum : int
{
    Usb11Device = 0x00000000,
    Usb20Device = 0x00000001,
}

union BM_REQUEST_TYPE
{
    struct _BM
    {
        ubyte _bitfield0;
    }
    ubyte B;
}
struct USB_DEFAULT_PIPE_SETUP_PACKET
{
    align (1):
    BM_REQUEST_TYPE bmRequestType;
    ubyte bRequest;
    union _wValue
    {
        align (1):
        struct
        {
            ubyte LowByte;
            ubyte HiByte;
        }
        ushort W;
    }
    union _wIndex
    {
        align (1):
        struct
        {
            ubyte LowByte;
            ubyte HiByte;
        }
        ushort W;
    }
    ushort wLength;
}
union USB_DEVICE_STATUS
{
    align (1):
    ushort AsUshort16;
    struct
    {
        align (1):
        ushort _bitfield0;
    }
}
union USB_INTERFACE_STATUS
{
    align (1):
    ushort AsUshort16;
    struct
    {
        align (1):
        ushort _bitfield0;
    }
}
union USB_ENDPOINT_STATUS
{
    align (1):
    ushort AsUshort16;
    struct
    {
        align (1):
        ushort _bitfield0;
    }
}
struct USB_COMMON_DESCRIPTOR
{
    ubyte bLength;
    ubyte bDescriptorType;
}
struct USB_DEVICE_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ushort bcdUSB;
    ubyte bDeviceClass;
    ubyte bDeviceSubClass;
    ubyte bDeviceProtocol;
    ubyte bMaxPacketSize0;
    ushort idVendor;
    ushort idProduct;
    ushort bcdDevice;
    ubyte iManufacturer;
    ubyte iProduct;
    ubyte iSerialNumber;
    ubyte bNumConfigurations;
}
struct USB_DEVICE_QUALIFIER_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ushort bcdUSB;
    ubyte bDeviceClass;
    ubyte bDeviceSubClass;
    ubyte bDeviceProtocol;
    ubyte bMaxPacketSize0;
    ubyte bNumConfigurations;
    ubyte bReserved;
}
struct USB_BOS_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ushort wTotalLength;
    ubyte bNumDeviceCaps;
}
struct USB_DEVICE_CAPABILITY_USB20_EXTENSION_DESCRIPTOR
{
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bDevCapabilityType;
    union _bmAttributes_e__Union
    {
        align (1):
        uint AsUlong;
        struct
        {
            align (1):
            uint _bitfield0;
        }
    }
}
struct USB_DEVICE_CAPABILITY_POWER_DELIVERY_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bDevCapabilityType;
    ubyte bReserved;
    union _bmAttributes_e__Union
    {
        align (1):
        uint AsUlong;
        struct
        {
            align (1):
            uint _bitfield0;
        }
    }
    ushort bmProviderPorts;
    ushort bmConsumerPorts;
    ushort bcdBCVersion;
    ushort bcdPDVersion;
    ushort bcdUSBTypeCVersion;
}
struct USB_DEVICE_CAPABILITY_PD_CONSUMER_PORT_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bDevCapabilityType;
    ubyte bReserved;
    union _bmCapabilities_e__Union
    {
        align (1):
        ushort AsUshort;
        struct
        {
            align (1):
            ushort _bitfield0;
        }
    }
    ushort wMinVoltage;
    ushort wMaxVoltage;
    ushort wReserved;
    uint dwMaxOperatingPower;
    uint dwMaxPeakPower;
    uint dwMaxPeakPowerTime;
}
struct USB_DEVICE_CAPABILITY_SUPERSPEED_USB_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bDevCapabilityType;
    ubyte bmAttributes;
    ushort wSpeedsSupported;
    ubyte bFunctionalitySupport;
    ubyte bU1DevExitLat;
    ushort wU2DevExitLat;
}
union USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED
{
    align (1):
    uint AsUlong32;
    struct
    {
        align (1):
        uint _bitfield0;
    }
}
struct USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_USB_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bDevCapabilityType;
    ubyte bReserved;
    union _bmAttributes_e__Union
    {
        align (1):
        uint AsUlong;
        struct
        {
            align (1):
            uint _bitfield0;
        }
    }
    union _wFunctionalitySupport_e__Union
    {
        align (1):
        ushort AsUshort;
        struct
        {
            align (1):
            ushort _bitfield1;
        }
    }
    ushort wReserved;
    USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED[1] bmSublinkSpeedAttr;
}
struct USB_DEVICE_CAPABILITY_CONTAINER_ID_DESCRIPTOR
{
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bDevCapabilityType;
    ubyte bReserved;
    ubyte[16] ContainerID;
}
struct USB_DEVICE_CAPABILITY_PLATFORM_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bDevCapabilityType;
    ubyte bReserved;
    GUID PlatformCapabilityUuid;
    ubyte[1] CapabililityData;
}
struct USB_DEVICE_CAPABILITY_BILLBOARD_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bDevCapabilityType;
    ubyte iAddtionalInfoURL;
    ubyte bNumberOfAlternateModes;
    ubyte bPreferredAlternateMode;
    union _VconnPower_e__Union
    {
        align (1):
        ushort AsUshort;
        struct
        {
            align (1):
            ushort _bitfield0;
        }
    }
    ubyte[32] bmConfigured;
    uint bReserved;
    struct
    {
        align (1):
        ushort wSVID;
        ubyte bAlternateMode;
        ubyte iAlternateModeSetting;
    }
}
struct USB_DEVICE_CAPABILITY_FIRMWARE_STATUS_DESCRIPTOR
{
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bDevCapabilityType;
    ubyte bcdDescriptorVersion;
    union _bmAttributes_e__Union
    {
        align (1):
        uint AsUlong;
        struct
        {
            align (1):
            uint _bitfield0;
        }
    }
}
struct USB_DEVICE_CAPABILITY_DESCRIPTOR
{
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bDevCapabilityType;
}
struct USB_CONFIGURATION_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ushort wTotalLength;
    ubyte bNumInterfaces;
    ubyte bConfigurationValue;
    ubyte iConfiguration;
    ubyte bmAttributes;
    ubyte MaxPower;
}
struct USB_INTERFACE_ASSOCIATION_DESCRIPTOR
{
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bFirstInterface;
    ubyte bInterfaceCount;
    ubyte bFunctionClass;
    ubyte bFunctionSubClass;
    ubyte bFunctionProtocol;
    ubyte iFunction;
}
struct USB_INTERFACE_DESCRIPTOR
{
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bInterfaceNumber;
    ubyte bAlternateSetting;
    ubyte bNumEndpoints;
    ubyte bInterfaceClass;
    ubyte bInterfaceSubClass;
    ubyte bInterfaceProtocol;
    ubyte iInterface;
}
struct USB_ENDPOINT_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bEndpointAddress;
    ubyte bmAttributes;
    ushort wMaxPacketSize;
    ubyte bInterval;
}
union USB_HIGH_SPEED_MAXPACKET
{
    align (1):
    ushort us;
}
struct USB_STRING_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    wchar[1] bString;
}
struct USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bMaxBurst;
    union _bmAttributes_e__Union
    {
        ubyte AsUchar;
        struct _Bulk_e__Struct
        {
            ubyte _bitfield0;
        }
        struct _Isochronous_e__Struct
        {
            ubyte _bitfield1;
        }
    }
    ushort wBytesPerInterval;
}
struct USB_SUPERSPEEDPLUS_ISOCH_ENDPOINT_COMPANION_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ushort wReserved;
    uint dwBytesPerInterval;
}
struct USB_HUB_DESCRIPTOR
{
    align (1):
    ubyte bDescriptorLength;
    ubyte bDescriptorType;
    ubyte bNumberOfPorts;
    ushort wHubCharacteristics;
    ubyte bPowerOnToPowerGood;
    ubyte bHubControlCurrent;
    ubyte[64] bRemoveAndPowerMask;
}
struct USB_30_HUB_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bNumberOfPorts;
    ushort wHubCharacteristics;
    ubyte bPowerOnToPowerGood;
    ubyte bHubControlCurrent;
    ubyte bHubHdrDecLat;
    ushort wHubDelay;
    ushort DeviceRemovable;
}
union USB_HUB_STATUS
{
    align (1):
    ushort AsUshort16;
    struct
    {
        align (1):
        ushort _bitfield0;
    }
}
union USB_HUB_CHANGE
{
    align (1):
    ushort AsUshort16;
    struct
    {
        align (1):
        ushort _bitfield0;
    }
}
union USB_HUB_STATUS_AND_CHANGE
{
    align (1):
    uint AsUlong32;
    struct
    {
        USB_HUB_STATUS HubStatus;
        USB_HUB_CHANGE HubChange;
    }
}
union USB_20_PORT_STATUS
{
    align (1):
    ushort AsUshort16;
    struct
    {
        align (1):
        ushort _bitfield0;
    }
}
union USB_20_PORT_CHANGE
{
    align (1):
    ushort AsUshort16;
    struct
    {
        align (1):
        ushort _bitfield0;
    }
}
union USB_30_PORT_STATUS
{
    align (1):
    ushort AsUshort16;
    struct
    {
        align (1):
        ushort _bitfield0;
    }
}
union USB_30_PORT_CHANGE
{
    align (1):
    ushort AsUshort16;
    struct
    {
        align (1):
        ushort _bitfield0;
    }
}
union USB_PORT_STATUS
{
    align (1):
    ushort AsUshort16;
    USB_20_PORT_STATUS Usb20PortStatus;
    USB_30_PORT_STATUS Usb30PortStatus;
}
union USB_PORT_CHANGE
{
    align (1):
    ushort AsUshort16;
    USB_20_PORT_CHANGE Usb20PortChange;
    USB_30_PORT_CHANGE Usb30PortChange;
}
union USB_PORT_EXT_STATUS
{
    align (1):
    uint AsUlong32;
    struct
    {
        align (1):
        uint _bitfield0;
    }
}
union USB_PORT_STATUS_AND_CHANGE
{
    align (1):
    uint AsUlong32;
    struct
    {
        USB_PORT_STATUS PortStatus;
        USB_PORT_CHANGE PortChange;
    }
}
union USB_PORT_EXT_STATUS_AND_CHANGE
{
    align (1):
    ulong AsUlong64;
    struct
    {
        USB_PORT_STATUS_AND_CHANGE PortStatusChange;
        USB_PORT_EXT_STATUS PortExtStatus;
    }
}
union USB_HUB_30_PORT_REMOTE_WAKE_MASK
{
    ubyte AsUchar8;
    struct
    {
        ubyte _bitfield0;
    }
}
union USB_FUNCTION_SUSPEND_OPTIONS
{
    ubyte AsUchar;
    struct
    {
        ubyte _bitfield0;
    }
}
struct USB_CONFIGURATION_POWER_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte[3] SelfPowerConsumedD0;
    ubyte bPowerSummaryId;
    ubyte bBusPowerSavingD1;
    ubyte bSelfPowerSavingD1;
    ubyte bBusPowerSavingD2;
    ubyte bSelfPowerSavingD2;
    ubyte bBusPowerSavingD3;
    ubyte bSelfPowerSavingD3;
    ushort TransitionTimeFromD1;
    ushort TransitionTimeFromD2;
    ushort TransitionTimeFromD3;
}
struct USB_INTERFACE_POWER_DESCRIPTOR
{
    align (1):
    ubyte bLength;
    ubyte bDescriptorType;
    ubyte bmCapabilitiesFlags;
    ubyte bBusPowerSavingD1;
    ubyte bSelfPowerSavingD1;
    ubyte bBusPowerSavingD2;
    ubyte bSelfPowerSavingD2;
    ubyte bBusPowerSavingD3;
    ubyte bSelfPowerSavingD3;
    ushort TransitionTimeFromD1;
    ushort TransitionTimeFromD2;
    ushort TransitionTimeFromD3;
}
alias USB_CONTROLLER_FLAVOR = int;
enum : int
{
    USB_HcGeneric       = 0x00000000,
    OHCI_Generic        = 0x00000064,
    OHCI_Hydra          = 0x00000065,
    OHCI_NEC            = 0x00000066,
    UHCI_Generic        = 0x000000c8,
    UHCI_Piix4          = 0x000000c9,
    UHCI_Piix3          = 0x000000ca,
    UHCI_Ich2           = 0x000000cb,
    UHCI_Reserved204    = 0x000000cc,
    UHCI_Ich1           = 0x000000cd,
    UHCI_Ich3m          = 0x000000ce,
    UHCI_Ich4           = 0x000000cf,
    UHCI_Ich5           = 0x000000d0,
    UHCI_Ich6           = 0x000000d1,
    UHCI_Intel          = 0x000000f9,
    UHCI_VIA            = 0x000000fa,
    UHCI_VIA_x01        = 0x000000fb,
    UHCI_VIA_x02        = 0x000000fc,
    UHCI_VIA_x03        = 0x000000fd,
    UHCI_VIA_x04        = 0x000000fe,
    UHCI_VIA_x0E_FIFO   = 0x00000108,
    EHCI_Generic        = 0x000003e8,
    EHCI_NEC            = 0x000007d0,
    EHCI_Lucent         = 0x00000bb8,
    EHCI_NVIDIA_Tegra2  = 0x00000fa0,
    EHCI_NVIDIA_Tegra3  = 0x00000fa1,
    EHCI_Intel_Medfield = 0x00001389,
}

struct USBD_VERSION_INFORMATION
{
    uint USBDI_Version;
    uint Supported_USB_Version;
}
alias USBD_PIPE_TYPE = int;
enum : int
{
    UsbdPipeTypeControl     = 0x00000000,
    UsbdPipeTypeIsochronous = 0x00000001,
    UsbdPipeTypeBulk        = 0x00000002,
    UsbdPipeTypeInterrupt   = 0x00000003,
}

struct USBD_DEVICE_INFORMATION
{
    uint OffsetNext;
    void* UsbdDeviceHandle;
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;
}
struct USBD_PIPE_INFORMATION
{
    ushort MaximumPacketSize;
    ubyte EndpointAddress;
    ubyte Interval;
    USBD_PIPE_TYPE PipeType;
    void* PipeHandle;
    uint MaximumTransferSize;
    uint PipeFlags;
}
alias USBD_ENDPOINT_OFFLOAD_MODE = int;
enum : int
{
    UsbdEndpointOffloadModeNotSupported = 0x00000000,
    UsbdEndpointOffloadSoftwareAssisted = 0x00000001,
    UsbdEndpointOffloadHardwareAssisted = 0x00000002,
}

struct USBD_ENDPOINT_OFFLOAD_INFORMATION
{
    align (1):
    uint Size;
    ushort EndpointAddress;
    uint ResourceId;
    USBD_ENDPOINT_OFFLOAD_MODE Mode;
    uint _bitfield1;
    uint _bitfield2;
    LARGE_INTEGER TransferSegmentLA;
    void* TransferSegmentVA;
    ulong TransferRingSize;
    uint TransferRingInitialCycleBit;
    uint MessageNumber;
    LARGE_INTEGER EventRingSegmentLA;
    void* EventRingSegmentVA;
    ulong EventRingSize;
    uint EventRingInitialCycleBit;
}
struct USBD_INTERFACE_INFORMATION
{
    ushort Length;
    ubyte InterfaceNumber;
    ubyte AlternateSetting;
    ubyte Class;
    ubyte SubClass;
    ubyte Protocol;
    ubyte Reserved;
    void* InterfaceHandle;
    uint NumberOfPipes;
    USBD_PIPE_INFORMATION[1] Pipes;
}
struct _URB_HCD_AREA
{
    void*[8] Reserved8;
}
struct _URB_HEADER
{
    ushort Length;
    ushort Function;
    int Status;
    void* UsbdDeviceHandle;
    uint UsbdFlags;
}
struct _URB_SELECT_INTERFACE
{
    _URB_HEADER Hdr;
    void* ConfigurationHandle;
    USBD_INTERFACE_INFORMATION Interface;
}
struct _URB_SELECT_CONFIGURATION
{
    _URB_HEADER Hdr;
    USB_CONFIGURATION_DESCRIPTOR* ConfigurationDescriptor;
    void* ConfigurationHandle;
    USBD_INTERFACE_INFORMATION Interface;
}
struct _URB_PIPE_REQUEST
{
    _URB_HEADER Hdr;
    void* PipeHandle;
    uint Reserved;
}
struct _URB_FRAME_LENGTH_CONTROL
{
    _URB_HEADER Hdr;
}
struct _URB_GET_FRAME_LENGTH
{
    _URB_HEADER Hdr;
    uint FrameLength;
    uint FrameNumber;
}
struct _URB_SET_FRAME_LENGTH
{
    _URB_HEADER Hdr;
    int FrameLengthDelta;
}
struct _URB_GET_CURRENT_FRAME_NUMBER
{
    _URB_HEADER Hdr;
    uint FrameNumber;
}
struct _URB_CONTROL_DESCRIPTOR_REQUEST
{
    _URB_HEADER Hdr;
    void* Reserved;
    uint Reserved0;
    uint TransferBufferLength;
    void* TransferBuffer;
    void* TransferBufferMDL;
    URB* UrbLink;
    _URB_HCD_AREA hca;
    ushort Reserved1;
    ubyte Index;
    ubyte DescriptorType;
    ushort LanguageId;
    ushort Reserved2;
}
struct _URB_CONTROL_GET_STATUS_REQUEST
{
    _URB_HEADER Hdr;
    void* Reserved;
    uint Reserved0;
    uint TransferBufferLength;
    void* TransferBuffer;
    void* TransferBufferMDL;
    URB* UrbLink;
    _URB_HCD_AREA hca;
    ubyte[4] Reserved1;
    ushort Index;
    ushort Reserved2;
}
struct _URB_CONTROL_FEATURE_REQUEST
{
    _URB_HEADER Hdr;
    void* Reserved;
    uint Reserved2;
    uint Reserved3;
    void* Reserved4;
    void* Reserved5;
    URB* UrbLink;
    _URB_HCD_AREA hca;
    ushort Reserved0;
    ushort FeatureSelector;
    ushort Index;
    ushort Reserved1;
}
struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST
{
    _URB_HEADER Hdr;
    void* Reserved;
    uint TransferFlags;
    uint TransferBufferLength;
    void* TransferBuffer;
    void* TransferBufferMDL;
    URB* UrbLink;
    _URB_HCD_AREA hca;
    ubyte RequestTypeReservedBits;
    ubyte Request;
    ushort Value;
    ushort Index;
    ushort Reserved1;
}
struct _URB_CONTROL_GET_INTERFACE_REQUEST
{
    _URB_HEADER Hdr;
    void* Reserved;
    uint Reserved0;
    uint TransferBufferLength;
    void* TransferBuffer;
    void* TransferBufferMDL;
    URB* UrbLink;
    _URB_HCD_AREA hca;
    ubyte[4] Reserved1;
    ushort Interface;
    ushort Reserved2;
}
struct _URB_CONTROL_GET_CONFIGURATION_REQUEST
{
    _URB_HEADER Hdr;
    void* Reserved;
    uint Reserved0;
    uint TransferBufferLength;
    void* TransferBuffer;
    void* TransferBufferMDL;
    URB* UrbLink;
    _URB_HCD_AREA hca;
    ubyte[8] Reserved1;
}
struct OS_STRING
{
    ubyte bLength;
    ubyte bDescriptorType;
    wchar[7] MicrosoftString;
    ubyte bVendorCode;
    union
    {
        ubyte bPad;
        ubyte bFlags;
    }
}
struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST
{
    _URB_HEADER Hdr;
    void* Reserved;
    uint Reserved0;
    uint TransferBufferLength;
    void* TransferBuffer;
    void* TransferBufferMDL;
    URB* UrbLink;
    _URB_HCD_AREA hca;
    ubyte _bitfield0;
    ubyte Reserved2;
    ubyte InterfaceNumber;
    ubyte MS_PageIndex;
    ushort MS_FeatureDescriptorIndex;
    ushort Reserved3;
}
struct _URB_CONTROL_TRANSFER
{
    _URB_HEADER Hdr;
    void* PipeHandle;
    uint TransferFlags;
    uint TransferBufferLength;
    void* TransferBuffer;
    void* TransferBufferMDL;
    URB* UrbLink;
    _URB_HCD_AREA hca;
    ubyte[8] SetupPacket;
}
struct _URB_CONTROL_TRANSFER_EX
{
    _URB_HEADER Hdr;
    void* PipeHandle;
    uint TransferFlags;
    uint TransferBufferLength;
    void* TransferBuffer;
    void* TransferBufferMDL;
    uint Timeout;
    _URB_HCD_AREA hca;
    ubyte[8] SetupPacket;
}
struct _URB_BULK_OR_INTERRUPT_TRANSFER
{
    _URB_HEADER Hdr;
    void* PipeHandle;
    uint TransferFlags;
    uint TransferBufferLength;
    void* TransferBuffer;
    void* TransferBufferMDL;
    URB* UrbLink;
    _URB_HCD_AREA hca;
}
struct USBD_ISO_PACKET_DESCRIPTOR
{
    uint Offset;
    uint Length;
    int Status;
}
struct _URB_ISOCH_TRANSFER
{
    _URB_HEADER Hdr;
    void* PipeHandle;
    uint TransferFlags;
    uint TransferBufferLength;
    void* TransferBuffer;
    void* TransferBufferMDL;
    URB* UrbLink;
    _URB_HCD_AREA hca;
    uint StartFrame;
    uint NumberOfPackets;
    uint ErrorCount;
    USBD_ISO_PACKET_DESCRIPTOR[1] IsoPacket;
}
struct USBD_STREAM_INFORMATION
{
    void* PipeHandle;
    uint StreamID;
    uint MaximumTransferSize;
    uint PipeFlags;
}
struct _URB_OPEN_STATIC_STREAMS
{
    _URB_HEADER Hdr;
    void* PipeHandle;
    uint NumberOfStreams;
    ushort StreamInfoVersion;
    ushort StreamInfoSize;
    USBD_STREAM_INFORMATION* Streams;
}
struct _URB_GET_ISOCH_PIPE_TRANSFER_PATH_DELAYS
{
    _URB_HEADER Hdr;
    void* PipeHandle;
    uint MaximumSendPathDelayInMilliSeconds;
    uint MaximumCompletionPathDelayInMilliSeconds;
}
struct URB
{
    union
    {
        _URB_HEADER UrbHeader;
        _URB_SELECT_INTERFACE UrbSelectInterface;
        _URB_SELECT_CONFIGURATION UrbSelectConfiguration;
        _URB_PIPE_REQUEST UrbPipeRequest;
        _URB_FRAME_LENGTH_CONTROL UrbFrameLengthControl;
        _URB_GET_FRAME_LENGTH UrbGetFrameLength;
        _URB_SET_FRAME_LENGTH UrbSetFrameLength;
        _URB_GET_CURRENT_FRAME_NUMBER UrbGetCurrentFrameNumber;
        _URB_CONTROL_TRANSFER UrbControlTransfer;
        _URB_CONTROL_TRANSFER_EX UrbControlTransferEx;
        _URB_BULK_OR_INTERRUPT_TRANSFER UrbBulkOrInterruptTransfer;
        _URB_ISOCH_TRANSFER UrbIsochronousTransfer;
        _URB_CONTROL_DESCRIPTOR_REQUEST UrbControlDescriptorRequest;
        _URB_CONTROL_GET_STATUS_REQUEST UrbControlGetStatusRequest;
        _URB_CONTROL_FEATURE_REQUEST UrbControlFeatureRequest;
        _URB_CONTROL_VENDOR_OR_CLASS_REQUEST UrbControlVendorClassRequest;
        _URB_CONTROL_GET_INTERFACE_REQUEST UrbControlGetInterfaceRequest;
        _URB_CONTROL_GET_CONFIGURATION_REQUEST UrbControlGetConfigurationRequest;
        _URB_OS_FEATURE_DESCRIPTOR_REQUEST UrbOSFeatureDescriptorRequest;
        _URB_OPEN_STATIC_STREAMS UrbOpenStaticStreams;
        _URB_GET_ISOCH_PIPE_TRANSFER_PATH_DELAYS UrbGetIsochPipeTransferPathDelays;
    }
}
alias USB_IDLE_CALLBACK = void function(void*);
struct USB_IDLE_CALLBACK_INFO
{
    USB_IDLE_CALLBACK IdleCallback;
    void* IdleContext;
}
alias USB_USER_ERROR_CODE = int;
enum : int
{
    UsbUserSuccess                = 0x00000000,
    UsbUserNotSupported           = 0x00000001,
    UsbUserInvalidRequestCode     = 0x00000002,
    UsbUserFeatureDisabled        = 0x00000003,
    UsbUserInvalidHeaderParameter = 0x00000004,
    UsbUserInvalidParameter       = 0x00000005,
    UsbUserMiniportError          = 0x00000006,
    UsbUserBufferTooSmall         = 0x00000007,
    UsbUserErrorNotMapped         = 0x00000008,
    UsbUserDeviceNotStarted       = 0x00000009,
    UsbUserNoDeviceConnected      = 0x0000000a,
}

struct USBUSER_REQUEST_HEADER
{
    align (1):
    uint UsbUserRequest;
    USB_USER_ERROR_CODE UsbUserStatusCode;
    uint RequestBufferLength;
    uint ActualBufferLength;
}
struct PACKET_PARAMETERS
{
    align (1):
    ubyte DeviceAddress;
    ubyte EndpointAddress;
    ushort MaximumPacketSize;
    uint Timeout;
    uint Flags;
    uint DataLength;
    ushort HubDeviceAddress;
    ushort PortTTNumber;
    ubyte ErrorCount;
    ubyte[3] Pad;
    int UsbdStatusCode;
    ubyte[4] Data;
}
struct USBUSER_SEND_ONE_PACKET
{
    USBUSER_REQUEST_HEADER Header;
    PACKET_PARAMETERS PacketParameters;
}
struct RAW_RESET_PORT_PARAMETERS
{
    align (1):
    ushort PortNumber;
    ushort PortStatus;
}
struct USBUSER_RAW_RESET_ROOT_PORT
{
    USBUSER_REQUEST_HEADER Header;
    RAW_RESET_PORT_PARAMETERS Parameters;
}
struct RAW_ROOTPORT_FEATURE
{
    align (1):
    ushort PortNumber;
    ushort PortFeature;
    ushort PortStatus;
}
struct USBUSER_ROOTPORT_FEATURE_REQUEST
{
    USBUSER_REQUEST_HEADER Header;
    RAW_ROOTPORT_FEATURE Parameters;
}
struct RAW_ROOTPORT_PARAMETERS
{
    align (1):
    ushort PortNumber;
    ushort PortStatus;
}
struct USBUSER_ROOTPORT_PARAMETERS
{
    USBUSER_REQUEST_HEADER Header;
    RAW_ROOTPORT_PARAMETERS Parameters;
}
struct USB_CONTROLLER_INFO_0
{
    align (1):
    uint PciVendorId;
    uint PciDeviceId;
    uint PciRevision;
    uint NumberOfRootPorts;
    USB_CONTROLLER_FLAVOR ControllerFlavor;
    uint HcFeatureFlags;
}
struct USBUSER_CONTROLLER_INFO_0
{
    USBUSER_REQUEST_HEADER Header;
    USB_CONTROLLER_INFO_0 Info0;
}
struct USB_UNICODE_NAME
{
    align (1):
    uint Length;
    wchar[1] String;
}
struct USBUSER_CONTROLLER_UNICODE_NAME
{
    USBUSER_REQUEST_HEADER Header;
    USB_UNICODE_NAME UnicodeName;
}
struct USB_PASS_THRU_PARAMETERS
{
    align (1):
    GUID FunctionGUID;
    uint ParameterLength;
    ubyte[4] Parameters;
}
struct USBUSER_PASS_THRU_REQUEST
{
    USBUSER_REQUEST_HEADER Header;
    USB_PASS_THRU_PARAMETERS PassThru;
}
alias WDMUSB_POWER_STATE = int;
enum : int
{
    WdmUsbPowerNotMapped         = 0x00000000,
    WdmUsbPowerSystemUnspecified = 0x00000064,
    WdmUsbPowerSystemWorking     = 0x00000065,
    WdmUsbPowerSystemSleeping1   = 0x00000066,
    WdmUsbPowerSystemSleeping2   = 0x00000067,
    WdmUsbPowerSystemSleeping3   = 0x00000068,
    WdmUsbPowerSystemHibernate   = 0x00000069,
    WdmUsbPowerSystemShutdown    = 0x0000006a,
    WdmUsbPowerDeviceUnspecified = 0x000000c8,
    WdmUsbPowerDeviceD0          = 0x000000c9,
    WdmUsbPowerDeviceD1          = 0x000000ca,
    WdmUsbPowerDeviceD2          = 0x000000cb,
    WdmUsbPowerDeviceD3          = 0x000000cc,
}

struct USB_POWER_INFO
{
    align (1):
    WDMUSB_POWER_STATE SystemState;
    WDMUSB_POWER_STATE HcDevicePowerState;
    WDMUSB_POWER_STATE HcDeviceWake;
    WDMUSB_POWER_STATE HcSystemWake;
    WDMUSB_POWER_STATE RhDevicePowerState;
    WDMUSB_POWER_STATE RhDeviceWake;
    WDMUSB_POWER_STATE RhSystemWake;
    WDMUSB_POWER_STATE LastSystemSleepState;
    BOOLEAN CanWakeup;
    BOOLEAN IsPowered;
}
struct USBUSER_POWER_INFO_REQUEST
{
    USBUSER_REQUEST_HEADER Header;
    USB_POWER_INFO PowerInformation;
}
struct USB_OPEN_RAW_DEVICE_PARAMETERS
{
    align (1):
    ushort PortStatus;
    ushort MaxPacketEp0;
}
struct USBUSER_OPEN_RAW_DEVICE
{
    USBUSER_REQUEST_HEADER Header;
    USB_OPEN_RAW_DEVICE_PARAMETERS Parameters;
}
struct USB_CLOSE_RAW_DEVICE_PARAMETERS
{
    align (1):
    uint xxx;
}
struct USBUSER_CLOSE_RAW_DEVICE
{
    USBUSER_REQUEST_HEADER Header;
    USB_CLOSE_RAW_DEVICE_PARAMETERS Parameters;
}
struct USB_SEND_RAW_COMMAND_PARAMETERS
{
    align (1):
    ubyte Usb_bmRequest;
    ubyte Usb_bRequest;
    ushort Usb_wVlaue;
    ushort Usb_wIndex;
    ushort Usb_wLength;
    ushort DeviceAddress;
    ushort MaximumPacketSize;
    uint Timeout;
    uint DataLength;
    int UsbdStatusCode;
    ubyte[4] Data;
}
struct USBUSER_SEND_RAW_COMMAND
{
    USBUSER_REQUEST_HEADER Header;
    USB_SEND_RAW_COMMAND_PARAMETERS Parameters;
}
struct USB_BANDWIDTH_INFO
{
    align (1):
    uint DeviceCount;
    uint TotalBusBandwidth;
    uint Total32secBandwidth;
    uint AllocedBulkAndControl;
    uint AllocedIso;
    uint AllocedInterrupt_1ms;
    uint AllocedInterrupt_2ms;
    uint AllocedInterrupt_4ms;
    uint AllocedInterrupt_8ms;
    uint AllocedInterrupt_16ms;
    uint AllocedInterrupt_32ms;
}
struct USBUSER_BANDWIDTH_INFO_REQUEST
{
    USBUSER_REQUEST_HEADER Header;
    USB_BANDWIDTH_INFO BandwidthInformation;
}
struct USB_BUS_STATISTICS_0
{
    align (1):
    uint DeviceCount;
    LARGE_INTEGER CurrentSystemTime;
    uint CurrentUsbFrame;
    uint BulkBytes;
    uint IsoBytes;
    uint InterruptBytes;
    uint ControlDataBytes;
    uint PciInterruptCount;
    uint HardResetCount;
    uint WorkerSignalCount;
    uint CommonBufferBytes;
    uint WorkerIdleTimeMs;
    BOOLEAN RootHubEnabled;
    ubyte RootHubDevicePowerState;
    ubyte Unused;
    ubyte NameIndex;
}
struct USBUSER_BUS_STATISTICS_0_REQUEST
{
    USBUSER_REQUEST_HEADER Header;
    USB_BUS_STATISTICS_0 BusStatistics0;
}
struct USB_DRIVER_VERSION_PARAMETERS
{
    align (1):
    uint DriverTrackingCode;
    uint USBDI_Version;
    uint USBUSER_Version;
    BOOLEAN CheckedPortDriver;
    BOOLEAN CheckedMiniportDriver;
    ushort USB_Version;
}
struct USBUSER_GET_DRIVER_VERSION
{
    USBUSER_REQUEST_HEADER Header;
    USB_DRIVER_VERSION_PARAMETERS Parameters;
}
struct USB_USB2HW_VERSION_PARAMETERS
{
    ubyte Usb2HwRevision;
}
struct USBUSER_GET_USB2HW_VERSION
{
    USBUSER_REQUEST_HEADER Header;
    USB_USB2HW_VERSION_PARAMETERS Parameters;
}
struct USBUSER_REFRESH_HCT_REG
{
    align (1):
    USBUSER_REQUEST_HEADER Header;
    uint Flags;
}
struct WINUSB_PIPE_INFORMATION
{
    USBD_PIPE_TYPE PipeType;
    ubyte PipeId;
    ushort MaximumPacketSize;
    ubyte Interval;
}
struct WINUSB_PIPE_INFORMATION_EX
{
    USBD_PIPE_TYPE PipeType;
    ubyte PipeId;
    ushort MaximumPacketSize;
    ubyte Interval;
    uint MaximumBytesPerInterval;
}
struct WINUSB_SETUP_PACKET
{
    align (1):
    ubyte RequestType;
    ubyte Request;
    ushort Value;
    ushort Index;
    ushort Length;
}
struct USB_START_TRACKING_FOR_TIME_SYNC_INFORMATION
{
    align (1):
    HANDLE TimeTrackingHandle;
    BOOLEAN IsStartupDelayTolerable;
}
struct USB_STOP_TRACKING_FOR_TIME_SYNC_INFORMATION
{
    align (1):
    HANDLE TimeTrackingHandle;
}
struct USB_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC_INFORMATION
{
    align (1):
    HANDLE TimeTrackingHandle;
    uint InputFrameNumber;
    uint InputMicroFrameNumber;
    LARGE_INTEGER QueryPerformanceCounterAtInputFrameOrMicroFrame;
    LARGE_INTEGER QueryPerformanceCounterFrequency;
    uint PredictedAccuracyInMicroSeconds;
    uint CurrentGenerationID;
    LARGE_INTEGER CurrentQueryPerformanceCounter;
    uint CurrentHardwareFrameNumber;
    uint CurrentHardwareMicroFrameNumber;
    uint CurrentUSBFrameNumber;
}
alias USBFN_EVENT = int;
enum : int
{
    UsbfnEventMinimum      = 0x00000000,
    UsbfnEventAttach       = 0x00000001,
    UsbfnEventReset        = 0x00000002,
    UsbfnEventDetach       = 0x00000003,
    UsbfnEventSuspend      = 0x00000004,
    UsbfnEventResume       = 0x00000005,
    UsbfnEventSetupPacket  = 0x00000006,
    UsbfnEventConfigured   = 0x00000007,
    UsbfnEventUnConfigured = 0x00000008,
    UsbfnEventPortType     = 0x00000009,
    UsbfnEventBusTearDown  = 0x0000000a,
    UsbfnEventSetInterface = 0x0000000b,
    UsbfnEventMaximum      = 0x0000000c,
}

alias USBFN_PORT_TYPE = int;
enum : int
{
    UsbfnUnknownPort                      = 0x00000000,
    UsbfnStandardDownstreamPort           = 0x00000001,
    UsbfnChargingDownstreamPort           = 0x00000002,
    UsbfnDedicatedChargingPort            = 0x00000003,
    UsbfnInvalidDedicatedChargingPort     = 0x00000004,
    UsbfnProprietaryDedicatedChargingPort = 0x00000005,
    UsbfnPortTypeMaximum                  = 0x00000006,
}

alias USBFN_BUS_SPEED = int;
enum : int
{
    UsbfnBusSpeedLow     = 0x00000000,
    UsbfnBusSpeedFull    = 0x00000001,
    UsbfnBusSpeedHigh    = 0x00000002,
    UsbfnBusSpeedSuper   = 0x00000003,
    UsbfnBusSpeedMaximum = 0x00000004,
}

alias USBFN_DIRECTION = int;
enum : int
{
    UsbfnDirectionMinimum = 0x00000000,
    UsbfnDirectionIn      = 0x00000001,
    UsbfnDirectionOut     = 0x00000002,
    UsbfnDirectionTx      = 0x00000001,
    UsbfnDirectionRx      = 0x00000002,
    UsbfnDirectionMaximum = 0x00000003,
}

alias USBFN_DEVICE_STATE = int;
enum : int
{
    UsbfnDeviceStateMinimum      = 0x00000000,
    UsbfnDeviceStateAttached     = 0x00000001,
    UsbfnDeviceStateDefault      = 0x00000002,
    UsbfnDeviceStateDetached     = 0x00000003,
    UsbfnDeviceStateAddressed    = 0x00000004,
    UsbfnDeviceStateConfigured   = 0x00000005,
    UsbfnDeviceStateSuspended    = 0x00000006,
    UsbfnDeviceStateStateMaximum = 0x00000007,
}

struct ALTERNATE_INTERFACE
{
    ushort InterfaceNumber;
    ushort AlternateInterfaceNumber;
}
struct USBFN_NOTIFICATION
{
    USBFN_EVENT Event;
    union _u_e__Union
    {
        USBFN_BUS_SPEED BusSpeed;
        USB_DEFAULT_PIPE_SETUP_PACKET SetupPacket;
        ushort ConfigurationValue;
        USBFN_PORT_TYPE PortType;
        ALTERNATE_INTERFACE AlternateInterface;
    }
}
struct USBFN_PIPE_INFORMATION
{
    USB_ENDPOINT_DESCRIPTOR EpDesc;
    uint PipeId;
}
struct USBFN_CLASS_INTERFACE
{
    ubyte InterfaceNumber;
    ubyte PipeCount;
    USBFN_PIPE_INFORMATION[16] PipeArr;
}
struct USBFN_CLASS_INFORMATION_PACKET
{
    USBFN_CLASS_INTERFACE FullSpeedClassInterface;
    USBFN_CLASS_INTERFACE HighSpeedClassInterface;
    wchar[40] InterfaceName;
    wchar[39] InterfaceGuid;
    BOOLEAN HasInterfaceGuid;
    USBFN_CLASS_INTERFACE SuperSpeedClassInterface;
}
struct USBFN_CLASS_INTERFACE_EX
{
    ubyte BaseInterfaceNumber;
    ubyte InterfaceCount;
    ubyte PipeCount;
    USBFN_PIPE_INFORMATION[16] PipeArr;
}
struct USBFN_CLASS_INFORMATION_PACKET_EX
{
    USBFN_CLASS_INTERFACE_EX FullSpeedClassInterfaceEx;
    USBFN_CLASS_INTERFACE_EX HighSpeedClassInterfaceEx;
    USBFN_CLASS_INTERFACE_EX SuperSpeedClassInterfaceEx;
    wchar[40] InterfaceName;
    wchar[39] InterfaceGuid;
    BOOLEAN HasInterfaceGuid;
}
struct USBFN_INTERFACE_INFO
{
    ubyte InterfaceNumber;
    USBFN_BUS_SPEED Speed;
    ushort Size;
    ubyte[1] InterfaceDescriptorSet;
}
struct USBFN_USB_STRING
{
    ubyte StringIndex;
    wchar[255] UsbString;
}
struct USBFN_BUS_CONFIGURATION_INFO
{
    wchar[40] ConfigurationName;
    BOOLEAN IsCurrent;
    BOOLEAN IsActive;
}
struct DRV_VERSION
{
    uint major;
    uint minor;
    uint internal;
}
struct IO_BLOCK
{
    uint uOffset;
    uint uLength;
    ubyte* pbyData;
    uint uIndex;
}
struct IO_BLOCK_EX
{
    uint uOffset;
    uint uLength;
    ubyte* pbyData;
    uint uIndex;
    ubyte bRequest;
    ubyte bmRequestType;
    ubyte fTransferDirectionIn;
}
struct CHANNEL_INFO
{
    uint EventChannelSize;
    uint uReadDataAlignment;
    uint uWriteDataAlignment;
}
alias PIPE_TYPE = int;
enum : int
{
    EVENT_PIPE      = 0x00000000,
    READ_DATA_PIPE  = 0x00000001,
    WRITE_DATA_PIPE = 0x00000002,
    ALL_PIPE        = 0x00000003,
}

struct USBSCAN_GET_DESCRIPTOR
{
    ubyte DescriptorType;
    ubyte Index;
    ushort LanguageId;
}
struct DEVICE_DESCRIPTOR
{
    ushort usVendorId;
    ushort usProductId;
    ushort usBcdDevice;
    ushort usLanguageId;
}
alias RAW_PIPE_TYPE = int;
enum : int
{
    USBSCAN_PIPE_CONTROL     = 0x00000000,
    USBSCAN_PIPE_ISOCHRONOUS = 0x00000001,
    USBSCAN_PIPE_BULK        = 0x00000002,
    USBSCAN_PIPE_INTERRUPT   = 0x00000003,
}

struct USBSCAN_PIPE_INFORMATION
{
    ushort MaximumPacketSize;
    ubyte EndpointAddress;
    ubyte Interval;
    RAW_PIPE_TYPE PipeType;
}
struct USBSCAN_PIPE_CONFIGURATION
{
    uint NumberOfPipes;
    USBSCAN_PIPE_INFORMATION[8] PipeInfo;
}
struct USBSCAN_TIMEOUT
{
    uint TimeoutRead;
    uint TimeoutWrite;
    uint TimeoutEvent;
}
